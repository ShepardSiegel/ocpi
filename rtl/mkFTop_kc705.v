//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Tue Nov 15 14:45:29 EST 2011
//
//
// Ports:
// Name                         I/O  size props
// RDY_usr_sw                     O     1 const
// led                            O     8 const
// lcd_db                         O     4
// lcd_e                          O     1
// lcd_rs                         O     1
// lcd_rw                         O     1
// debug                          O    16 reg
// RDY_debug                      O     1 const
// sys0_clkp                      I     1 clock
// sys0_clkn                      I     1 clock
// sys0_rstn                      I     1 reset
// usr_sw_i                       I     8 unused
// EN_usr_sw                      I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFTop_kc705(sys0_clkp,
		    sys0_clkn,
		    sys0_rstn,

		    usr_sw_i,
		    EN_usr_sw,
		    RDY_usr_sw,

		    led,

		    lcd_db,

		    lcd_e,

		    lcd_rs,

		    lcd_rw,

		    debug,
		    RDY_debug);
  input  sys0_clkp;
  input  sys0_clkn;
  input  sys0_rstn;

  // action method usr_sw
  input  [7 : 0] usr_sw_i;
  input  EN_usr_sw;
  output RDY_usr_sw;

  // value method led
  output [7 : 0] led;

  // value method lcd_db
  output [3 : 0] lcd_db;

  // value method lcd_e
  output lcd_e;

  // value method lcd_rs
  output lcd_rs;

  // value method lcd_rw
  output lcd_rw;

  // value method debug
  output [15 : 0] debug;
  output RDY_debug;

  // signals for module outputs
  wire [15 : 0] debug;
  wire [7 : 0] led;
  wire [3 : 0] lcd_db;
  wire RDY_debug, RDY_usr_sw, lcd_e, lcd_rs, lcd_rw;

  // register freeCnt
  reg [15 : 0] freeCnt;
  wire [15 : 0] freeCnt$D_IN;
  wire freeCnt$EN;

  // register needs_init
  reg needs_init;
  wire needs_init$D_IN, needs_init$EN;

  // ports of submodule lcd_ctrl
  wire [127 : 0] lcd_ctrl$setLine1_text, lcd_ctrl$setLine2_text;
  wire [3 : 0] lcd_ctrl$db;
  wire lcd_ctrl$EN_setLine1,
       lcd_ctrl$EN_setLine2,
       lcd_ctrl$e,
       lcd_ctrl$rs,
       lcd_ctrl$rw;

  // ports of submodule sys0_clk
  wire sys0_clk$O;

  // ports of submodule sys0_rst
  wire sys0_rst$OUT_RST_N;

  // action method usr_sw
  assign RDY_usr_sw = 1'd1 ;

  // value method led
  assign led = 8'hAA ;

  // value method lcd_db
  assign lcd_db = lcd_ctrl$db ;

  // value method lcd_e
  assign lcd_e = lcd_ctrl$e ;

  // value method lcd_rs
  assign lcd_rs = lcd_ctrl$rs ;

  // value method lcd_rw
  assign lcd_rw = lcd_ctrl$rw ;

  // value method debug
  assign debug = freeCnt ;
  assign RDY_debug = 1'd1 ;

  // submodule lcd_ctrl
  mkLCDController lcd_ctrl(.CLK(sys0_clk$O),
			   .RST_N(sys0_rst$OUT_RST_N),
			   .setLine1_text(lcd_ctrl$setLine1_text),
			   .setLine2_text(lcd_ctrl$setLine2_text),
			   .EN_setLine1(lcd_ctrl$EN_setLine1),
			   .EN_setLine2(lcd_ctrl$EN_setLine2),
			   .db(lcd_ctrl$db),
			   .e(lcd_ctrl$e),
			   .rs(lcd_ctrl$rs),
			   .rw(lcd_ctrl$rw));

  // submodule sys0_clk
  IBUFDS sys0_clk(.I(sys0_clkp), .IB(sys0_clkn), .O(sys0_clk$O));

  // submodule sys0_rst
  SyncResetA #(.RSTDELAY(32'd15)) sys0_rst(.CLK(sys0_clk$O),
					   .IN_RST_N(sys0_rstn),
					   .OUT_RST_N(sys0_rst$OUT_RST_N));

  // register freeCnt
  assign freeCnt$D_IN = freeCnt + 16'd1 ;
  assign freeCnt$EN = 1'd1 ;

  // register needs_init
  assign needs_init$D_IN = 1'd0 ;
  assign needs_init$EN = needs_init ;

  // submodule lcd_ctrl
  assign lcd_ctrl$setLine1_text = 128'h202073656C75522063696D6F74412020 ;
  assign lcd_ctrl$setLine2_text = 128'h20353037636B203A204950436E65704F ;
  assign lcd_ctrl$EN_setLine1 = needs_init ;
  assign lcd_ctrl$EN_setLine2 = needs_init ;

  // handling of inlined registers

  always@(posedge sys0_clk$O)
  begin
    if (!sys0_rst$OUT_RST_N)
      begin
        freeCnt <= `BSV_ASSIGNMENT_DELAY 16'd0;
	needs_init <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (freeCnt$EN) freeCnt <= `BSV_ASSIGNMENT_DELAY freeCnt$D_IN;
	if (needs_init$EN)
	  needs_init <= `BSV_ASSIGNMENT_DELAY needs_init$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    freeCnt = 16'hAAAA;
    needs_init = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFTop_kc705

