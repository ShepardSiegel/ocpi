//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Apr 23 19:34:36 EDT 2012
//
//
// Ports:
// Name                         I/O  size props
// led                            O     5
// debug                          O    32
// sysRst                         O     1 reset
// sys0_clkp                      I     1 clock
// sys0_clkn                      I     1 clock
// fpga_rstn                      I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFTop_n210(sys0_clkp,
		   sys0_clkn,
		   fpga_rstn,

		   led,

		   debug,

		   sysRst);
  input  sys0_clkp;
  input  sys0_clkn;
  input  fpga_rstn;

  // value method led
  output [4 : 0] led;

  // value method debug
  output [31 : 0] debug;

  // output resets
  output sysRst;

  // signals for module outputs
  wire [31 : 0] debug;
  wire [4 : 0] led;
  wire sysRst;

  // register doInit
  reg doInit;
  wire doInit$D_IN, doInit$EN;

  // register freeCnt
  reg [31 : 0] freeCnt;
  wire [31 : 0] freeCnt$D_IN;
  wire freeCnt$EN;

  // ports of submodule sys0_clk
  wire sys0_clk$O;

  // ports of submodule sys0_rst
  wire sys0_rst$OUT_RST_N;

  // remaining internal signals
  reg [4 : 0] CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1;

  // output resets
  assign sysRst = sys0_rst$OUT_RST_N ;

  // value method led
  assign led =
	     doInit ?
	       CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1 :
	       (freeCnt[24] ? 5'd30 : 5'd31) ;

  // value method debug
  assign debug =
	     { freeCnt[15],
	       freeCnt[15] ^ freeCnt[14],
	       freeCnt[14] ^ freeCnt[13],
	       freeCnt[13] ^ freeCnt[12],
	       freeCnt[12] ^ freeCnt[11],
	       freeCnt[11] ^ freeCnt[10],
	       freeCnt[10] ^ freeCnt[9],
	       freeCnt[9] ^ freeCnt[8],
	       freeCnt[8] ^ freeCnt[7],
	       freeCnt[7] ^ freeCnt[6],
	       freeCnt[6] ^ freeCnt[5],
	       freeCnt[5] ^ freeCnt[4],
	       freeCnt[4] ^ freeCnt[3],
	       freeCnt[3] ^ freeCnt[2],
	       freeCnt[2] ^ freeCnt[1],
	       freeCnt[1] ^ freeCnt[0],
	       16'h0 } ;

  // submodule sys0_clk
  IBUFDS sys0_clk(.I(sys0_clkp), .IB(sys0_clkn), .O(sys0_clk$O));

  // submodule sys0_rst
  SyncResetA #(.RSTDELAY(32'd1)) sys0_rst(.CLK(sys0_clk$O),
					  .IN_RST_N(fpga_rstn),
					  .OUT_RST_N(sys0_rst$OUT_RST_N));

  // register doInit
  assign doInit$D_IN = 1'd0 ;
  assign doInit$EN = freeCnt > 32'h08000000 ;

  // register freeCnt
  assign freeCnt$D_IN = freeCnt + 32'd1 ;
  assign freeCnt$EN = 1'd1 ;

  // remaining internal signals
  always@(freeCnt)
  begin
    case (freeCnt[26:24])
      3'd0, 3'd1, 3'd2, 3'd6, 3'd7:
	  CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1 =
	      freeCnt[22] ? 5'd3 : 5'd31;
      3'd3: CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1 = 5'd27;
      3'd4: CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1 = 5'd19;
      3'd5: CASE_freeCnt_BITS_26_TO_24_3_0_IF_freeCnt_BIT__ETC__q1 = 5'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge sys0_clk$O)
  begin
    if (!sys0_rst$OUT_RST_N)
      begin
        doInit <= `BSV_ASSIGNMENT_DELAY 1'd1;
	freeCnt <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (doInit$EN) doInit <= `BSV_ASSIGNMENT_DELAY doInit$D_IN;
	if (freeCnt$EN) freeCnt <= `BSV_ASSIGNMENT_DELAY freeCnt$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    doInit = 1'h0;
    freeCnt = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFTop_n210

