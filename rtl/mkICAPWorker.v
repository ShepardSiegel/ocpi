//
// Generated by Bluespec Compiler, version 2010.10.beta1 (build 22431, 2010-10-28)
//
// On Fri Dec 17 14:57:48 EST 2010
//
//
// Ports:
// Name                         I/O  size props
// wci_s_resp                     O    34 reg
// wci_s_SThreadBusy              O     1
// wci_s_SFlag                    O     2
// wciS0_Clk                      I     1 clock
// wciS0_MReset_n                 I     1 reset
// wci_s_req                      I    60
// wci_s_MFlag                    I     2 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkICAPWorker(wciS0_Clk,
		    wciS0_MReset_n,

		    wci_s_req,

		    wci_s_resp,

		    wci_s_SThreadBusy,

		    wci_s_SFlag,

		    wci_s_MFlag);
  parameter [0 : 0] isV6ICAP = 1'b0;
  parameter [0 : 0] hasDebugLogic = 1'b0;
  input  wciS0_Clk;
  input  wciS0_MReset_n;

  // action method wci_s_putreq
  input  [59 : 0] wci_s_req;

  // value method wci_s_resp
  output [33 : 0] wci_s_resp;

  // value method wci_s_sThreadBusy
  output wci_s_SThreadBusy;

  // value method wci_s_sFlag
  output [1 : 0] wci_s_SFlag;

  // action method wci_s_mFlag
  input  [1 : 0] wci_s_MFlag;

  // signals for module outputs
  wire [33 : 0] wci_s_resp;
  wire [1 : 0] wci_s_SFlag;
  wire wci_s_SThreadBusy;

  // inlined wires
  wire [59 : 0] wci_wciReq$wget;
  wire [33 : 0] wci_respF_x_wire$wget;
  wire [31 : 0] coutF_wDataIn$wget,
		coutF_wDataOut$wget,
		icap_icapIn_1$wget,
		icap_icapOut_1$wget;
  wire [2 : 0] wci_wEdge$wget;
  wire cinF_dClear_pw$whas,
       cinF_deq_happened$whas,
       cinF_deq_pw$whas,
       cinF_enq_pw$whas,
       cinF_sClear_pw$whas,
       coutF_pwDequeue$whas,
       coutF_pwEnqueue$whas,
       coutF_rRdPtr_pwDecrement$whas,
       coutF_rRdPtr_pwIncrement$whas,
       coutF_rWrPtr_pwDecrement$whas,
       coutF_rWrPtr_pwIncrement$whas,
       coutF_wDataIn$whas,
       coutF_wDataOut$whas,
       icap_cre$wget,
       icap_cre$whas,
       icap_cwe$wget,
       icap_cwe$whas,
       icap_icapBusy_1$wget,
       icap_icapBusy_1$whas,
       icap_icapCs_1$wget,
       icap_icapCs_1$whas,
       icap_icapIn_1$whas,
       icap_icapOut_1$whas,
       icap_icapRd_1$wget,
       icap_icapRd_1$whas,
       wci_ctlAckReg_1$wget,
       wci_ctlAckReg_1$whas,
       wci_reqF_r_clr$whas,
       wci_reqF_r_deq$whas,
       wci_reqF_r_enq$whas,
       wci_respF_dequeueing$whas,
       wci_respF_enqueueing$whas,
       wci_respF_x_wire$whas,
       wci_sFlagReg_1$wget,
       wci_sFlagReg_1$whas,
       wci_sThreadBusy_pw$whas,
       wci_wEdge$whas,
       wci_wciReq$whas,
       wci_wci_cfrd_pw$whas,
       wci_wci_cfwr_pw$whas,
       wci_wci_ctrl_pw$whas;

  // register cinF_head_wrapped
  reg cinF_head_wrapped;
  wire cinF_head_wrapped$D_IN, cinF_head_wrapped$EN;

  // register cinF_tail_wrapped
  reg cinF_tail_wrapped;
  wire cinF_tail_wrapped$D_IN, cinF_tail_wrapped$EN;

  // register cinS
  reg [31 : 0] cinS;
  wire [31 : 0] cinS$D_IN;
  wire cinS$EN;

  // register coutF_rRdPtr_rdCounter
  reg [10 : 0] coutF_rRdPtr_rdCounter;
  wire [10 : 0] coutF_rRdPtr_rdCounter$D_IN;
  wire coutF_rRdPtr_rdCounter$EN;

  // register coutF_rRdPtr_rdCounterPre
  reg [10 : 0] coutF_rRdPtr_rdCounterPre;
  wire [10 : 0] coutF_rRdPtr_rdCounterPre$D_IN;
  wire coutF_rRdPtr_rdCounterPre$EN;

  // register coutF_rRdPtr_rsCounter
  reg [10 : 0] coutF_rRdPtr_rsCounter;
  wire [10 : 0] coutF_rRdPtr_rsCounter$D_IN;
  wire coutF_rRdPtr_rsCounter$EN;

  // register coutF_rWrPtr_rdCounter
  reg [10 : 0] coutF_rWrPtr_rdCounter;
  wire [10 : 0] coutF_rWrPtr_rdCounter$D_IN;
  wire coutF_rWrPtr_rdCounter$EN;

  // register coutF_rWrPtr_rdCounterPre
  reg [10 : 0] coutF_rWrPtr_rdCounterPre;
  wire [10 : 0] coutF_rWrPtr_rdCounterPre$D_IN;
  wire coutF_rWrPtr_rdCounterPre$EN;

  // register coutF_rWrPtr_rsCounter
  reg [10 : 0] coutF_rWrPtr_rsCounter;
  wire [10 : 0] coutF_rWrPtr_rsCounter$D_IN;
  wire coutF_rWrPtr_rsCounter$EN;

  // register dwRead
  reg [31 : 0] dwRead;
  wire [31 : 0] dwRead$D_IN;
  wire dwRead$EN;

  // register dwWritten
  reg [31 : 0] dwWritten;
  wire [31 : 0] dwWritten$D_IN;
  wire dwWritten$EN;

  // register icapCtrl
  reg [31 : 0] icapCtrl;
  wire [31 : 0] icapCtrl$D_IN;
  wire icapCtrl$EN;

  // register icap_icapBusy
  reg icap_icapBusy;
  wire icap_icapBusy$D_IN, icap_icapBusy$EN;

  // register icap_icapCs
  reg icap_icapCs;
  wire icap_icapCs$D_IN, icap_icapCs$EN;

  // register icap_icapIn
  reg [31 : 0] icap_icapIn;
  wire [31 : 0] icap_icapIn$D_IN;
  wire icap_icapIn$EN;

  // register icap_icapOut
  reg [31 : 0] icap_icapOut;
  wire [31 : 0] icap_icapOut$D_IN;
  wire icap_icapOut$EN;

  // register icap_icapRd
  reg icap_icapRd;
  wire icap_icapRd$D_IN, icap_icapRd$EN;

  // register icap_inCount
  reg [31 : 0] icap_inCount;
  wire [31 : 0] icap_inCount$D_IN;
  wire icap_inCount$EN;

  // register icap_outCount
  reg [31 : 0] icap_outCount;
  wire [31 : 0] icap_outCount$D_IN;
  wire icap_outCount$EN;

  // register wci_cEdge
  reg [2 : 0] wci_cEdge;
  wire [2 : 0] wci_cEdge$D_IN;
  wire wci_cEdge$EN;

  // register wci_cState
  reg [2 : 0] wci_cState;
  wire [2 : 0] wci_cState$D_IN;
  wire wci_cState$EN;

  // register wci_ctlAckReg
  reg wci_ctlAckReg;
  wire wci_ctlAckReg$D_IN, wci_ctlAckReg$EN;

  // register wci_ctlOpActive
  reg wci_ctlOpActive;
  wire wci_ctlOpActive$D_IN, wci_ctlOpActive$EN;

  // register wci_illegalEdge
  reg wci_illegalEdge;
  wire wci_illegalEdge$D_IN, wci_illegalEdge$EN;

  // register wci_nState
  reg [2 : 0] wci_nState;
  reg [2 : 0] wci_nState$D_IN;
  wire wci_nState$EN;

  // register wci_reqF_countReg
  reg [1 : 0] wci_reqF_countReg;
  wire [1 : 0] wci_reqF_countReg$D_IN;
  wire wci_reqF_countReg$EN;

  // register wci_respF_c_r
  reg [1 : 0] wci_respF_c_r;
  wire [1 : 0] wci_respF_c_r$D_IN;
  wire wci_respF_c_r$EN;

  // register wci_respF_q_0
  reg [33 : 0] wci_respF_q_0;
  reg [33 : 0] wci_respF_q_0$D_IN;
  wire wci_respF_q_0$EN;

  // register wci_respF_q_1
  reg [33 : 0] wci_respF_q_1;
  reg [33 : 0] wci_respF_q_1$D_IN;
  wire wci_respF_q_1$EN;

  // register wci_sFlagReg
  reg wci_sFlagReg;
  wire wci_sFlagReg$D_IN, wci_sFlagReg$EN;

  // register wci_sThreadBusy_d
  reg wci_sThreadBusy_d;
  wire wci_sThreadBusy_d$D_IN, wci_sThreadBusy_d$EN;

  // ports of submodule cd
  wire cd$CLK_OUT, cd$PREEDGE;

  // ports of submodule cinF_dCombinedReset
  wire cinF_dCombinedReset$RST_OUT;

  // ports of submodule cinF_dCrossedsReset
  wire cinF_dCrossedsReset$OUT_RST_N;

  // ports of submodule cinF_dInReset
  wire cinF_dInReset$VAL;

  // ports of submodule cinF_sCombinedReset
  wire cinF_sCombinedReset$RST_OUT;

  // ports of submodule cinF_sCrosseddReset
  wire cinF_sCrosseddReset$OUT_RST_N;

  // ports of submodule cinF_sInReset
  wire cinF_sInReset$VAL;

  // ports of submodule coutF_memory
  wire [31 : 0] coutF_memory$DIA, coutF_memory$DIB, coutF_memory$DOB;
  wire [9 : 0] coutF_memory$ADDRA, coutF_memory$ADDRB;
  wire coutF_memory$ENA, coutF_memory$ENB, coutF_memory$WEA, coutF_memory$WEB;

  // ports of submodule coutF_rRdPtr_wdCounterCrossing
  wire [10 : 0] coutF_rRdPtr_wdCounterCrossing$WGET,
		coutF_rRdPtr_wdCounterCrossing$WVAL;

  // ports of submodule coutF_rWrPtr_wdCounterCrossing
  wire [10 : 0] coutF_rWrPtr_wdCounterCrossing$WGET,
		coutF_rWrPtr_wdCounterCrossing$WVAL;

  // ports of submodule cre
  wire cre$dD_OUT, cre$sD_IN, cre$sEN, cre$sRDY;

  // ports of submodule cwe
  wire cwe$dD_OUT, cwe$sD_IN, cwe$sEN, cwe$sRDY;

  // ports of submodule icap_cinF
  wire [31 : 0] icap_cinF$D_IN, icap_cinF$D_OUT;
  wire icap_cinF$CLR,
       icap_cinF$DEQ,
       icap_cinF$EMPTY_N,
       icap_cinF$ENQ,
       icap_cinF$FULL_N;

  // ports of submodule icap_coutF
  wire [31 : 0] icap_coutF$D_IN, icap_coutF$D_OUT;
  wire icap_coutF$CLR,
       icap_coutF$DEQ,
       icap_coutF$EMPTY_N,
       icap_coutF$ENQ,
       icap_coutF$FULL_N;

  // ports of submodule icap_icap
  wire [31 : 0] icap_icap$I, icap_icap$O;
  wire icap_icap$BUSY, icap_icap$CSB, icap_icap$RDWRB;

  // ports of submodule inCnt
  wire [31 : 0] inCnt$dD_OUT, inCnt$sD_IN;
  wire inCnt$sEN, inCnt$sRDY;

  // ports of submodule outCnt
  wire [31 : 0] outCnt$dD_OUT, outCnt$sD_IN;
  wire outCnt$sEN, outCnt$sRDY;

  // ports of submodule slowReset
  wire slowReset$OUT_RST_N;

  // ports of submodule wci_isReset
  wire wci_isReset$VAL;

  // ports of submodule wci_reqF
  wire [59 : 0] wci_reqF$D_IN, wci_reqF$D_OUT;
  wire wci_reqF$CLR, wci_reqF$DEQ, wci_reqF$EMPTY_N, wci_reqF$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_cinF_dClear_update_head,
       CAN_FIRE_RL_cinF_deq_update_head,
       CAN_FIRE_RL_cinF_enq_update_tail,
       CAN_FIRE_RL_cinF_reset_head,
       CAN_FIRE_RL_cinF_reset_tail,
       CAN_FIRE_RL_cinF_sClear_update_tail,
       CAN_FIRE_RL_config_read,
       CAN_FIRE_RL_config_write,
       CAN_FIRE_RL_connect_cre,
       CAN_FIRE_RL_connect_cwe,
       CAN_FIRE_RL_connect_inc,
       CAN_FIRE_RL_connect_outc,
       CAN_FIRE_RL_coutF_portA,
       CAN_FIRE_RL_coutF_portB,
       CAN_FIRE_RL_coutF_portB_read_data,
       CAN_FIRE_RL_coutF_rRdPtr_do_decrement,
       CAN_FIRE_RL_coutF_rRdPtr_do_increment,
       CAN_FIRE_RL_coutF_rRdPtr_synchronizer,
       CAN_FIRE_RL_coutF_rRdPtr_wdCounterCrossing_clock_domain_crossing,
       CAN_FIRE_RL_coutF_rWrPtr_do_decrement,
       CAN_FIRE_RL_coutF_rWrPtr_do_increment,
       CAN_FIRE_RL_coutF_rWrPtr_synchronizer,
       CAN_FIRE_RL_coutF_rWrPtr_wdCounterCrossing_clock_domain_crossing,
       CAN_FIRE_RL_icap_drive_icap_control,
       CAN_FIRE_RL_icap_icapBusy__dreg_update,
       CAN_FIRE_RL_icap_icapCs__dreg_update,
       CAN_FIRE_RL_icap_icapIn__dreg_update,
       CAN_FIRE_RL_icap_icapOut__dreg_update,
       CAN_FIRE_RL_icap_icapRd__dreg_update,
       CAN_FIRE_RL_icap_read_configuration_data,
       CAN_FIRE_RL_icap_write_configration_data,
       CAN_FIRE_RL_update_control,
       CAN_FIRE_RL_wci_cfrd,
       CAN_FIRE_RL_wci_cfwr,
       CAN_FIRE_RL_wci_ctlAckReg__dreg_update,
       CAN_FIRE_RL_wci_ctl_op_complete,
       CAN_FIRE_RL_wci_ctl_op_start,
       CAN_FIRE_RL_wci_ctrl_EiI,
       CAN_FIRE_RL_wci_ctrl_IsO,
       CAN_FIRE_RL_wci_ctrl_OrE,
       CAN_FIRE_RL_wci_reqF__updateLevelCounter,
       CAN_FIRE_RL_wci_reqF_enq,
       CAN_FIRE_RL_wci_request_decode,
       CAN_FIRE_RL_wci_respF_both,
       CAN_FIRE_RL_wci_respF_decCtr,
       CAN_FIRE_RL_wci_respF_deq,
       CAN_FIRE_RL_wci_respF_incCtr,
       CAN_FIRE_RL_wci_sFlagReg__dreg_update,
       CAN_FIRE_RL_wci_sThreadBusy_reg,
       CAN_FIRE_wci_s_mFlag,
       CAN_FIRE_wci_s_putreq,
       WILL_FIRE_RL_cinF_dClear_update_head,
       WILL_FIRE_RL_cinF_deq_update_head,
       WILL_FIRE_RL_cinF_enq_update_tail,
       WILL_FIRE_RL_cinF_reset_head,
       WILL_FIRE_RL_cinF_reset_tail,
       WILL_FIRE_RL_cinF_sClear_update_tail,
       WILL_FIRE_RL_config_read,
       WILL_FIRE_RL_config_write,
       WILL_FIRE_RL_connect_cre,
       WILL_FIRE_RL_connect_cwe,
       WILL_FIRE_RL_connect_inc,
       WILL_FIRE_RL_connect_outc,
       WILL_FIRE_RL_coutF_portA,
       WILL_FIRE_RL_coutF_portB,
       WILL_FIRE_RL_coutF_portB_read_data,
       WILL_FIRE_RL_coutF_rRdPtr_do_decrement,
       WILL_FIRE_RL_coutF_rRdPtr_do_increment,
       WILL_FIRE_RL_coutF_rRdPtr_synchronizer,
       WILL_FIRE_RL_coutF_rRdPtr_wdCounterCrossing_clock_domain_crossing,
       WILL_FIRE_RL_coutF_rWrPtr_do_decrement,
       WILL_FIRE_RL_coutF_rWrPtr_do_increment,
       WILL_FIRE_RL_coutF_rWrPtr_synchronizer,
       WILL_FIRE_RL_coutF_rWrPtr_wdCounterCrossing_clock_domain_crossing,
       WILL_FIRE_RL_icap_drive_icap_control,
       WILL_FIRE_RL_icap_icapBusy__dreg_update,
       WILL_FIRE_RL_icap_icapCs__dreg_update,
       WILL_FIRE_RL_icap_icapIn__dreg_update,
       WILL_FIRE_RL_icap_icapOut__dreg_update,
       WILL_FIRE_RL_icap_icapRd__dreg_update,
       WILL_FIRE_RL_icap_read_configuration_data,
       WILL_FIRE_RL_icap_write_configration_data,
       WILL_FIRE_RL_update_control,
       WILL_FIRE_RL_wci_cfrd,
       WILL_FIRE_RL_wci_cfwr,
       WILL_FIRE_RL_wci_ctlAckReg__dreg_update,
       WILL_FIRE_RL_wci_ctl_op_complete,
       WILL_FIRE_RL_wci_ctl_op_start,
       WILL_FIRE_RL_wci_ctrl_EiI,
       WILL_FIRE_RL_wci_ctrl_IsO,
       WILL_FIRE_RL_wci_ctrl_OrE,
       WILL_FIRE_RL_wci_reqF__updateLevelCounter,
       WILL_FIRE_RL_wci_reqF_enq,
       WILL_FIRE_RL_wci_request_decode,
       WILL_FIRE_RL_wci_respF_both,
       WILL_FIRE_RL_wci_respF_decCtr,
       WILL_FIRE_RL_wci_respF_deq,
       WILL_FIRE_RL_wci_respF_incCtr,
       WILL_FIRE_RL_wci_sFlagReg__dreg_update,
       WILL_FIRE_RL_wci_sThreadBusy_reg,
       WILL_FIRE_wci_s_mFlag,
       WILL_FIRE_wci_s_putreq;

  // inputs to muxes for submodule ports
  reg [33 : 0] MUX_wci_respF_q_0$write_1__VAL_2;
  wire [33 : 0] MUX_wci_respF_q_0$write_1__VAL_1,
		MUX_wci_respF_q_1$write_1__VAL_1,
		MUX_wci_respF_x_wire$wset_1__VAL_1,
		MUX_wci_respF_x_wire$wset_1__VAL_2;
  wire [10 : 0] MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1,
		MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1;
  wire [1 : 0] MUX_wci_respF_c_r$write_1__VAL_1,
	       MUX_wci_respF_c_r$write_1__VAL_2;
  wire MUX_wci_illegalEdge$write_1__SEL_1,
       MUX_wci_illegalEdge$write_1__VAL_1,
       MUX_wci_respF_q_0$write_1__SEL_2,
       MUX_wci_respF_q_1$write_1__SEL_2;

  // remaining internal signals
  reg [63 : 0] v__h25803, v__h3551, v__h3736, v__h3891;
  reg [31 : 0] x_data__h25731;
  wire [31 : 0] IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_OR_coutF_ETC___d738,
		IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_cout_ETC___d737,
		IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_OR_coutF_ETC___d670,
		IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_cout_ETC___d735,
		icapStatus__h25169,
		rdat__h25575,
		rdat__h25581,
		rdat__h25587,
		rdat__h25593,
		x3__h19954;
  wire [10 : 0] coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661,
		x__h15573,
		x__h17849,
		x__h21196,
		x_dReadBin__h19658,
		x_sReadBin__h19655,
		y__h16458,
		y__h18734;
  wire [9 : 0] x2__h21165;
  wire [2 : 0] x__h25668;
  wire NOT_coutF_rRdPtr_rsCounter_75_EQ_coutF_rWrPtr__ETC___d583,
       NOT_wci_respF_c_r_2_EQ_2_1_2_AND_wci_reqF_i_no_ETC___d574,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d653,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d654,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d655,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d656,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d657,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d658,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d659,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d660,
       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d666,
       coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_coutF_r_ETC___d716,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d644,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d645,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d646,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d647,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d648,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d649,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d650,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d651,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d652,
       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d681,
       coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_coutF_r_ETC___d715,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d638,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d639,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d640,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d641,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d642,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d643,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d663,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d664,
       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d665,
       z__h16502,
       z__h16509,
       z__h16516,
       z__h16523,
       z__h16530,
       z__h16537,
       z__h16544,
       z__h16551,
       z__h16558,
       z__h18778,
       z__h18785,
       z__h18792,
       z__h18799,
       z__h18806,
       z__h18813,
       z__h18820,
       z__h18827,
       z__h18834;

  // action method wci_s_putreq
  assign CAN_FIRE_wci_s_putreq = 1'd1 ;
  assign WILL_FIRE_wci_s_putreq = 1'd1 ;

  // value method wci_s_resp
  assign wci_s_resp = wci_respF_q_0 ;

  // value method wci_s_sThreadBusy
  assign wci_s_SThreadBusy = wci_reqF_countReg > 2'd1 || wci_isReset$VAL ;

  // value method wci_s_sFlag
  assign wci_s_SFlag = { 1'd1, wci_sFlagReg } ;

  // action method wci_s_mFlag
  assign CAN_FIRE_wci_s_mFlag = 1'd1 ;
  assign WILL_FIRE_wci_s_mFlag = 1'd1 ;

  // submodule cd
  ClockDiv #(.width(32'd1),
	     .lower(32'd0),
	     .upper(32'd1),
	     .offset(32'd0)) cd(.CLK_IN(wciS0_Clk),
				.RST_N(wciS0_MReset_n),
				.PREEDGE(cd$PREEDGE),
				.CLK_OUT(cd$CLK_OUT));

  // submodule cinF_dCombinedReset
  ResetEither cinF_dCombinedReset(.A_RST(slowReset$OUT_RST_N),
				  .B_RST(cinF_dCrossedsReset$OUT_RST_N),
				  .RST_OUT(cinF_dCombinedReset$RST_OUT));

  // submodule cinF_dCrossedsReset
  SyncReset0 cinF_dCrossedsReset(.IN_RST_N(wciS0_MReset_n),
				 .OUT_RST_N(cinF_dCrossedsReset$OUT_RST_N));

  // submodule cinF_dInReset
  ResetToBool cinF_dInReset(.RST(cinF_dCombinedReset$RST_OUT),
			    .VAL(cinF_dInReset$VAL));

  // submodule cinF_sCombinedReset
  ResetEither cinF_sCombinedReset(.A_RST(wciS0_MReset_n),
				  .B_RST(cinF_sCrosseddReset$OUT_RST_N),
				  .RST_OUT(cinF_sCombinedReset$RST_OUT));

  // submodule cinF_sCrosseddReset
  SyncReset0 cinF_sCrosseddReset(.IN_RST_N(slowReset$OUT_RST_N),
				 .OUT_RST_N(cinF_sCrosseddReset$OUT_RST_N));

  // submodule cinF_sInReset
  ResetToBool cinF_sInReset(.RST(cinF_sCombinedReset$RST_OUT),
			    .VAL(cinF_sInReset$VAL));

  // submodule coutF_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd32),
	  .MEMSIZE(11'd1024)) coutF_memory(.CLKA(cd$CLK_OUT),
					   .CLKB(wciS0_Clk),
					   .ADDRA(coutF_memory$ADDRA),
					   .ADDRB(coutF_memory$ADDRB),
					   .DIA(coutF_memory$DIA),
					   .DIB(coutF_memory$DIB),
					   .WEA(coutF_memory$WEA),
					   .WEB(coutF_memory$WEB),
					   .ENA(coutF_memory$ENA),
					   .ENB(coutF_memory$ENB),
					   .DOA(),
					   .DOB(coutF_memory$DOB));

  // submodule coutF_rRdPtr_wdCounterCrossing
  BypassCrossingWire #(.width(32'd11)) coutF_rRdPtr_wdCounterCrossing(.WVAL(coutF_rRdPtr_wdCounterCrossing$WVAL),
								      .WGET(coutF_rRdPtr_wdCounterCrossing$WGET));

  // submodule coutF_rWrPtr_wdCounterCrossing
  BypassCrossingWire #(.width(32'd11)) coutF_rWrPtr_wdCounterCrossing(.WVAL(coutF_rWrPtr_wdCounterCrossing$WVAL),
								      .WGET(coutF_rWrPtr_wdCounterCrossing$WGET));

  // submodule cre
  SyncRegister #(.width(32'd1), .init(1'd0)) cre(.sCLK(wciS0_Clk),
						 .dCLK(cd$CLK_OUT),
						 .sRST_N(wciS0_MReset_n),
						 .sD_IN(cre$sD_IN),
						 .sEN(cre$sEN),
						 .dD_OUT(cre$dD_OUT),
						 .sRDY(cre$sRDY));

  // submodule cwe
  SyncRegister #(.width(32'd1), .init(1'd0)) cwe(.sCLK(wciS0_Clk),
						 .dCLK(cd$CLK_OUT),
						 .sRST_N(wciS0_MReset_n),
						 .sD_IN(cwe$sD_IN),
						 .sEN(cwe$sEN),
						 .dD_OUT(cwe$dD_OUT),
						 .sRDY(cwe$sRDY));

  // submodule icap_cinF
  FIFO2 #(.width(32'd32),
	  .guarded(32'd1)) icap_cinF(.RST_N(slowReset$OUT_RST_N),
				     .CLK(cd$CLK_OUT),
				     .D_IN(icap_cinF$D_IN),
				     .ENQ(icap_cinF$ENQ),
				     .DEQ(icap_cinF$DEQ),
				     .CLR(icap_cinF$CLR),
				     .D_OUT(icap_cinF$D_OUT),
				     .FULL_N(icap_cinF$FULL_N),
				     .EMPTY_N(icap_cinF$EMPTY_N));

  // submodule icap_coutF
  FIFO2 #(.width(32'd32),
	  .guarded(32'd1)) icap_coutF(.RST_N(slowReset$OUT_RST_N),
				      .CLK(cd$CLK_OUT),
				      .D_IN(icap_coutF$D_IN),
				      .ENQ(icap_coutF$ENQ),
				      .DEQ(icap_coutF$DEQ),
				      .CLR(icap_coutF$CLR),
				      .D_OUT(icap_coutF$D_OUT),
				      .FULL_N(icap_coutF$FULL_N),
				      .EMPTY_N(icap_coutF$EMPTY_N));

  // submodule icap_icap
  ICAP_VIRTEX6 #(.ICAP_WIDTH("X32")) icap_icap(.CLK(cd$CLK_OUT),
					       .CSB(icap_icap$CSB),
					       .I(icap_icap$I),
					       .RDWRB(icap_icap$RDWRB),
					       .O(icap_icap$O),
					       .BUSY(icap_icap$BUSY));

  // submodule inCnt
  SyncRegister #(.width(32'd32), .init(32'd0)) inCnt(.sCLK(cd$CLK_OUT),
						     .dCLK(wciS0_Clk),
						     .sRST_N(slowReset$OUT_RST_N),
						     .sD_IN(inCnt$sD_IN),
						     .sEN(inCnt$sEN),
						     .dD_OUT(inCnt$dD_OUT),
						     .sRDY(inCnt$sRDY));

  // submodule outCnt
  SyncRegister #(.width(32'd32), .init(32'd0)) outCnt(.sCLK(cd$CLK_OUT),
						      .dCLK(wciS0_Clk),
						      .sRST_N(slowReset$OUT_RST_N),
						      .sD_IN(outCnt$sD_IN),
						      .sEN(outCnt$sEN),
						      .dD_OUT(outCnt$dD_OUT),
						      .sRDY(outCnt$sRDY));

  // submodule slowReset
  SyncResetA #(.RSTDELAY(32'd1)) slowReset(.CLK(cd$CLK_OUT),
					   .IN_RST_N(wciS0_MReset_n),
					   .OUT_RST_N(slowReset$OUT_RST_N));

  // submodule wci_isReset
  ResetToBool wci_isReset(.RST(wciS0_MReset_n), .VAL(wci_isReset$VAL));

  // submodule wci_reqF
  SizedFIFO #(.p1width(32'd60),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) wci_reqF(.RST_N(wciS0_MReset_n),
					.CLK(wciS0_Clk),
					.D_IN(wci_reqF$D_IN),
					.ENQ(wci_reqF$ENQ),
					.DEQ(wci_reqF$DEQ),
					.CLR(wci_reqF$CLR),
					.D_OUT(wci_reqF$D_OUT),
					.FULL_N(),
					.EMPTY_N(wci_reqF$EMPTY_N));

  // rule RL_update_control
  assign CAN_FIRE_RL_update_control =
	     cwe$sRDY && cre$sRDY && wci_cState == 3'd2 ;
  assign WILL_FIRE_RL_update_control = CAN_FIRE_RL_update_control ;

  // rule RL_connect_cwe
  assign CAN_FIRE_RL_connect_cwe = 1'd1 ;
  assign WILL_FIRE_RL_connect_cwe = 1'd1 ;

  // rule RL_connect_cre
  assign CAN_FIRE_RL_connect_cre = 1'd1 ;
  assign WILL_FIRE_RL_connect_cre = 1'd1 ;

  // rule RL_connect_inc
  assign CAN_FIRE_RL_connect_inc = inCnt$sRDY ;
  assign WILL_FIRE_RL_connect_inc = inCnt$sRDY ;

  // rule RL_connect_outc
  assign CAN_FIRE_RL_connect_outc = outCnt$sRDY ;
  assign WILL_FIRE_RL_connect_outc = outCnt$sRDY ;

  // rule RL_config_write
  assign CAN_FIRE_RL_config_write =
	     cinF_head_wrapped != cinF_tail_wrapped && !cinF_dInReset$VAL &&
	     icap_cinF$FULL_N ;
  assign WILL_FIRE_RL_config_write = CAN_FIRE_RL_config_write ;

  // rule RL_config_read
  assign CAN_FIRE_RL_config_read =
	     coutF_rWrPtr_rsCounter !=
	     { coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[10],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[10] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[9],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[9] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[8],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[8] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[7],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[7] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[6],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[6] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[5],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[5] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[4],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[4] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[3],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[3] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[2],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[2] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[1],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[1] ^
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661[0] } &&
	     icap_coutF$EMPTY_N ;
  assign WILL_FIRE_RL_config_read = CAN_FIRE_RL_config_read ;

  // rule RL_wci_request_decode
  assign CAN_FIRE_RL_wci_request_decode = wci_reqF$EMPTY_N ;
  assign WILL_FIRE_RL_wci_request_decode = wci_reqF$EMPTY_N ;

  // rule RL_wci_sThreadBusy_reg
  assign CAN_FIRE_RL_wci_sThreadBusy_reg = 1'd1 ;
  assign WILL_FIRE_RL_wci_sThreadBusy_reg = 1'd1 ;

  // rule RL_wci_reqF_enq
  assign CAN_FIRE_RL_wci_reqF_enq = wci_s_req[59:57] != 3'd0 ;
  assign WILL_FIRE_RL_wci_reqF_enq = CAN_FIRE_RL_wci_reqF_enq ;

  // rule RL_wci_respF_deq
  assign CAN_FIRE_RL_wci_respF_deq = 1'd1 ;
  assign WILL_FIRE_RL_wci_respF_deq = 1'd1 ;

  // rule RL_wci_cfwr
  assign CAN_FIRE_RL_wci_cfwr =
	     NOT_wci_respF_c_r_2_EQ_2_1_2_AND_wci_reqF_i_no_ETC___d574 &&
	     wci_wci_cfwr_pw$whas ;
  assign WILL_FIRE_RL_wci_cfwr =
	     CAN_FIRE_RL_wci_cfwr && !WILL_FIRE_RL_wci_ctl_op_start &&
	     !WILL_FIRE_RL_wci_ctl_op_complete ;

  // rule RL_wci_ctl_op_start
  assign CAN_FIRE_RL_wci_ctl_op_start =
	     wci_reqF$EMPTY_N && wci_wci_ctrl_pw$whas ;
  assign WILL_FIRE_RL_wci_ctl_op_start =
	     CAN_FIRE_RL_wci_ctl_op_start &&
	     !WILL_FIRE_RL_wci_ctl_op_complete ;

  // rule RL_wci_ctrl_IsO
  assign CAN_FIRE_RL_wci_ctrl_IsO =
	     wci_wci_ctrl_pw$whas && WILL_FIRE_RL_wci_ctl_op_start &&
	     wci_cState == 3'd1 &&
	     wci_reqF$D_OUT[36:34] == 3'd1 ;
  assign WILL_FIRE_RL_wci_ctrl_IsO = CAN_FIRE_RL_wci_ctrl_IsO ;

  // rule RL_wci_ctrl_EiI
  assign CAN_FIRE_RL_wci_ctrl_EiI =
	     wci_wci_ctrl_pw$whas && WILL_FIRE_RL_wci_ctl_op_start &&
	     wci_cState == 3'd0 &&
	     wci_reqF$D_OUT[36:34] == 3'd0 ;
  assign WILL_FIRE_RL_wci_ctrl_EiI = CAN_FIRE_RL_wci_ctrl_EiI ;

  // rule RL_wci_ctrl_OrE
  assign CAN_FIRE_RL_wci_ctrl_OrE =
	     wci_wci_ctrl_pw$whas && WILL_FIRE_RL_wci_ctl_op_start &&
	     wci_cState == 3'd2 &&
	     wci_reqF$D_OUT[36:34] == 3'd3 ;
  assign WILL_FIRE_RL_wci_ctrl_OrE = CAN_FIRE_RL_wci_ctrl_OrE ;

  // rule RL_wci_ctl_op_complete
  assign CAN_FIRE_RL_wci_ctl_op_complete =
	     wci_respF_c_r != 2'd2 && wci_ctlOpActive && wci_ctlAckReg ;
  assign WILL_FIRE_RL_wci_ctl_op_complete = CAN_FIRE_RL_wci_ctl_op_complete ;

  // rule RL_wci_sFlagReg__dreg_update
  assign CAN_FIRE_RL_wci_sFlagReg__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_wci_sFlagReg__dreg_update = 1'd1 ;

  // rule RL_wci_ctlAckReg__dreg_update
  assign CAN_FIRE_RL_wci_ctlAckReg__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_wci_ctlAckReg__dreg_update = 1'd1 ;

  // rule RL_icap_drive_icap_control
  assign CAN_FIRE_RL_icap_drive_icap_control = 1'd1 ;
  assign WILL_FIRE_RL_icap_drive_icap_control = 1'd1 ;

  // rule RL_icap_write_configration_data
  assign CAN_FIRE_RL_icap_write_configration_data =
	     icap_cinF$EMPTY_N && cwe$dD_OUT && !cre$dD_OUT ;
  assign WILL_FIRE_RL_icap_write_configration_data =
	     CAN_FIRE_RL_icap_write_configration_data ;

  // rule RL_icap_read_configuration_data
  assign CAN_FIRE_RL_icap_read_configuration_data =
	     (icap_icapBusy || icap_coutF$FULL_N) && cre$dD_OUT &&
	     !cwe$dD_OUT ;
  assign WILL_FIRE_RL_icap_read_configuration_data =
	     CAN_FIRE_RL_icap_read_configuration_data ;

  // rule RL_icap_icapCs__dreg_update
  assign CAN_FIRE_RL_icap_icapCs__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_icap_icapCs__dreg_update = 1'd1 ;

  // rule RL_icap_icapRd__dreg_update
  assign CAN_FIRE_RL_icap_icapRd__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_icap_icapRd__dreg_update = 1'd1 ;

  // rule RL_icap_icapIn__dreg_update
  assign CAN_FIRE_RL_icap_icapIn__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_icap_icapIn__dreg_update = 1'd1 ;

  // rule RL_icap_icapOut__dreg_update
  assign CAN_FIRE_RL_icap_icapOut__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_icap_icapOut__dreg_update = 1'd1 ;

  // rule RL_icap_icapBusy__dreg_update
  assign CAN_FIRE_RL_icap_icapBusy__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_icap_icapBusy__dreg_update = 1'd1 ;

  // rule RL_cinF_enq_update_tail
  assign CAN_FIRE_RL_cinF_enq_update_tail =
	     !cinF_sInReset$VAL && cinF_enq_pw$whas ;
  assign WILL_FIRE_RL_cinF_enq_update_tail =
	     CAN_FIRE_RL_cinF_enq_update_tail ;

  // rule RL_cinF_sClear_update_tail
  assign CAN_FIRE_RL_cinF_sClear_update_tail = 1'b0 ;
  assign WILL_FIRE_RL_cinF_sClear_update_tail = 1'b0 ;

  // rule RL_cinF_reset_tail
  assign CAN_FIRE_RL_cinF_reset_tail = cinF_sInReset$VAL ;
  assign WILL_FIRE_RL_cinF_reset_tail = cinF_sInReset$VAL ;

  // rule RL_cinF_deq_update_head
  assign CAN_FIRE_RL_cinF_deq_update_head =
	     !cinF_dInReset$VAL && CAN_FIRE_RL_config_write ;
  assign WILL_FIRE_RL_cinF_deq_update_head =
	     CAN_FIRE_RL_cinF_deq_update_head ;

  // rule RL_cinF_dClear_update_head
  assign CAN_FIRE_RL_cinF_dClear_update_head = 1'b0 ;
  assign WILL_FIRE_RL_cinF_dClear_update_head = 1'b0 ;

  // rule RL_cinF_reset_head
  assign CAN_FIRE_RL_cinF_reset_head = cinF_dInReset$VAL ;
  assign WILL_FIRE_RL_cinF_reset_head = cinF_dInReset$VAL ;

  // rule RL_coutF_portA
  assign CAN_FIRE_RL_coutF_portA = 1'd1 ;
  assign WILL_FIRE_RL_coutF_portA = 1'd1 ;

  // rule RL_coutF_portB_read_data
  assign CAN_FIRE_RL_coutF_portB_read_data = 1'd1 ;
  assign WILL_FIRE_RL_coutF_portB_read_data = 1'd1 ;

  // rule RL_wci_cfrd
  assign CAN_FIRE_RL_wci_cfrd =
	     wci_respF_c_r != 2'd2 && wci_reqF$EMPTY_N &&
	     (wci_reqF$D_OUT[51:32] != 20'h0000C ||
	      NOT_coutF_rRdPtr_rsCounter_75_EQ_coutF_rWrPtr__ETC___d583) &&
	     wci_wci_cfrd_pw$whas ;
  assign WILL_FIRE_RL_wci_cfrd =
	     CAN_FIRE_RL_wci_cfrd && !WILL_FIRE_RL_wci_ctl_op_start &&
	     !WILL_FIRE_RL_wci_ctl_op_complete ;

  // rule RL_wci_reqF__updateLevelCounter
  assign CAN_FIRE_RL_wci_reqF__updateLevelCounter =
	     (wci_s_req[59:57] != 3'd0) != wci_reqF_r_deq$whas ;
  assign WILL_FIRE_RL_wci_reqF__updateLevelCounter =
	     CAN_FIRE_RL_wci_reqF__updateLevelCounter ;

  // rule RL_wci_respF_incCtr
  assign CAN_FIRE_RL_wci_respF_incCtr =
	     ((wci_respF_c_r == 2'd0) ?
		wci_respF_x_wire$whas :
		wci_respF_c_r != 2'd1 || wci_respF_x_wire$whas) &&
	     wci_respF_enqueueing$whas &&
	     !(wci_respF_c_r != 2'd0) ;
  assign WILL_FIRE_RL_wci_respF_incCtr = CAN_FIRE_RL_wci_respF_incCtr ;

  // rule RL_wci_respF_decCtr
  assign CAN_FIRE_RL_wci_respF_decCtr =
	     wci_respF_c_r != 2'd0 && !wci_respF_enqueueing$whas ;
  assign WILL_FIRE_RL_wci_respF_decCtr = CAN_FIRE_RL_wci_respF_decCtr ;

  // rule RL_wci_respF_both
  assign CAN_FIRE_RL_wci_respF_both =
	     ((wci_respF_c_r == 2'd1) ?
		wci_respF_x_wire$whas :
		wci_respF_c_r != 2'd2 || wci_respF_x_wire$whas) &&
	     wci_respF_c_r != 2'd0 &&
	     wci_respF_enqueueing$whas ;
  assign WILL_FIRE_RL_wci_respF_both = CAN_FIRE_RL_wci_respF_both ;

  // rule RL_coutF_portB
  assign CAN_FIRE_RL_coutF_portB = 1'd1 ;
  assign WILL_FIRE_RL_coutF_portB = 1'd1 ;

  // rule RL_coutF_rWrPtr_synchronizer
  assign CAN_FIRE_RL_coutF_rWrPtr_synchronizer = 1'd1 ;
  assign WILL_FIRE_RL_coutF_rWrPtr_synchronizer = 1'd1 ;

  // rule RL_coutF_rWrPtr_wdCounterCrossing_clock_domain_crossing
  assign CAN_FIRE_RL_coutF_rWrPtr_wdCounterCrossing_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_coutF_rWrPtr_wdCounterCrossing_clock_domain_crossing =
	     1'd1 ;

  // rule RL_coutF_rWrPtr_do_increment
  assign CAN_FIRE_RL_coutF_rWrPtr_do_increment = CAN_FIRE_RL_config_read ;
  assign WILL_FIRE_RL_coutF_rWrPtr_do_increment = CAN_FIRE_RL_config_read ;

  // rule RL_coutF_rWrPtr_do_decrement
  assign CAN_FIRE_RL_coutF_rWrPtr_do_decrement = 1'b0 ;
  assign WILL_FIRE_RL_coutF_rWrPtr_do_decrement = 1'b0 ;

  // rule RL_coutF_rRdPtr_synchronizer
  assign CAN_FIRE_RL_coutF_rRdPtr_synchronizer = 1'd1 ;
  assign WILL_FIRE_RL_coutF_rRdPtr_synchronizer = 1'd1 ;

  // rule RL_coutF_rRdPtr_wdCounterCrossing_clock_domain_crossing
  assign CAN_FIRE_RL_coutF_rRdPtr_wdCounterCrossing_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_coutF_rRdPtr_wdCounterCrossing_clock_domain_crossing =
	     1'd1 ;

  // rule RL_coutF_rRdPtr_do_increment
  assign CAN_FIRE_RL_coutF_rRdPtr_do_increment = coutF_pwDequeue$whas ;
  assign WILL_FIRE_RL_coutF_rRdPtr_do_increment = coutF_pwDequeue$whas ;

  // rule RL_coutF_rRdPtr_do_decrement
  assign CAN_FIRE_RL_coutF_rRdPtr_do_decrement = 1'b0 ;
  assign WILL_FIRE_RL_coutF_rRdPtr_do_decrement = 1'b0 ;

  // inputs to muxes for submodule ports
  assign MUX_wci_illegalEdge$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_ctl_op_start &&
	     (wci_reqF$D_OUT[36:34] == 3'd0 && wci_cState != 3'd0 ||
	      wci_reqF$D_OUT[36:34] == 3'd1 && wci_cState != 3'd1 &&
	      wci_cState != 3'd3 ||
	      wci_reqF$D_OUT[36:34] == 3'd2 && wci_cState != 3'd2 ||
	      wci_reqF$D_OUT[36:34] == 3'd3 && wci_cState != 3'd3 &&
	      wci_cState != 3'd2 &&
	      wci_cState != 3'd1 ||
	      wci_reqF$D_OUT[36:34] == 3'd4 ||
	      wci_reqF$D_OUT[36:34] == 3'd5 ||
	      wci_reqF$D_OUT[36:34] == 3'd6 ||
	      wci_reqF$D_OUT[36:34] == 3'd7) ;
  assign MUX_wci_respF_q_0$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_respF_incCtr && wci_respF_c_r == 2'd0 ;
  assign MUX_wci_respF_q_1$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_respF_incCtr && wci_respF_c_r == 2'd1 ;
  assign MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1 =
	     (~coutF_rRdPtr_rsCounter[IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_cout_ETC___d737[3:0]]) ?
	       coutF_rRdPtr_rsCounter | x__h17849 :
	       coutF_rRdPtr_rsCounter & y__h18734 ;
  assign MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1 =
	     (~coutF_rWrPtr_rsCounter[IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_cout_ETC___d735[3:0]]) ?
	       coutF_rWrPtr_rsCounter | x__h15573 :
	       coutF_rWrPtr_rsCounter & y__h16458 ;
  assign MUX_wci_illegalEdge$write_1__VAL_1 =
	     wci_reqF$D_OUT[36:34] != 3'd4 && wci_reqF$D_OUT[36:34] != 3'd5 &&
	     wci_reqF$D_OUT[36:34] != 3'd6 ;
  assign MUX_wci_respF_c_r$write_1__VAL_1 = wci_respF_c_r + 2'd1 ;
  assign MUX_wci_respF_c_r$write_1__VAL_2 = wci_respF_c_r - 2'd1 ;
  assign MUX_wci_respF_q_0$write_1__VAL_1 =
	     (wci_respF_c_r == 2'd1) ?
	       MUX_wci_respF_q_0$write_1__VAL_2 :
	       wci_respF_q_1 ;
  always@(WILL_FIRE_RL_wci_ctl_op_complete or
	  MUX_wci_respF_x_wire$wset_1__VAL_1 or
	  WILL_FIRE_RL_wci_cfrd or
	  MUX_wci_respF_x_wire$wset_1__VAL_2 or WILL_FIRE_RL_wci_cfwr)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_ctl_op_complete:
	  MUX_wci_respF_q_0$write_1__VAL_2 =
	      MUX_wci_respF_x_wire$wset_1__VAL_1;
      WILL_FIRE_RL_wci_cfrd:
	  MUX_wci_respF_q_0$write_1__VAL_2 =
	      MUX_wci_respF_x_wire$wset_1__VAL_2;
      WILL_FIRE_RL_wci_cfwr: MUX_wci_respF_q_0$write_1__VAL_2 = 34'h1C0DE4201;
      default: MUX_wci_respF_q_0$write_1__VAL_2 =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign MUX_wci_respF_q_1$write_1__VAL_1 =
	     (wci_respF_c_r == 2'd2) ?
	       MUX_wci_respF_q_0$write_1__VAL_2 :
	       34'h0AAAAAAAA ;
  assign MUX_wci_respF_x_wire$wset_1__VAL_1 =
	     wci_illegalEdge ? 34'h3C0DE4202 : 34'h1C0DE4201 ;
  assign MUX_wci_respF_x_wire$wset_1__VAL_2 = { 2'd1, x_data__h25731 } ;

  // inlined wires
  assign wci_wciReq$wget = wci_s_req ;
  assign wci_wciReq$whas = 1'd1 ;
  assign wci_respF_x_wire$wget = MUX_wci_respF_q_0$write_1__VAL_2 ;
  assign wci_respF_x_wire$whas =
	     WILL_FIRE_RL_wci_ctl_op_complete || WILL_FIRE_RL_wci_cfrd ||
	     WILL_FIRE_RL_wci_cfwr ;
  assign wci_wEdge$wget = wci_reqF$D_OUT[36:34] ;
  assign wci_wEdge$whas = WILL_FIRE_RL_wci_ctl_op_start ;
  assign wci_sFlagReg_1$wget = 1'b0 ;
  assign wci_sFlagReg_1$whas = 1'b0 ;
  assign wci_ctlAckReg_1$wget = 1'd1 ;
  assign wci_ctlAckReg_1$whas =
	     WILL_FIRE_RL_wci_ctrl_OrE || WILL_FIRE_RL_wci_ctrl_IsO ||
	     WILL_FIRE_RL_wci_ctrl_EiI ;
  assign icap_icapCs_1$wget = 1'd1 ;
  assign icap_icapCs_1$whas =
	     WILL_FIRE_RL_icap_read_configuration_data ||
	     WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd_1$wget = !WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd_1$whas =
	     WILL_FIRE_RL_icap_write_configration_data ||
	     WILL_FIRE_RL_icap_read_configuration_data ;
  assign icap_icapIn_1$wget =
	     { icap_cinF$D_OUT[24],
	       icap_cinF$D_OUT[25],
	       icap_cinF$D_OUT[26],
	       icap_cinF$D_OUT[27],
	       icap_cinF$D_OUT[28],
	       icap_cinF$D_OUT[29],
	       icap_cinF$D_OUT[30],
	       icap_cinF$D_OUT[31],
	       icap_cinF$D_OUT[16],
	       icap_cinF$D_OUT[17],
	       icap_cinF$D_OUT[18],
	       icap_cinF$D_OUT[19],
	       icap_cinF$D_OUT[20],
	       icap_cinF$D_OUT[21],
	       icap_cinF$D_OUT[22],
	       icap_cinF$D_OUT[23],
	       icap_cinF$D_OUT[8],
	       icap_cinF$D_OUT[9],
	       icap_cinF$D_OUT[10],
	       icap_cinF$D_OUT[11],
	       icap_cinF$D_OUT[12],
	       icap_cinF$D_OUT[13],
	       icap_cinF$D_OUT[14],
	       icap_cinF$D_OUT[15],
	       icap_cinF$D_OUT[0],
	       icap_cinF$D_OUT[1],
	       icap_cinF$D_OUT[2],
	       icap_cinF$D_OUT[3],
	       icap_cinF$D_OUT[4],
	       icap_cinF$D_OUT[5],
	       icap_cinF$D_OUT[6],
	       icap_cinF$D_OUT[7] } ;
  assign icap_icapIn_1$whas = CAN_FIRE_RL_icap_write_configration_data ;
  assign icap_icapOut_1$wget = icap_icap$O ;
  assign icap_icapOut_1$whas = 1'd1 ;
  assign icap_icapBusy_1$wget = icap_icap$BUSY ;
  assign icap_icapBusy_1$whas = 1'd1 ;
  assign icap_cwe$wget = cwe$dD_OUT ;
  assign icap_cwe$whas = 1'd1 ;
  assign icap_cre$wget = cre$dD_OUT ;
  assign icap_cre$whas = 1'd1 ;
  assign coutF_wDataIn$wget = icap_coutF$D_OUT ;
  assign coutF_wDataIn$whas = CAN_FIRE_RL_config_read ;
  assign coutF_wDataOut$wget = coutF_memory$DOB ;
  assign coutF_wDataOut$whas = 1'd1 ;
  assign wci_reqF_r_enq$whas = CAN_FIRE_RL_wci_reqF_enq ;
  assign wci_reqF_r_deq$whas =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_ctl_op_start ;
  assign wci_reqF_r_clr$whas = 1'b0 ;
  assign wci_respF_enqueueing$whas =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_ctl_op_complete ;
  assign wci_respF_dequeueing$whas = wci_respF_c_r != 2'd0 ;
  assign wci_sThreadBusy_pw$whas = 1'b0 ;
  assign wci_wci_cfwr_pw$whas =
	     wci_reqF$EMPTY_N && wci_reqF$D_OUT[56] &&
	     wci_reqF$D_OUT[59:57] == 3'd1 ;
  assign wci_wci_cfrd_pw$whas =
	     wci_reqF$EMPTY_N && wci_reqF$D_OUT[56] &&
	     wci_reqF$D_OUT[59:57] == 3'd2 ;
  assign wci_wci_ctrl_pw$whas =
	     wci_reqF$EMPTY_N && !wci_reqF$D_OUT[56] &&
	     wci_reqF$D_OUT[59:57] == 3'd2 ;
  assign cinF_enq_pw$whas =
	     WILL_FIRE_RL_wci_cfwr && wci_reqF$D_OUT[51:32] == 20'h00008 ;
  assign cinF_deq_pw$whas = CAN_FIRE_RL_config_write ;
  assign cinF_sClear_pw$whas = 1'b0 ;
  assign cinF_dClear_pw$whas = 1'b0 ;
  assign cinF_deq_happened$whas = 1'b0 ;
  assign coutF_rWrPtr_pwIncrement$whas = CAN_FIRE_RL_config_read ;
  assign coutF_rWrPtr_pwDecrement$whas = 1'b0 ;
  assign coutF_rRdPtr_pwIncrement$whas = coutF_pwDequeue$whas ;
  assign coutF_rRdPtr_pwDecrement$whas = 1'b0 ;
  assign coutF_pwDequeue$whas =
	     WILL_FIRE_RL_wci_cfrd && wci_reqF$D_OUT[51:32] == 20'h0000C ;
  assign coutF_pwEnqueue$whas = CAN_FIRE_RL_config_read ;

  // register cinF_head_wrapped
  assign cinF_head_wrapped$D_IN =
	     WILL_FIRE_RL_cinF_deq_update_head && !cinF_head_wrapped ;
  assign cinF_head_wrapped$EN =
	     WILL_FIRE_RL_cinF_deq_update_head || cinF_dInReset$VAL ;

  // register cinF_tail_wrapped
  assign cinF_tail_wrapped$D_IN =
	     WILL_FIRE_RL_cinF_enq_update_tail && !cinF_tail_wrapped ;
  assign cinF_tail_wrapped$EN =
	     WILL_FIRE_RL_cinF_enq_update_tail || cinF_sInReset$VAL ;

  // register cinS
  assign cinS$D_IN = wci_reqF$D_OUT[31:0] ;
  assign cinS$EN = cinF_enq_pw$whas ;

  // register coutF_rRdPtr_rdCounter
  assign coutF_rRdPtr_rdCounter$D_IN = coutF_rRdPtr_rdCounterPre ;
  assign coutF_rRdPtr_rdCounter$EN = 1'd1 ;

  // register coutF_rRdPtr_rdCounterPre
  assign coutF_rRdPtr_rdCounterPre$D_IN =
	     coutF_rRdPtr_wdCounterCrossing$WGET ;
  assign coutF_rRdPtr_rdCounterPre$EN = 1'd1 ;

  // register coutF_rRdPtr_rsCounter
  assign coutF_rRdPtr_rsCounter$D_IN =
	     MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1 ;
  assign coutF_rRdPtr_rsCounter$EN = coutF_pwDequeue$whas ;

  // register coutF_rWrPtr_rdCounter
  assign coutF_rWrPtr_rdCounter$D_IN = coutF_rWrPtr_rdCounterPre ;
  assign coutF_rWrPtr_rdCounter$EN = 1'd1 ;

  // register coutF_rWrPtr_rdCounterPre
  assign coutF_rWrPtr_rdCounterPre$D_IN =
	     coutF_rWrPtr_wdCounterCrossing$WGET ;
  assign coutF_rWrPtr_rdCounterPre$EN = 1'd1 ;

  // register coutF_rWrPtr_rsCounter
  assign coutF_rWrPtr_rsCounter$D_IN =
	     MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1 ;
  assign coutF_rWrPtr_rsCounter$EN = CAN_FIRE_RL_config_read ;

  // register dwRead
  assign dwRead$D_IN = 32'h0 ;
  assign dwRead$EN = 1'b0 ;

  // register dwWritten
  assign dwWritten$D_IN = 32'h0 ;
  assign dwWritten$EN = 1'b0 ;

  // register icapCtrl
  assign icapCtrl$D_IN = wci_reqF$D_OUT[31:0] ;
  assign icapCtrl$EN =
	     WILL_FIRE_RL_wci_cfwr && wci_reqF$D_OUT[51:32] == 20'h00004 ;

  // register icap_icapBusy
  assign icap_icapBusy$D_IN = icap_icap$BUSY ;
  assign icap_icapBusy$EN = 1'd1 ;

  // register icap_icapCs
  assign icap_icapCs$D_IN = icap_icapCs_1$whas ;
  assign icap_icapCs$EN = 1'd1 ;

  // register icap_icapIn
  assign icap_icapIn$D_IN =
	     CAN_FIRE_RL_icap_write_configration_data ?
	       icap_icapIn_1$wget :
	       32'hFFFFFFFF ;
  assign icap_icapIn$EN = 1'd1 ;

  // register icap_icapOut
  assign icap_icapOut$D_IN = icap_icap$O ;
  assign icap_icapOut$EN = 1'd1 ;

  // register icap_icapRd
  assign icap_icapRd$D_IN =
	     icap_icapRd_1$whas &&
	     !WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd$EN = 1'd1 ;

  // register icap_inCount
  assign icap_inCount$D_IN = icap_inCount + 32'd1 ;
  assign icap_inCount$EN = CAN_FIRE_RL_icap_write_configration_data ;

  // register icap_outCount
  assign icap_outCount$D_IN = icap_outCount + 32'd1 ;
  assign icap_outCount$EN =
	     WILL_FIRE_RL_icap_read_configuration_data && !icap_icapBusy ;

  // register wci_cEdge
  assign wci_cEdge$D_IN = wci_reqF$D_OUT[36:34] ;
  assign wci_cEdge$EN = WILL_FIRE_RL_wci_ctl_op_start ;

  // register wci_cState
  assign wci_cState$D_IN = wci_nState ;
  assign wci_cState$EN =
	     WILL_FIRE_RL_wci_ctl_op_complete && !wci_illegalEdge ;

  // register wci_ctlAckReg
  assign wci_ctlAckReg$D_IN = wci_ctlAckReg_1$whas ;
  assign wci_ctlAckReg$EN = 1'd1 ;

  // register wci_ctlOpActive
  assign wci_ctlOpActive$D_IN = !WILL_FIRE_RL_wci_ctl_op_complete ;
  assign wci_ctlOpActive$EN =
	     WILL_FIRE_RL_wci_ctl_op_complete ||
	     WILL_FIRE_RL_wci_ctl_op_start ;

  // register wci_illegalEdge
  assign wci_illegalEdge$D_IN =
	     MUX_wci_illegalEdge$write_1__SEL_1 &&
	     MUX_wci_illegalEdge$write_1__VAL_1 ;
  assign wci_illegalEdge$EN =
	     MUX_wci_illegalEdge$write_1__SEL_1 ||
	     WILL_FIRE_RL_wci_ctl_op_complete && wci_illegalEdge ;

  // register wci_nState
  always@(wci_reqF$D_OUT)
  begin
    case (wci_reqF$D_OUT[36:34])
      3'd0: wci_nState$D_IN = 3'd1;
      3'd1: wci_nState$D_IN = 3'd2;
      3'd2: wci_nState$D_IN = 3'd3;
      default: wci_nState$D_IN = 3'd0;
    endcase
  end
  assign wci_nState$EN =
	     WILL_FIRE_RL_wci_ctl_op_start &&
	     (wci_reqF$D_OUT[36:34] == 3'd0 && wci_cState == 3'd0 ||
	      wci_reqF$D_OUT[36:34] == 3'd1 &&
	      (wci_cState == 3'd1 || wci_cState == 3'd3) ||
	      wci_reqF$D_OUT[36:34] == 3'd2 && wci_cState == 3'd2 ||
	      wci_reqF$D_OUT[36:34] == 3'd3 &&
	      (wci_cState == 3'd3 || wci_cState == 3'd2 ||
	       wci_cState == 3'd1)) ;

  // register wci_reqF_countReg
  assign wci_reqF_countReg$D_IN =
	     (wci_s_req[59:57] != 3'd0) ?
	       wci_reqF_countReg + 2'd1 :
	       wci_reqF_countReg - 2'd1 ;
  assign wci_reqF_countReg$EN = CAN_FIRE_RL_wci_reqF__updateLevelCounter ;

  // register wci_respF_c_r
  assign wci_respF_c_r$D_IN =
	     WILL_FIRE_RL_wci_respF_incCtr ?
	       MUX_wci_respF_c_r$write_1__VAL_1 :
	       MUX_wci_respF_c_r$write_1__VAL_2 ;
  assign wci_respF_c_r$EN =
	     WILL_FIRE_RL_wci_respF_incCtr || WILL_FIRE_RL_wci_respF_decCtr ;

  // register wci_respF_q_0
  always@(WILL_FIRE_RL_wci_respF_both or
	  MUX_wci_respF_q_0$write_1__VAL_1 or
	  MUX_wci_respF_q_0$write_1__SEL_2 or
	  MUX_wci_respF_q_0$write_1__VAL_2 or
	  WILL_FIRE_RL_wci_respF_decCtr or wci_respF_q_1)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_respF_both:
	  wci_respF_q_0$D_IN = MUX_wci_respF_q_0$write_1__VAL_1;
      MUX_wci_respF_q_0$write_1__SEL_2:
	  wci_respF_q_0$D_IN = MUX_wci_respF_q_0$write_1__VAL_2;
      WILL_FIRE_RL_wci_respF_decCtr: wci_respF_q_0$D_IN = wci_respF_q_1;
      default: wci_respF_q_0$D_IN = 34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_respF_q_0$EN =
	     WILL_FIRE_RL_wci_respF_both ||
	     WILL_FIRE_RL_wci_respF_incCtr && wci_respF_c_r == 2'd0 ||
	     WILL_FIRE_RL_wci_respF_decCtr ;

  // register wci_respF_q_1
  always@(WILL_FIRE_RL_wci_respF_both or
	  MUX_wci_respF_q_1$write_1__VAL_1 or
	  MUX_wci_respF_q_1$write_1__SEL_2 or
	  MUX_wci_respF_q_0$write_1__VAL_2 or WILL_FIRE_RL_wci_respF_decCtr)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_respF_both:
	  wci_respF_q_1$D_IN = MUX_wci_respF_q_1$write_1__VAL_1;
      MUX_wci_respF_q_1$write_1__SEL_2:
	  wci_respF_q_1$D_IN = MUX_wci_respF_q_0$write_1__VAL_2;
      WILL_FIRE_RL_wci_respF_decCtr: wci_respF_q_1$D_IN = 34'h0AAAAAAAA;
      default: wci_respF_q_1$D_IN = 34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_respF_q_1$EN =
	     WILL_FIRE_RL_wci_respF_both ||
	     WILL_FIRE_RL_wci_respF_incCtr && wci_respF_c_r == 2'd1 ||
	     WILL_FIRE_RL_wci_respF_decCtr ;

  // register wci_sFlagReg
  assign wci_sFlagReg$D_IN = 1'b0 ;
  assign wci_sFlagReg$EN = 1'd1 ;

  // register wci_sThreadBusy_d
  assign wci_sThreadBusy_d$D_IN = 1'b0 ;
  assign wci_sThreadBusy_d$EN = 1'd1 ;

  // submodule coutF_memory
  assign coutF_memory$ADDRA =
	     { coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d663,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d664,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d638,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d665,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d639,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d640,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d641,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d642,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d643,
	       coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d643 ^
	       coutF_rWrPtr_rsCounter[0] } ;
  assign coutF_memory$ADDRB =
	     coutF_pwDequeue$whas ? x__h21196[9:0] : x2__h21165 ;
  assign coutF_memory$DIA = x3__h19954 ;
  assign coutF_memory$DIB = 32'hAAAAAAAA /* unspecified value */  ;
  assign coutF_memory$WEA = CAN_FIRE_RL_config_read ;
  assign coutF_memory$WEB = 1'd0 ;
  assign coutF_memory$ENA = 1'd1 ;
  assign coutF_memory$ENB = 1'd1 ;

  // submodule coutF_rRdPtr_wdCounterCrossing
  assign coutF_rRdPtr_wdCounterCrossing$WVAL = coutF_rRdPtr_rsCounter ;

  // submodule coutF_rWrPtr_wdCounterCrossing
  assign coutF_rWrPtr_wdCounterCrossing$WVAL = coutF_rWrPtr_rsCounter ;

  // submodule cre
  assign cre$sD_IN = icapCtrl[1] ;
  assign cre$sEN = CAN_FIRE_RL_update_control ;

  // submodule cwe
  assign cwe$sD_IN = icapCtrl[0] ;
  assign cwe$sEN = CAN_FIRE_RL_update_control ;

  // submodule icap_cinF
  assign icap_cinF$D_IN = cinS ;
  assign icap_cinF$ENQ = CAN_FIRE_RL_config_write ;
  assign icap_cinF$DEQ = CAN_FIRE_RL_icap_write_configration_data ;
  assign icap_cinF$CLR = 1'b0 ;

  // submodule icap_coutF
  assign icap_coutF$D_IN =
	     { icap_icapOut[24],
	       icap_icapOut[25],
	       icap_icapOut[26],
	       icap_icapOut[27],
	       icap_icapOut[28],
	       icap_icapOut[29],
	       icap_icapOut[30],
	       icap_icapOut[31],
	       icap_icapOut[16],
	       icap_icapOut[17],
	       icap_icapOut[18],
	       icap_icapOut[19],
	       icap_icapOut[20],
	       icap_icapOut[21],
	       icap_icapOut[22],
	       icap_icapOut[23],
	       icap_icapOut[8],
	       icap_icapOut[9],
	       icap_icapOut[10],
	       icap_icapOut[11],
	       icap_icapOut[12],
	       icap_icapOut[13],
	       icap_icapOut[14],
	       icap_icapOut[15],
	       icap_icapOut[0],
	       icap_icapOut[1],
	       icap_icapOut[2],
	       icap_icapOut[3],
	       icap_icapOut[4],
	       icap_icapOut[5],
	       icap_icapOut[6],
	       icap_icapOut[7] } ;
  assign icap_coutF$ENQ =
	     WILL_FIRE_RL_icap_read_configuration_data && !icap_icapBusy ;
  assign icap_coutF$DEQ = CAN_FIRE_RL_config_read ;
  assign icap_coutF$CLR = 1'b0 ;

  // submodule icap_icap
  assign icap_icap$CSB = !icap_icapCs ;
  assign icap_icap$I = icap_icapIn ;
  assign icap_icap$RDWRB = icap_icapRd ;

  // submodule inCnt
  assign inCnt$sD_IN = icap_inCount ;
  assign inCnt$sEN = inCnt$sRDY ;

  // submodule outCnt
  assign outCnt$sD_IN = icap_outCount ;
  assign outCnt$sEN = outCnt$sRDY ;

  // submodule wci_reqF
  assign wci_reqF$D_IN = wci_s_req ;
  assign wci_reqF$ENQ = CAN_FIRE_RL_wci_reqF_enq ;
  assign wci_reqF$DEQ = wci_reqF_r_deq$whas ;
  assign wci_reqF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_OR_coutF_ETC___d738 =
	     (coutF_rRdPtr_rsCounter[0] || coutF_rRdPtr_rsCounter[1] ||
	      coutF_rRdPtr_rsCounter[2] ||
	      coutF_rRdPtr_rsCounter[3] ||
	      coutF_rRdPtr_rsCounter[4] ||
	      coutF_rRdPtr_rsCounter[5] ||
	      coutF_rRdPtr_rsCounter[6] ||
	      coutF_rRdPtr_rsCounter[7] ||
	      coutF_rRdPtr_rsCounter[8] ||
	      coutF_rRdPtr_rsCounter[9]) ?
	       (coutF_rRdPtr_rsCounter[0] ?
		  32'd1 :
		  (coutF_rRdPtr_rsCounter[1] ?
		     32'd2 :
		     (coutF_rRdPtr_rsCounter[2] ?
			32'd3 :
			(coutF_rRdPtr_rsCounter[3] ?
			   32'd4 :
			   (coutF_rRdPtr_rsCounter[4] ?
			      32'd5 :
			      (coutF_rRdPtr_rsCounter[5] ?
				 32'd6 :
				 (coutF_rRdPtr_rsCounter[6] ?
				    32'd7 :
				    (coutF_rRdPtr_rsCounter[7] ?
				       32'd8 :
				       (coutF_rRdPtr_rsCounter[8] ?
					  32'd9 :
					  (coutF_rRdPtr_rsCounter[9] ?
					     32'd10 :
					     (coutF_rRdPtr_rsCounter[10] ?
						32'd11 :
						32'd12))))))))))) :
	       32'd10 ;
  assign IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_cout_ETC___d737 =
	     coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_coutF_r_ETC___d716 ?
	       IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_OR_coutF_ETC___d738 :
	       32'd0 ;
  assign IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_OR_coutF_ETC___d670 =
	     (coutF_rWrPtr_rsCounter[0] || coutF_rWrPtr_rsCounter[1] ||
	      coutF_rWrPtr_rsCounter[2] ||
	      coutF_rWrPtr_rsCounter[3] ||
	      coutF_rWrPtr_rsCounter[4] ||
	      coutF_rWrPtr_rsCounter[5] ||
	      coutF_rWrPtr_rsCounter[6] ||
	      coutF_rWrPtr_rsCounter[7] ||
	      coutF_rWrPtr_rsCounter[8] ||
	      coutF_rWrPtr_rsCounter[9]) ?
	       (coutF_rWrPtr_rsCounter[0] ?
		  32'd1 :
		  (coutF_rWrPtr_rsCounter[1] ?
		     32'd2 :
		     (coutF_rWrPtr_rsCounter[2] ?
			32'd3 :
			(coutF_rWrPtr_rsCounter[3] ?
			   32'd4 :
			   (coutF_rWrPtr_rsCounter[4] ?
			      32'd5 :
			      (coutF_rWrPtr_rsCounter[5] ?
				 32'd6 :
				 (coutF_rWrPtr_rsCounter[6] ?
				    32'd7 :
				    (coutF_rWrPtr_rsCounter[7] ?
				       32'd8 :
				       (coutF_rWrPtr_rsCounter[8] ?
					  32'd9 :
					  (coutF_rWrPtr_rsCounter[9] ?
					     32'd10 :
					     (coutF_rWrPtr_rsCounter[10] ?
						32'd11 :
						32'd12))))))))))) :
	       32'd10 ;
  assign IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_cout_ETC___d735 =
	     coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_coutF_r_ETC___d715 ?
	       IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_OR_coutF_ETC___d670 :
	       32'd0 ;
  assign NOT_coutF_rRdPtr_rsCounter_75_EQ_coutF_rWrPtr__ETC___d583 =
	     coutF_rRdPtr_rsCounter != coutF_rWrPtr_rdCounter ;
  assign NOT_wci_respF_c_r_2_EQ_2_1_2_AND_wci_reqF_i_no_ETC___d574 =
	     wci_respF_c_r != 2'd2 && wci_reqF$EMPTY_N &&
	     (wci_reqF$D_OUT[51:32] != 20'h00008 ||
	      cinF_head_wrapped == cinF_tail_wrapped && !cinF_sInReset$VAL &&
	      cd$PREEDGE) ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_CONCAT_cou_ETC___d661 =
	     x_dReadBin__h19658 + 11'd512 ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d653 =
	     coutF_rRdPtr_rdCounter[10] ^ coutF_rRdPtr_rdCounter[9] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d654 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d653 ^
	     coutF_rRdPtr_rdCounter[8] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d655 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d666 ^
	     coutF_rRdPtr_rdCounter[6] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d656 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d655 ^
	     coutF_rRdPtr_rdCounter[5] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d657 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d656 ^
	     coutF_rRdPtr_rdCounter[4] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d658 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d657 ^
	     coutF_rRdPtr_rdCounter[3] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d659 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d658 ^
	     coutF_rRdPtr_rdCounter[2] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d660 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d659 ^
	     coutF_rRdPtr_rdCounter[1] ;
  assign coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d666 =
	     coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d654 ^
	     coutF_rRdPtr_rdCounter[7] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_coutF_r_ETC___d716 =
	     z__h18834 ^ coutF_rRdPtr_rsCounter[10] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d644 =
	     coutF_rRdPtr_rsCounter[10] ^ coutF_rRdPtr_rsCounter[9] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d645 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d644 ^
	     coutF_rRdPtr_rsCounter[8] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d646 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d645 ^
	     coutF_rRdPtr_rsCounter[7] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d647 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d646 ^
	     coutF_rRdPtr_rsCounter[6] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d648 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d647 ^
	     coutF_rRdPtr_rsCounter[5] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d649 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d648 ^
	     coutF_rRdPtr_rsCounter[4] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d650 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d649 ^
	     coutF_rRdPtr_rsCounter[3] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d651 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d650 ^
	     coutF_rRdPtr_rsCounter[2] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d652 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d651 ^
	     coutF_rRdPtr_rsCounter[1] ;
  assign coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d681 =
	     coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d652 ^
	     coutF_rRdPtr_rsCounter[0] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_coutF_r_ETC___d715 =
	     z__h16558 ^ coutF_rWrPtr_rsCounter[10] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d638 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d664 ^
	     coutF_rWrPtr_rsCounter[7] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d639 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d665 ^
	     coutF_rWrPtr_rsCounter[5] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d640 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d639 ^
	     coutF_rWrPtr_rsCounter[4] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d641 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d640 ^
	     coutF_rWrPtr_rsCounter[3] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d642 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d641 ^
	     coutF_rWrPtr_rsCounter[2] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d643 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d642 ^
	     coutF_rWrPtr_rsCounter[1] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d663 =
	     coutF_rWrPtr_rsCounter[10] ^ coutF_rWrPtr_rsCounter[9] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d664 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d663 ^
	     coutF_rWrPtr_rsCounter[8] ;
  assign coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d665 =
	     coutF_rWrPtr_rsCounter_06_BIT_10_32_XOR_coutF__ETC___d638 ^
	     coutF_rWrPtr_rsCounter[6] ;
  assign icapStatus__h25169 = { 29'd0, x__h25668 } ;
  assign rdat__h25575 = hasDebugLogic ? dwWritten : 32'd0 ;
  assign rdat__h25581 = hasDebugLogic ? dwRead : 32'd0 ;
  assign rdat__h25587 = hasDebugLogic ? inCnt$dD_OUT : 32'd0 ;
  assign rdat__h25593 = hasDebugLogic ? outCnt$dD_OUT : 32'd0 ;
  assign x2__h21165 =
	     { coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d644,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d645,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d646,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d647,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d648,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d649,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d650,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d651,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d652,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d681 } ;
  assign x3__h19954 = CAN_FIRE_RL_config_read ? icap_coutF$D_OUT : 32'd0 ;
  assign x__h15573 =
	     11'd1 <<
	     IF_coutF_rWrPtr_rsCounter_06_BIT_0_13_XOR_cout_ETC___d735 ;
  assign x__h17849 =
	     11'd1 <<
	     IF_coutF_rRdPtr_rsCounter_75_BIT_0_82_XOR_cout_ETC___d737 ;
  assign x__h21196 = x_sReadBin__h19655 + 11'd1 ;
  assign x__h25668 =
	     { NOT_coutF_rRdPtr_rsCounter_75_EQ_coutF_rWrPtr__ETC___d583,
	       icapCtrl[1:0] } ;
  assign x_dReadBin__h19658 =
	     { coutF_rRdPtr_rdCounter[10],
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d653,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d654,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d666,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d655,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d656,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d657,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d658,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d659,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d660,
	       coutF_rRdPtr_rdCounter_06_BIT_10_07_XOR_coutF__ETC___d660 ^
	       coutF_rRdPtr_rdCounter[0] } ;
  assign x_sReadBin__h19655 =
	     { coutF_rRdPtr_rsCounter[10],
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d644,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d645,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d646,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d647,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d648,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d649,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d650,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d651,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d652,
	       coutF_rRdPtr_rsCounter_75_BIT_10_01_XOR_coutF__ETC___d681 } ;
  assign y__h16458 = ~x__h15573 ;
  assign y__h18734 = ~x__h17849 ;
  assign z__h16502 = coutF_rWrPtr_rsCounter[0] ^ coutF_rWrPtr_rsCounter[1] ;
  assign z__h16509 = z__h16502 ^ coutF_rWrPtr_rsCounter[2] ;
  assign z__h16516 = z__h16509 ^ coutF_rWrPtr_rsCounter[3] ;
  assign z__h16523 = z__h16516 ^ coutF_rWrPtr_rsCounter[4] ;
  assign z__h16530 = z__h16523 ^ coutF_rWrPtr_rsCounter[5] ;
  assign z__h16537 = z__h16530 ^ coutF_rWrPtr_rsCounter[6] ;
  assign z__h16544 = z__h16537 ^ coutF_rWrPtr_rsCounter[7] ;
  assign z__h16551 = z__h16544 ^ coutF_rWrPtr_rsCounter[8] ;
  assign z__h16558 = z__h16551 ^ coutF_rWrPtr_rsCounter[9] ;
  assign z__h18778 = coutF_rRdPtr_rsCounter[0] ^ coutF_rRdPtr_rsCounter[1] ;
  assign z__h18785 = z__h18778 ^ coutF_rRdPtr_rsCounter[2] ;
  assign z__h18792 = z__h18785 ^ coutF_rRdPtr_rsCounter[3] ;
  assign z__h18799 = z__h18792 ^ coutF_rRdPtr_rsCounter[4] ;
  assign z__h18806 = z__h18799 ^ coutF_rRdPtr_rsCounter[5] ;
  assign z__h18813 = z__h18806 ^ coutF_rRdPtr_rsCounter[6] ;
  assign z__h18820 = z__h18813 ^ coutF_rRdPtr_rsCounter[7] ;
  assign z__h18827 = z__h18820 ^ coutF_rRdPtr_rsCounter[8] ;
  assign z__h18834 = z__h18827 ^ coutF_rRdPtr_rsCounter[9] ;
  always@(wci_reqF$D_OUT or
	  icapStatus__h25169 or
	  icapCtrl or
	  coutF_memory$DOB or
	  rdat__h25575 or rdat__h25581 or rdat__h25587 or rdat__h25593)
  begin
    case (wci_reqF$D_OUT[51:32])
      20'h0: x_data__h25731 = icapStatus__h25169;
      20'h00004: x_data__h25731 = icapCtrl;
      20'h0000C: x_data__h25731 = coutF_memory$DOB;
      20'h00040: x_data__h25731 = rdat__h25575;
      20'h00044: x_data__h25731 = rdat__h25581;
      20'h00048: x_data__h25731 = rdat__h25587;
      20'h0004C: x_data__h25731 = rdat__h25593;
      default: x_data__h25731 = 32'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge wciS0_Clk)
  begin
    if (!wciS0_MReset_n)
      begin
        cinF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dwRead <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dwWritten <= `BSV_ASSIGNMENT_DELAY 32'd0;
	icapCtrl <= `BSV_ASSIGNMENT_DELAY 32'd0;
	wci_cEdge <= `BSV_ASSIGNMENT_DELAY 3'h2;
	wci_cState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_ctlAckReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_ctlOpActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_illegalEdge <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_nState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_reqF_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_respF_c_r <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_respF_q_0 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_respF_q_1 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_sFlagReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (cinF_tail_wrapped$EN)
	  cinF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY cinF_tail_wrapped$D_IN;
	if (dwRead$EN) dwRead <= `BSV_ASSIGNMENT_DELAY dwRead$D_IN;
	if (dwWritten$EN) dwWritten <= `BSV_ASSIGNMENT_DELAY dwWritten$D_IN;
	if (icapCtrl$EN) icapCtrl <= `BSV_ASSIGNMENT_DELAY icapCtrl$D_IN;
	if (wci_cEdge$EN) wci_cEdge <= `BSV_ASSIGNMENT_DELAY wci_cEdge$D_IN;
	if (wci_cState$EN)
	  wci_cState <= `BSV_ASSIGNMENT_DELAY wci_cState$D_IN;
	if (wci_ctlAckReg$EN)
	  wci_ctlAckReg <= `BSV_ASSIGNMENT_DELAY wci_ctlAckReg$D_IN;
	if (wci_ctlOpActive$EN)
	  wci_ctlOpActive <= `BSV_ASSIGNMENT_DELAY wci_ctlOpActive$D_IN;
	if (wci_illegalEdge$EN)
	  wci_illegalEdge <= `BSV_ASSIGNMENT_DELAY wci_illegalEdge$D_IN;
	if (wci_nState$EN)
	  wci_nState <= `BSV_ASSIGNMENT_DELAY wci_nState$D_IN;
	if (wci_reqF_countReg$EN)
	  wci_reqF_countReg <= `BSV_ASSIGNMENT_DELAY wci_reqF_countReg$D_IN;
	if (wci_respF_c_r$EN)
	  wci_respF_c_r <= `BSV_ASSIGNMENT_DELAY wci_respF_c_r$D_IN;
	if (wci_respF_q_0$EN)
	  wci_respF_q_0 <= `BSV_ASSIGNMENT_DELAY wci_respF_q_0$D_IN;
	if (wci_respF_q_1$EN)
	  wci_respF_q_1 <= `BSV_ASSIGNMENT_DELAY wci_respF_q_1$D_IN;
	if (wci_sFlagReg$EN)
	  wci_sFlagReg <= `BSV_ASSIGNMENT_DELAY wci_sFlagReg$D_IN;
	if (wci_sThreadBusy_d$EN)
	  wci_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY wci_sThreadBusy_d$D_IN;
      end
    if (cinS$EN) cinS <= `BSV_ASSIGNMENT_DELAY cinS$D_IN;
  end

  always@(posedge cd$CLK_OUT)
  begin
    if (!slowReset$OUT_RST_N)
      begin
        cinF_head_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_icapBusy <= `BSV_ASSIGNMENT_DELAY 1'd1;
	icap_icapCs <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_icapIn <= `BSV_ASSIGNMENT_DELAY 32'hFFFFFFFF;
	icap_icapOut <= `BSV_ASSIGNMENT_DELAY 32'hFFFFFFFF;
	icap_icapRd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_inCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	icap_outCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (cinF_head_wrapped$EN)
	  cinF_head_wrapped <= `BSV_ASSIGNMENT_DELAY cinF_head_wrapped$D_IN;
	if (icap_icapBusy$EN)
	  icap_icapBusy <= `BSV_ASSIGNMENT_DELAY icap_icapBusy$D_IN;
	if (icap_icapCs$EN)
	  icap_icapCs <= `BSV_ASSIGNMENT_DELAY icap_icapCs$D_IN;
	if (icap_icapIn$EN)
	  icap_icapIn <= `BSV_ASSIGNMENT_DELAY icap_icapIn$D_IN;
	if (icap_icapOut$EN)
	  icap_icapOut <= `BSV_ASSIGNMENT_DELAY icap_icapOut$D_IN;
	if (icap_icapRd$EN)
	  icap_icapRd <= `BSV_ASSIGNMENT_DELAY icap_icapRd$D_IN;
	if (icap_inCount$EN)
	  icap_inCount <= `BSV_ASSIGNMENT_DELAY icap_inCount$D_IN;
	if (icap_outCount$EN)
	  icap_outCount <= `BSV_ASSIGNMENT_DELAY icap_outCount$D_IN;
      end
  end

  always@(posedge wciS0_Clk or negedge wciS0_MReset_n)
  if (!wciS0_MReset_n)
    begin
      coutF_rRdPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY 11'd0;
    end
  else
    begin
      if (coutF_rRdPtr_rsCounter$EN)
	coutF_rRdPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rsCounter$D_IN;
      if (coutF_rWrPtr_rdCounter$EN)
	coutF_rWrPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rdCounter$D_IN;
      if (coutF_rWrPtr_rdCounterPre$EN)
	coutF_rWrPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rdCounterPre$D_IN;
    end

  always@(posedge cd$CLK_OUT or negedge slowReset$OUT_RST_N)
  if (!slowReset$OUT_RST_N)
    begin
      coutF_rRdPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rRdPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
    end
  else
    begin
      if (coutF_rRdPtr_rdCounter$EN)
	coutF_rRdPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rdCounter$D_IN;
      if (coutF_rRdPtr_rdCounterPre$EN)
	coutF_rRdPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rdCounterPre$D_IN;
      if (coutF_rWrPtr_rsCounter$EN)
	coutF_rWrPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rsCounter$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cinF_head_wrapped = 1'h0;
    cinF_tail_wrapped = 1'h0;
    cinS = 32'hAAAAAAAA;
    coutF_rRdPtr_rdCounter = 11'h2AA;
    coutF_rRdPtr_rdCounterPre = 11'h2AA;
    coutF_rRdPtr_rsCounter = 11'h2AA;
    coutF_rWrPtr_rdCounter = 11'h2AA;
    coutF_rWrPtr_rdCounterPre = 11'h2AA;
    coutF_rWrPtr_rsCounter = 11'h2AA;
    dwRead = 32'hAAAAAAAA;
    dwWritten = 32'hAAAAAAAA;
    icapCtrl = 32'hAAAAAAAA;
    icap_icapBusy = 1'h0;
    icap_icapCs = 1'h0;
    icap_icapIn = 32'hAAAAAAAA;
    icap_icapOut = 32'hAAAAAAAA;
    icap_icapRd = 1'h0;
    icap_inCount = 32'hAAAAAAAA;
    icap_outCount = 32'hAAAAAAAA;
    wci_cEdge = 3'h2;
    wci_cState = 3'h2;
    wci_ctlAckReg = 1'h0;
    wci_ctlOpActive = 1'h0;
    wci_illegalEdge = 1'h0;
    wci_nState = 3'h2;
    wci_reqF_countReg = 2'h2;
    wci_respF_c_r = 2'h2;
    wci_respF_q_0 = 34'h2AAAAAAAA;
    wci_respF_q_1 = 34'h2AAAAAAAA;
    wci_sFlagReg = 1'h0;
    wci_sThreadBusy_d = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge wciS0_Clk)
  begin
    #0;
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_start)
	begin
	  v__h3551 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_start)
	$display("[%0d]: %m: WCI ControlOp: Starting-transition edge:%x from:%x",
		 v__h3551,
		 wci_reqF$D_OUT[36:34],
		 wci_cState);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_IsO)
	begin
	  v__h25803 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_IsO)
	$display("[%0d]: %m: Starting ICAPyWorker", v__h25803);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_IsO && WILL_FIRE_RL_wci_cfwr)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 104, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_IsO and RL_wci_cfwr fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 109, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_EiI and RL_wci_ctrl_IsO fired in the\n  same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_cfwr)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 109, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_EiI and RL_wci_cfwr fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_OrE && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 110, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_OrE and RL_wci_ctrl_IsO fired in the\n  same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_OrE && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 110, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_OrE and RL_wci_ctrl_EiI fired in the\n  same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_OrE && WILL_FIRE_RL_wci_cfwr)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 110, column 6: (R0001)\n  Mutually exclusive rules RL_wci_ctrl_OrE and RL_wci_cfwr fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_complete && wci_illegalEdge)
	begin
	  v__h3891 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_complete && wci_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: ILLEGAL-EDGE Completed-transition edge:%x from:%x",
		 v__h3891,
		 wci_cEdge,
		 wci_cState);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_complete && !wci_illegalEdge)
	begin
	  v__h3736 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctl_op_complete && !wci_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: Completed-transition edge:%x from:%x to:%x",
		 v__h3736,
		 wci_cEdge,
		 wci_cState,
		 wci_nState);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 89, column 6: (R0001)\n  Mutually exclusive rules RL_wci_cfrd and RL_wci_ctrl_OrE fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 89, column 6: (R0001)\n  Mutually exclusive rules RL_wci_cfrd and RL_wci_ctrl_IsO fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 89, column 6: (R0001)\n  Mutually exclusive rules RL_wci_cfrd and RL_wci_ctrl_EiI fired in the same\n  clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_cfwr)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 89, column 6: (R0001)\n  Mutually exclusive rules RL_wci_cfrd and RL_wci_cfwr fired in the same clock\n  cycle.\n");
  end
  // synopsys translate_on

  // synopsys translate_off
  always@(negedge cd$CLK_OUT)
  begin
    #0;
    if (slowReset$OUT_RST_N)
      if (WILL_FIRE_RL_icap_read_configuration_data &&
	  WILL_FIRE_RL_icap_write_configration_data)
	$display("Error: \"bsv/dev/ICAP.bsv\", line 108, column 8: (R0001)\n  Mutually exclusive rules RL_icap_read_configuration_data and\n  RL_icap_write_configration_data fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkICAPWorker

