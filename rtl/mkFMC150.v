//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Sun Apr 15 14:37:22 EDT 2012
//
//
// Ports:
// Name                         I/O  size props
// wciS0_SResp                    O     2 reg
// wciS0_SData                    O    32 reg
// wciS0_SThreadBusy              O     1
// wciS0_SFlag                    O     2
// pads_sdo                       O     1 reg
// pads_csb                       O     1 reg
// pads_sclkgate                  O     1 reg
// CLK_pads_sclk                  O     1 clock
// CLK_GATE_pads_sclk             O     1 const
// CLK_pads_sclkn                 O     1 clock
// CLK_GATE_pads_sclkn            O     1 const
// RST_N_pads_srst                O     1 reset
// CLK_flp_clk                    I     1 clock
// RST_N_flp_rst                  I     1 unused
// wciS0_Clk                      I     1 clock
// wciS0_MReset_n                 I     1 reset
// wciS0_MCmd                     I     3
// wciS0_MAddrSpace               I     1
// wciS0_MByteEn                  I     4
// wciS0_MAddr                    I    32
// wciS0_MData                    I    32
// wciS0_MFlag                    I     2 unused
// pads_sdi_arg                   I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFMC150(CLK_flp_clk,
		RST_N_flp_rst,
		wciS0_Clk,
		wciS0_MReset_n,

		wciS0_MCmd,

		wciS0_MAddrSpace,

		wciS0_MByteEn,

		wciS0_MAddr,

		wciS0_MData,

		wciS0_SResp,

		wciS0_SData,

		wciS0_SThreadBusy,

		wciS0_SFlag,

		wciS0_MFlag,

		pads_sdo,

		pads_csb,

		pads_sclkgate,

		pads_sdi_arg,

		CLK_pads_sclk,
		CLK_GATE_pads_sclk,

		CLK_pads_sclkn,
		CLK_GATE_pads_sclkn,

		RST_N_pads_srst);
  parameter [0 : 0] hasDebugLogic = 1'b0;
  input  CLK_flp_clk;
  input  RST_N_flp_rst;
  input  wciS0_Clk;
  input  wciS0_MReset_n;

  // action method wciS0_mCmd
  input  [2 : 0] wciS0_MCmd;

  // action method wciS0_mAddrSpace
  input  wciS0_MAddrSpace;

  // action method wciS0_mByteEn
  input  [3 : 0] wciS0_MByteEn;

  // action method wciS0_mAddr
  input  [31 : 0] wciS0_MAddr;

  // action method wciS0_mData
  input  [31 : 0] wciS0_MData;

  // value method wciS0_sResp
  output [1 : 0] wciS0_SResp;

  // value method wciS0_sData
  output [31 : 0] wciS0_SData;

  // value method wciS0_sThreadBusy
  output wciS0_SThreadBusy;

  // value method wciS0_sFlag
  output [1 : 0] wciS0_SFlag;

  // action method wciS0_mFlag
  input  [1 : 0] wciS0_MFlag;

  // value method pads_sdo
  output pads_sdo;

  // value method pads_csb
  output pads_csb;

  // value method pads_sclkgate
  output pads_sclkgate;

  // action method pads_sdi
  input  pads_sdi_arg;

  // oscillator and gates for output clock CLK_pads_sclk
  output CLK_pads_sclk;
  output CLK_GATE_pads_sclk;

  // oscillator and gates for output clock CLK_pads_sclkn
  output CLK_pads_sclkn;
  output CLK_GATE_pads_sclkn;

  // output resets
  output RST_N_pads_srst;

  // signals for module outputs
  wire [31 : 0] wciS0_SData;
  wire [1 : 0] wciS0_SFlag, wciS0_SResp;
  wire CLK_GATE_pads_sclk,
       CLK_GATE_pads_sclkn,
       CLK_pads_sclk,
       CLK_pads_sclkn,
       RST_N_pads_srst,
       pads_csb,
       pads_sclkgate,
       pads_sdo,
       wciS0_SThreadBusy;

  // inlined wires
  wire [71 : 0] wci_wslv_wciReq$wget;
  wire [33 : 0] wci_wslv_respF_x_wire$wget;
  wire [31 : 0] wci_wci_Es_mAddr_w$wget, wci_wci_Es_mData_w$wget;
  wire [17 : 0] fcCdc_grayCounter_wdCounterCrossing$wget;
  wire [3 : 0] wci_wci_Es_mByteEn_w$wget;
  wire [2 : 0] wci_wci_Es_mCmd_w$wget, wci_wslv_wEdge$wget;
  wire fcCdc_grayCounter_pwDecrement$whas,
       fcCdc_grayCounter_pwIncrement$whas,
       fcCdc_pulseAction_1$wget,
       fcCdc_pulseAction_1$whas,
       oneKHz_decAction$whas,
       oneKHz_incAction$whas,
       spiCDC_cGate_1$wget,
       spiCDC_cGate_1$whas,
       spiCDC_csbR_1$wget,
       spiCDC_csbR_1$whas,
       spiCDC_doResp_1$wget,
       spiCDC_doResp_1$whas,
       spiCDC_reqF_dClear_pw$whas,
       spiCDC_reqF_deq_happened$whas,
       spiCDC_reqF_deq_pw$whas,
       spiCDC_reqF_enq_pw$whas,
       spiCDC_reqF_sClear_pw$whas,
       spiCDC_respF_dClear_pw$whas,
       spiCDC_respF_deq_happened$whas,
       spiCDC_respF_deq_pw$whas,
       spiCDC_respF_enq_pw$whas,
       spiCDC_respF_sClear_pw$whas,
       spiCDC_sdiWs$wget,
       wci_wci_Es_mAddrSpace_w$wget,
       wci_wci_Es_mAddrSpace_w$whas,
       wci_wci_Es_mAddr_w$whas,
       wci_wci_Es_mByteEn_w$whas,
       wci_wci_Es_mCmd_w$whas,
       wci_wci_Es_mData_w$whas,
       wci_wslv_ctlAckReg_1$wget,
       wci_wslv_ctlAckReg_1$whas,
       wci_wslv_reqF_r_clr$whas,
       wci_wslv_reqF_r_deq$whas,
       wci_wslv_reqF_r_enq$whas,
       wci_wslv_respF_dequeueing$whas,
       wci_wslv_respF_enqueueing$whas,
       wci_wslv_respF_x_wire$whas,
       wci_wslv_sFlagReg_1$wget,
       wci_wslv_sFlagReg_1$whas,
       wci_wslv_sThreadBusy_pw$whas,
       wci_wslv_wEdge$whas,
       wci_wslv_wciReq$whas,
       wci_wslv_wci_cfrd_pw$whas,
       wci_wslv_wci_cfwr_pw$whas,
       wci_wslv_wci_ctrl_pw$whas;

  // register fcCdc_countNow
  reg [17 : 0] fcCdc_countNow;
  wire [17 : 0] fcCdc_countNow$D_IN;
  wire fcCdc_countNow$EN;

  // register fcCdc_countPast
  reg [17 : 0] fcCdc_countPast;
  wire [17 : 0] fcCdc_countPast$D_IN;
  wire fcCdc_countPast$EN;

  // register fcCdc_frequency
  reg [17 : 0] fcCdc_frequency;
  wire [17 : 0] fcCdc_frequency$D_IN;
  wire fcCdc_frequency$EN;

  // register fcCdc_grayCounter_rdCounter
  reg [17 : 0] fcCdc_grayCounter_rdCounter;
  wire [17 : 0] fcCdc_grayCounter_rdCounter$D_IN;
  wire fcCdc_grayCounter_rdCounter$EN;

  // register fcCdc_grayCounter_rdCounterPre
  reg [17 : 0] fcCdc_grayCounter_rdCounterPre;
  wire [17 : 0] fcCdc_grayCounter_rdCounterPre$D_IN;
  wire fcCdc_grayCounter_rdCounterPre$EN;

  // register fcCdc_grayCounter_rsCounter
  reg [17 : 0] fcCdc_grayCounter_rsCounter;
  wire [17 : 0] fcCdc_grayCounter_rsCounter$D_IN;
  wire fcCdc_grayCounter_rsCounter$EN;

  // register fcCdc_pulseAction
  reg fcCdc_pulseAction;
  wire fcCdc_pulseAction$D_IN, fcCdc_pulseAction$EN;

  // register fcCdc_sampleCount
  reg [15 : 0] fcCdc_sampleCount;
  wire [15 : 0] fcCdc_sampleCount$D_IN;
  wire fcCdc_sampleCount$EN;

  // register oneKHz_value
  reg [17 : 0] oneKHz_value;
  wire [17 : 0] oneKHz_value$D_IN;
  wire oneKHz_value$EN;

  // register spiCDC_cGate
  reg spiCDC_cGate;
  wire spiCDC_cGate$D_IN, spiCDC_cGate$EN;

  // register spiCDC_capV
  reg [27 : 0] spiCDC_capV;
  wire [27 : 0] spiCDC_capV$D_IN;
  wire spiCDC_capV$EN;

  // register spiCDC_csbR
  reg spiCDC_csbR;
  wire spiCDC_csbR$D_IN, spiCDC_csbR$EN;

  // register spiCDC_dPos
  reg [4 : 0] spiCDC_dPos;
  wire [4 : 0] spiCDC_dPos$D_IN;
  wire spiCDC_dPos$EN;

  // register spiCDC_doResp
  reg spiCDC_doResp;
  wire spiCDC_doResp$D_IN, spiCDC_doResp$EN;

  // register spiCDC_rPos
  reg [5 : 0] spiCDC_rPos;
  wire [5 : 0] spiCDC_rPos$D_IN;
  wire spiCDC_rPos$EN;

  // register spiCDC_rcv_d
  reg spiCDC_rcv_d;
  wire spiCDC_rcv_d$D_IN, spiCDC_rcv_d$EN;

  // register spiCDC_reqF_head_wrapped
  reg spiCDC_reqF_head_wrapped;
  wire spiCDC_reqF_head_wrapped$D_IN, spiCDC_reqF_head_wrapped$EN;

  // register spiCDC_reqF_tail_wrapped
  reg spiCDC_reqF_tail_wrapped;
  wire spiCDC_reqF_tail_wrapped$D_IN, spiCDC_reqF_tail_wrapped$EN;

  // register spiCDC_reqS
  reg [32 : 0] spiCDC_reqS;
  wire [32 : 0] spiCDC_reqS$D_IN;
  wire spiCDC_reqS$EN;

  // register spiCDC_respF_head_wrapped
  reg spiCDC_respF_head_wrapped;
  wire spiCDC_respF_head_wrapped$D_IN, spiCDC_respF_head_wrapped$EN;

  // register spiCDC_respF_tail_wrapped
  reg spiCDC_respF_tail_wrapped;
  wire spiCDC_respF_tail_wrapped$D_IN, spiCDC_respF_tail_wrapped$EN;

  // register spiCDC_respS
  reg [27 : 0] spiCDC_respS;
  wire [27 : 0] spiCDC_respS$D_IN;
  wire spiCDC_respS$EN;

  // register spiCDC_sdiP
  reg spiCDC_sdiP;
  wire spiCDC_sdiP$D_IN, spiCDC_sdiP$EN;

  // register spiCDC_sdoR
  reg spiCDC_sdoR;
  wire spiCDC_sdoR$D_IN, spiCDC_sdoR$EN;

  // register spiCDC_xmt_d
  reg spiCDC_xmt_d;
  wire spiCDC_xmt_d$D_IN, spiCDC_xmt_d$EN;

  // register splitReadInFlight
  reg splitReadInFlight;
  wire splitReadInFlight$D_IN, splitReadInFlight$EN;

  // register wci_wslv_cEdge
  reg [2 : 0] wci_wslv_cEdge;
  wire [2 : 0] wci_wslv_cEdge$D_IN;
  wire wci_wslv_cEdge$EN;

  // register wci_wslv_cState
  reg [2 : 0] wci_wslv_cState;
  wire [2 : 0] wci_wslv_cState$D_IN;
  wire wci_wslv_cState$EN;

  // register wci_wslv_ctlAckReg
  reg wci_wslv_ctlAckReg;
  wire wci_wslv_ctlAckReg$D_IN, wci_wslv_ctlAckReg$EN;

  // register wci_wslv_ctlOpActive
  reg wci_wslv_ctlOpActive;
  wire wci_wslv_ctlOpActive$D_IN, wci_wslv_ctlOpActive$EN;

  // register wci_wslv_illegalEdge
  reg wci_wslv_illegalEdge;
  wire wci_wslv_illegalEdge$D_IN, wci_wslv_illegalEdge$EN;

  // register wci_wslv_isReset_isInReset
  reg wci_wslv_isReset_isInReset;
  wire wci_wslv_isReset_isInReset$D_IN, wci_wslv_isReset_isInReset$EN;

  // register wci_wslv_nState
  reg [2 : 0] wci_wslv_nState;
  reg [2 : 0] wci_wslv_nState$D_IN;
  wire wci_wslv_nState$EN;

  // register wci_wslv_reqF_countReg
  reg [1 : 0] wci_wslv_reqF_countReg;
  wire [1 : 0] wci_wslv_reqF_countReg$D_IN;
  wire wci_wslv_reqF_countReg$EN;

  // register wci_wslv_respF_c_r
  reg [1 : 0] wci_wslv_respF_c_r;
  wire [1 : 0] wci_wslv_respF_c_r$D_IN;
  wire wci_wslv_respF_c_r$EN;

  // register wci_wslv_respF_q_0
  reg [33 : 0] wci_wslv_respF_q_0;
  reg [33 : 0] wci_wslv_respF_q_0$D_IN;
  wire wci_wslv_respF_q_0$EN;

  // register wci_wslv_respF_q_1
  reg [33 : 0] wci_wslv_respF_q_1;
  reg [33 : 0] wci_wslv_respF_q_1$D_IN;
  wire wci_wslv_respF_q_1$EN;

  // register wci_wslv_sFlagReg
  reg wci_wslv_sFlagReg;
  wire wci_wslv_sFlagReg$D_IN, wci_wslv_sFlagReg$EN;

  // register wci_wslv_sThreadBusy_d
  reg wci_wslv_sThreadBusy_d;
  wire wci_wslv_sThreadBusy_d$D_IN, wci_wslv_sThreadBusy_d$EN;

  // ports of submodule spiCDC_cd
  wire spiCDC_cd$CLK_OUT, spiCDC_cd$PREEDGE;

  // ports of submodule spiCDC_cinv
  wire spiCDC_cinv$CLK_OUT;

  // ports of submodule spiCDC_reqF_dCombinedReset
  wire spiCDC_reqF_dCombinedReset$RST_OUT;

  // ports of submodule spiCDC_reqF_dCrossedsReset
  wire spiCDC_reqF_dCrossedsReset$OUT_RST_N;

  // ports of submodule spiCDC_reqF_dInReset
  wire spiCDC_reqF_dInReset$VAL;

  // ports of submodule spiCDC_reqF_sCombinedReset
  wire spiCDC_reqF_sCombinedReset$RST_OUT;

  // ports of submodule spiCDC_reqF_sCrosseddReset
  wire spiCDC_reqF_sCrosseddReset$OUT_RST_N;

  // ports of submodule spiCDC_reqF_sInReset
  wire spiCDC_reqF_sInReset$VAL;

  // ports of submodule spiCDC_respF_dCombinedReset
  wire spiCDC_respF_dCombinedReset$RST_OUT;

  // ports of submodule spiCDC_respF_dCrossedsReset
  wire spiCDC_respF_dCrossedsReset$OUT_RST_N;

  // ports of submodule spiCDC_respF_dInReset
  wire spiCDC_respF_dInReset$VAL;

  // ports of submodule spiCDC_respF_sCombinedReset
  wire spiCDC_respF_sCombinedReset$RST_OUT;

  // ports of submodule spiCDC_respF_sCrosseddReset
  wire spiCDC_respF_sCrosseddReset$OUT_RST_N;

  // ports of submodule spiCDC_respF_sInReset
  wire spiCDC_respF_sInReset$VAL;

  // ports of submodule spiCDC_slowReset
  wire spiCDC_slowReset$OUT_RST_N;

  // ports of submodule wci_wslv_reqF
  wire [71 : 0] wci_wslv_reqF$D_IN, wci_wslv_reqF$D_OUT;
  wire wci_wslv_reqF$CLR,
       wci_wslv_reqF$DEQ,
       wci_wslv_reqF$EMPTY_N,
       wci_wslv_reqF$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_spi_response,
       CAN_FIRE_RL_wci_cfwr,
       WILL_FIRE_RL_spiCDC_rd_resp,
       WILL_FIRE_RL_spiCDC_recv_d,
       WILL_FIRE_RL_spiCDC_reqF_deq_update_head,
       WILL_FIRE_RL_spiCDC_reqF_enq_update_tail,
       WILL_FIRE_RL_spiCDC_respF_deq_update_head,
       WILL_FIRE_RL_spiCDC_respF_enq_update_tail,
       WILL_FIRE_RL_spiCDC_send_d,
       WILL_FIRE_RL_spiCDC_start_cs,
       WILL_FIRE_RL_spi_response,
       WILL_FIRE_RL_wci_cfrd,
       WILL_FIRE_RL_wci_cfwr,
       WILL_FIRE_RL_wci_ctrl_EiI,
       WILL_FIRE_RL_wci_ctrl_IsO,
       WILL_FIRE_RL_wci_ctrl_OrE,
       WILL_FIRE_RL_wci_wslv_ctl_op_complete,
       WILL_FIRE_RL_wci_wslv_ctl_op_start,
       WILL_FIRE_RL_wci_wslv_respF_both,
       WILL_FIRE_RL_wci_wslv_respF_decCtr,
       WILL_FIRE_RL_wci_wslv_respF_incCtr;

  // inputs to muxes for submodule ports
  reg [33 : 0] MUX_wci_wslv_respF_q_0$write_1__VAL_1;
  wire [33 : 0] MUX_wci_wslv_respF_q_0$write_1__VAL_2,
		MUX_wci_wslv_respF_q_1$write_1__VAL_2,
		MUX_wci_wslv_respF_x_wire$wset_1__VAL_1,
		MUX_wci_wslv_respF_x_wire$wset_1__VAL_2,
		MUX_wci_wslv_respF_x_wire$wset_1__VAL_3;
  wire [32 : 0] MUX_spiCDC_reqS$write_1__VAL_1,
		MUX_spiCDC_reqS$write_1__VAL_2;
  wire [17 : 0] MUX_fcCdc_grayCounter_rsCounter$write_1__VAL_1,
		MUX_oneKHz_value$write_1__VAL_1;
  wire [5 : 0] MUX_spiCDC_rPos$write_1__VAL_1, MUX_spiCDC_rPos$write_1__VAL_2;
  wire [4 : 0] MUX_spiCDC_dPos$write_1__VAL_1;
  wire [1 : 0] MUX_wci_wslv_respF_c_r$write_1__VAL_1,
	       MUX_wci_wslv_respF_c_r$write_1__VAL_2;
  wire MUX_spiCDC_doResp_1$wset_1__SEL_1,
       MUX_spiCDC_rcv_d$write_1__SEL_1,
       MUX_spiCDC_reqS$write_1__SEL_1,
       MUX_spiCDC_reqS$write_1__SEL_2,
       MUX_wci_wslv_illegalEdge$write_1__SEL_1,
       MUX_wci_wslv_illegalEdge$write_1__SEL_2,
       MUX_wci_wslv_illegalEdge$write_1__VAL_2,
       MUX_wci_wslv_respF_q_0$write_1__SEL_1,
       MUX_wci_wslv_respF_q_1$write_1__SEL_1,
       MUX_wci_wslv_respF_x_wire$wset_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h32653, v__h33142, v__h3616, v__h3790, v__h3934;
  reg [31 : 0] rdat__h33126;
  reg CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2,
      CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3;
  wire [31 : 0] IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_OR__ETC___d558,
		IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_ETC___d559,
		rdat__h33002;
  wire [27 : 0] spiCDC_reqS_BITS_27_TO_0__q1;
  wire [17 : 0] x__h27174, y__h28579;
  wire [4 : 0] _31_MINUS_spiCDC_dPos_31___d527, x__h13513;
  wire _dor1spiCDC_reqF_enq_pw$EN_wset,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d565,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d566,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d567,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d568,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d569,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d570,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d571,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d572,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d573,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d574,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d575,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d576,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d577,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d578,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d579,
       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d580,
       fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_fc_ETC___d528,
       spiCDC_reqF_head_wrapped_crossed__67_EQ_spiCDC_ETC___d451,
       wci_wslv_reqF_i_notEmpty__4_AND_IF_wci_wslv_re_ETC___d472,
       x__h13470,
       z__h27194,
       z__h27201,
       z__h27208,
       z__h27215,
       z__h27222,
       z__h27229,
       z__h27236,
       z__h27243,
       z__h27250,
       z__h27257,
       z__h27264,
       z__h27271,
       z__h27278,
       z__h27285,
       z__h27292,
       z__h27299;

  // oscillator and gates for output clock CLK_pads_sclk
  assign CLK_pads_sclk = spiCDC_cd$CLK_OUT ;
  assign CLK_GATE_pads_sclk = 1'b1 ;

  // oscillator and gates for output clock CLK_pads_sclkn
  assign CLK_pads_sclkn = spiCDC_cinv$CLK_OUT ;
  assign CLK_GATE_pads_sclkn = 1'b1 ;

  // output resets
  assign RST_N_pads_srst = spiCDC_slowReset$OUT_RST_N ;

  // value method wciS0_sResp
  assign wciS0_SResp = wci_wslv_respF_q_0[33:32] ;

  // value method wciS0_sData
  assign wciS0_SData = wci_wslv_respF_q_0[31:0] ;

  // value method wciS0_sThreadBusy
  assign wciS0_SThreadBusy =
	     wci_wslv_reqF_countReg > 2'd1 || wci_wslv_isReset_isInReset ;

  // value method wciS0_sFlag
  assign wciS0_SFlag = { 1'd1, wci_wslv_sFlagReg } ;

  // value method pads_sdo
  assign pads_sdo = spiCDC_sdoR ;

  // value method pads_csb
  assign pads_csb = spiCDC_csbR ;

  // value method pads_sclkgate
  assign pads_sclkgate = spiCDC_cGate ;

  // submodule spiCDC_cd
  ClockDiv #(.width(32'd3),
	     .lower(32'd0),
	     .upper(32'd7),
	     .offset(32'd0)) spiCDC_cd(.CLK_IN(wciS0_Clk),
				       .RST_N(wciS0_MReset_n),
				       .PREEDGE(spiCDC_cd$PREEDGE),
				       .CLK_OUT(spiCDC_cd$CLK_OUT));

  // submodule spiCDC_cinv
  ClockInverter spiCDC_cinv(.CLK_IN(spiCDC_cd$CLK_OUT),
			    .PREEDGE(),
			    .CLK_OUT(spiCDC_cinv$CLK_OUT));

  // submodule spiCDC_reqF_dCombinedReset
  ResetEither spiCDC_reqF_dCombinedReset(.A_RST(spiCDC_slowReset$OUT_RST_N),
					 .B_RST(spiCDC_reqF_dCrossedsReset$OUT_RST_N),
					 .RST_OUT(spiCDC_reqF_dCombinedReset$RST_OUT));

  // submodule spiCDC_reqF_dCrossedsReset
  SyncReset0 spiCDC_reqF_dCrossedsReset(.IN_RST_N(wciS0_MReset_n),
					.OUT_RST_N(spiCDC_reqF_dCrossedsReset$OUT_RST_N));

  // submodule spiCDC_reqF_dInReset
  ResetToBool spiCDC_reqF_dInReset(.RST(spiCDC_reqF_dCombinedReset$RST_OUT),
				   .VAL(spiCDC_reqF_dInReset$VAL));

  // submodule spiCDC_reqF_sCombinedReset
  ResetEither spiCDC_reqF_sCombinedReset(.A_RST(wciS0_MReset_n),
					 .B_RST(spiCDC_reqF_sCrosseddReset$OUT_RST_N),
					 .RST_OUT(spiCDC_reqF_sCombinedReset$RST_OUT));

  // submodule spiCDC_reqF_sCrosseddReset
  SyncReset0 spiCDC_reqF_sCrosseddReset(.IN_RST_N(spiCDC_slowReset$OUT_RST_N),
					.OUT_RST_N(spiCDC_reqF_sCrosseddReset$OUT_RST_N));

  // submodule spiCDC_reqF_sInReset
  ResetToBool spiCDC_reqF_sInReset(.RST(spiCDC_reqF_sCombinedReset$RST_OUT),
				   .VAL(spiCDC_reqF_sInReset$VAL));

  // submodule spiCDC_respF_dCombinedReset
  ResetEither spiCDC_respF_dCombinedReset(.A_RST(wciS0_MReset_n),
					  .B_RST(spiCDC_respF_dCrossedsReset$OUT_RST_N),
					  .RST_OUT(spiCDC_respF_dCombinedReset$RST_OUT));

  // submodule spiCDC_respF_dCrossedsReset
  SyncReset0 spiCDC_respF_dCrossedsReset(.IN_RST_N(spiCDC_slowReset$OUT_RST_N),
					 .OUT_RST_N(spiCDC_respF_dCrossedsReset$OUT_RST_N));

  // submodule spiCDC_respF_dInReset
  ResetToBool spiCDC_respF_dInReset(.RST(spiCDC_respF_dCombinedReset$RST_OUT),
				    .VAL(spiCDC_respF_dInReset$VAL));

  // submodule spiCDC_respF_sCombinedReset
  ResetEither spiCDC_respF_sCombinedReset(.A_RST(spiCDC_slowReset$OUT_RST_N),
					  .B_RST(spiCDC_respF_sCrosseddReset$OUT_RST_N),
					  .RST_OUT(spiCDC_respF_sCombinedReset$RST_OUT));

  // submodule spiCDC_respF_sCrosseddReset
  SyncReset0 spiCDC_respF_sCrosseddReset(.IN_RST_N(wciS0_MReset_n),
					 .OUT_RST_N(spiCDC_respF_sCrosseddReset$OUT_RST_N));

  // submodule spiCDC_respF_sInReset
  ResetToBool spiCDC_respF_sInReset(.RST(spiCDC_respF_sCombinedReset$RST_OUT),
				    .VAL(spiCDC_respF_sInReset$VAL));

  // submodule spiCDC_slowReset
  SyncResetA #(.RSTDELAY(32'd1)) spiCDC_slowReset(.CLK(spiCDC_cd$CLK_OUT),
						  .IN_RST_N(wciS0_MReset_n),
						  .OUT_RST_N(spiCDC_slowReset$OUT_RST_N));

  // submodule wci_wslv_reqF
  SizedFIFO #(.p1width(32'd72),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) wci_wslv_reqF(.RST_N(wciS0_MReset_n),
					     .CLK(wciS0_Clk),
					     .D_IN(wci_wslv_reqF$D_IN),
					     .ENQ(wci_wslv_reqF$ENQ),
					     .DEQ(wci_wslv_reqF$DEQ),
					     .CLR(wci_wslv_reqF$CLR),
					     .D_OUT(wci_wslv_reqF$D_OUT),
					     .FULL_N(),
					     .EMPTY_N(wci_wslv_reqF$EMPTY_N));

  // rule RL_spi_response
  assign CAN_FIRE_RL_spi_response =
	     wci_wslv_respF_c_r != 2'd2 &&
	     spiCDC_respF_head_wrapped != spiCDC_respF_tail_wrapped &&
	     !spiCDC_respF_dInReset$VAL &&
	     spiCDC_cd$PREEDGE ;
  assign WILL_FIRE_RL_spi_response =
	     CAN_FIRE_RL_spi_response &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_cfwr
  assign CAN_FIRE_RL_wci_cfwr =
	     wci_wslv_respF_c_r != 2'd2 && wci_wslv_reqF$EMPTY_N &&
	     (wci_wslv_reqF$D_OUT[43:42] != 2'b0 ||
	      spiCDC_reqF_head_wrapped_crossed__67_EQ_spiCDC_ETC___d451) &&
	     wci_wslv_wci_cfwr_pw$whas ;
  assign WILL_FIRE_RL_wci_cfwr =
	     CAN_FIRE_RL_wci_cfwr && !WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_cfrd
  assign WILL_FIRE_RL_wci_cfrd =
	     wci_wslv_reqF_i_notEmpty__4_AND_IF_wci_wslv_re_ETC___d472 &&
	     wci_wslv_wci_cfrd_pw$whas &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_wslv_ctl_op_start
  assign WILL_FIRE_RL_wci_wslv_ctl_op_start =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_wci_ctrl_pw$whas &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_ctrl_EiI
  assign WILL_FIRE_RL_wci_ctrl_EiI =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd0 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd0 ;

  // rule RL_wci_ctrl_IsO
  assign WILL_FIRE_RL_wci_ctrl_IsO =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd1 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd1 ;

  // rule RL_wci_ctrl_OrE
  assign WILL_FIRE_RL_wci_ctrl_OrE =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd2 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd3 ;

  // rule RL_wci_wslv_ctl_op_complete
  assign WILL_FIRE_RL_wci_wslv_ctl_op_complete =
	     wci_wslv_respF_c_r != 2'd2 && wci_wslv_ctlOpActive &&
	     wci_wslv_ctlAckReg ;

  // rule RL_wci_wslv_respF_incCtr
  assign WILL_FIRE_RL_wci_wslv_respF_incCtr =
	     ((wci_wslv_respF_c_r == 2'd0) ?
		wci_wslv_respF_x_wire$whas :
		wci_wslv_respF_c_r != 2'd1 || wci_wslv_respF_x_wire$whas) &&
	     wci_wslv_respF_enqueueing$whas &&
	     !(wci_wslv_respF_c_r != 2'd0) ;

  // rule RL_wci_wslv_respF_decCtr
  assign WILL_FIRE_RL_wci_wslv_respF_decCtr =
	     wci_wslv_respF_c_r != 2'd0 && !wci_wslv_respF_enqueueing$whas ;

  // rule RL_wci_wslv_respF_both
  assign WILL_FIRE_RL_wci_wslv_respF_both =
	     ((wci_wslv_respF_c_r == 2'd1) ?
		wci_wslv_respF_x_wire$whas :
		wci_wslv_respF_c_r != 2'd2 || wci_wslv_respF_x_wire$whas) &&
	     wci_wslv_respF_c_r != 2'd0 &&
	     wci_wslv_respF_enqueueing$whas ;

  // rule RL_spiCDC_start_cs
  assign WILL_FIRE_RL_spiCDC_start_cs =
	     spiCDC_reqF_head_wrapped != spiCDC_reqF_tail_wrapped &&
	     !spiCDC_reqF_dInReset$VAL &&
	     !spiCDC_xmt_d &&
	     !spiCDC_rcv_d &&
	     !spiCDC_doResp ;

  // rule RL_spiCDC_send_d
  assign WILL_FIRE_RL_spiCDC_send_d =
	     spiCDC_reqF_head_wrapped != spiCDC_reqF_tail_wrapped &&
	     !spiCDC_reqF_dInReset$VAL &&
	     spiCDC_xmt_d &&
	     !spiCDC_rcv_d &&
	     !spiCDC_doResp ;

  // rule RL_spiCDC_recv_d
  assign WILL_FIRE_RL_spiCDC_recv_d =
	     !spiCDC_xmt_d && spiCDC_rcv_d && !spiCDC_doResp ;

  // rule RL_spiCDC_rd_resp
  assign WILL_FIRE_RL_spiCDC_rd_resp =
	     spiCDC_respF_head_wrapped == spiCDC_respF_tail_wrapped &&
	     !spiCDC_respF_sInReset$VAL &&
	     !spiCDC_xmt_d &&
	     !spiCDC_rcv_d &&
	     spiCDC_doResp ;

  // rule RL_spiCDC_reqF_enq_update_tail
  assign WILL_FIRE_RL_spiCDC_reqF_enq_update_tail =
	     !spiCDC_reqF_sInReset$VAL && spiCDC_reqF_enq_pw$whas ;

  // rule RL_spiCDC_reqF_deq_update_head
  assign WILL_FIRE_RL_spiCDC_reqF_deq_update_head =
	     !spiCDC_reqF_dInReset$VAL && MUX_spiCDC_rcv_d$write_1__SEL_1 ;

  // rule RL_spiCDC_respF_enq_update_tail
  assign WILL_FIRE_RL_spiCDC_respF_enq_update_tail =
	     !spiCDC_respF_sInReset$VAL && WILL_FIRE_RL_spiCDC_rd_resp ;

  // rule RL_spiCDC_respF_deq_update_head
  assign WILL_FIRE_RL_spiCDC_respF_deq_update_head =
	     !spiCDC_respF_dInReset$VAL && WILL_FIRE_RL_spi_response ;

  // inputs to muxes for submodule ports
  assign MUX_spiCDC_doResp_1$wset_1__SEL_1 =
	     WILL_FIRE_RL_spiCDC_recv_d && spiCDC_rPos == 6'd0 ;
  assign MUX_spiCDC_rcv_d$write_1__SEL_1 =
	     WILL_FIRE_RL_spiCDC_send_d && spiCDC_dPos == 5'd0 ;
  assign MUX_spiCDC_reqS$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_cfwr && wci_wslv_reqF$D_OUT[43:42] == 2'b0 ;
  assign MUX_spiCDC_reqS$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] == 2'b0 ;
  assign MUX_wci_wslv_illegalEdge$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge ;
  assign MUX_wci_wslv_illegalEdge$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     (wci_wslv_reqF$D_OUT[36:34] == 3'd0 && wci_wslv_cState != 3'd0 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd1 && wci_wslv_cState != 3'd1 &&
	      wci_wslv_cState != 3'd3 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd2 && wci_wslv_cState != 3'd2 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd3 && wci_wslv_cState != 3'd3 &&
	      wci_wslv_cState != 3'd2 &&
	      wci_wslv_cState != 3'd1 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd4 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd5 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd6 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd7) ;
  assign MUX_wci_wslv_respF_q_0$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd0 ;
  assign MUX_wci_wslv_respF_q_1$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd1 ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__SEL_1 =
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] != 2'b0 ;
  assign MUX_fcCdc_grayCounter_rsCounter$write_1__VAL_1 =
	     (~fcCdc_grayCounter_rsCounter[IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_ETC___d559[4:0]]) ?
	       fcCdc_grayCounter_rsCounter | x__h27174 :
	       fcCdc_grayCounter_rsCounter & y__h28579 ;
  assign MUX_oneKHz_value$write_1__VAL_1 =
	     (oneKHz_value == 18'd124999) ? 18'd0 : oneKHz_value + 18'd1 ;
  assign MUX_spiCDC_dPos$write_1__VAL_1 =
	     (spiCDC_dPos == 5'd0) ? spiCDC_dPos : spiCDC_dPos - 5'd1 ;
  assign MUX_spiCDC_rPos$write_1__VAL_1 = spiCDC_reqS[32] ? 6'd32 : 6'd0 ;
  assign MUX_spiCDC_rPos$write_1__VAL_2 =
	     (spiCDC_rPos == 6'd0) ? spiCDC_rPos : spiCDC_rPos - 6'd1 ;
  assign MUX_spiCDC_reqS$write_1__VAL_1 =
	     { 1'd0, wci_wslv_reqF$D_OUT[37:34], wci_wslv_reqF$D_OUT[27:0] } ;
  assign MUX_spiCDC_reqS$write_1__VAL_2 =
	     { 1'd1, wci_wslv_reqF$D_OUT[37:34], 28'd0 } ;
  assign MUX_wci_wslv_illegalEdge$write_1__VAL_2 =
	     wci_wslv_reqF$D_OUT[36:34] != 3'd4 &&
	     wci_wslv_reqF$D_OUT[36:34] != 3'd5 &&
	     wci_wslv_reqF$D_OUT[36:34] != 3'd6 ;
  assign MUX_wci_wslv_respF_c_r$write_1__VAL_1 = wci_wslv_respF_c_r + 2'd1 ;
  assign MUX_wci_wslv_respF_c_r$write_1__VAL_2 = wci_wslv_respF_c_r - 2'd1 ;
  always@(MUX_wci_wslv_respF_x_wire$wset_1__SEL_1 or
	  MUX_wci_wslv_respF_x_wire$wset_1__VAL_1 or
	  WILL_FIRE_RL_wci_wslv_ctl_op_complete or
	  MUX_wci_wslv_respF_x_wire$wset_1__VAL_2 or
	  WILL_FIRE_RL_spi_response or
	  MUX_wci_wslv_respF_x_wire$wset_1__VAL_3 or WILL_FIRE_RL_wci_cfwr)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_wci_wslv_respF_x_wire$wset_1__SEL_1:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 =
	      MUX_wci_wslv_respF_x_wire$wset_1__VAL_1;
      WILL_FIRE_RL_wci_wslv_ctl_op_complete:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 =
	      MUX_wci_wslv_respF_x_wire$wset_1__VAL_2;
      WILL_FIRE_RL_spi_response:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 =
	      MUX_wci_wslv_respF_x_wire$wset_1__VAL_3;
      WILL_FIRE_RL_wci_cfwr:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 = 34'h1C0DE4201;
      default: MUX_wci_wslv_respF_q_0$write_1__VAL_1 =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign MUX_wci_wslv_respF_q_0$write_1__VAL_2 =
	     (wci_wslv_respF_c_r == 2'd1) ?
	       MUX_wci_wslv_respF_q_0$write_1__VAL_1 :
	       wci_wslv_respF_q_1 ;
  assign MUX_wci_wslv_respF_q_1$write_1__VAL_2 =
	     (wci_wslv_respF_c_r == 2'd2) ?
	       MUX_wci_wslv_respF_q_0$write_1__VAL_1 :
	       34'h0AAAAAAAA ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__VAL_1 = { 2'd1, rdat__h33126 } ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__VAL_2 =
	     wci_wslv_illegalEdge ? 34'h3C0DE4202 : 34'h1C0DE4201 ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__VAL_3 = { 6'd16, spiCDC_respS } ;

  // inlined wires
  assign wci_wslv_wciReq$wget =
	     { wciS0_MCmd,
	       wciS0_MAddrSpace,
	       wciS0_MByteEn,
	       wciS0_MAddr,
	       wciS0_MData } ;
  assign wci_wslv_wciReq$whas = 1'd1 ;
  assign wci_wslv_respF_x_wire$wget = MUX_wci_wslv_respF_q_0$write_1__VAL_1 ;
  assign wci_wslv_respF_x_wire$whas =
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] != 2'b0 ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete ||
	     WILL_FIRE_RL_spi_response ||
	     WILL_FIRE_RL_wci_cfwr ;
  assign wci_wslv_wEdge$wget = wci_wslv_reqF$D_OUT[36:34] ;
  assign wci_wslv_wEdge$whas = WILL_FIRE_RL_wci_wslv_ctl_op_start ;
  assign wci_wslv_sFlagReg_1$wget = 1'b0 ;
  assign wci_wslv_sFlagReg_1$whas = 1'b0 ;
  assign wci_wslv_ctlAckReg_1$wget = 1'd1 ;
  assign wci_wslv_ctlAckReg_1$whas =
	     WILL_FIRE_RL_wci_ctrl_OrE || WILL_FIRE_RL_wci_ctrl_IsO ||
	     WILL_FIRE_RL_wci_ctrl_EiI ;
  assign wci_wci_Es_mCmd_w$wget = wciS0_MCmd ;
  assign wci_wci_Es_mCmd_w$whas = 1'd1 ;
  assign wci_wci_Es_mAddrSpace_w$wget = wciS0_MAddrSpace ;
  assign wci_wci_Es_mAddrSpace_w$whas = 1'd1 ;
  assign wci_wci_Es_mAddr_w$wget = wciS0_MAddr ;
  assign wci_wci_Es_mAddr_w$whas = 1'd1 ;
  assign wci_wci_Es_mData_w$wget = wciS0_MData ;
  assign wci_wci_Es_mData_w$whas = 1'd1 ;
  assign wci_wci_Es_mByteEn_w$wget = wciS0_MByteEn ;
  assign wci_wci_Es_mByteEn_w$whas = 1'd1 ;
  assign spiCDC_cGate_1$wget =
	     !WILL_FIRE_RL_spiCDC_recv_d || spiCDC_rPos != 6'd32 ;
  assign spiCDC_cGate_1$whas =
	     WILL_FIRE_RL_spiCDC_recv_d || WILL_FIRE_RL_spiCDC_send_d ;
  assign spiCDC_csbR_1$wget =
	     WILL_FIRE_RL_spiCDC_recv_d && spiCDC_rPos == 6'd32 ;
  assign spiCDC_csbR_1$whas = spiCDC_cGate_1$whas ;
  assign spiCDC_doResp_1$wget = MUX_spiCDC_doResp_1$wset_1__SEL_1 ;
  assign spiCDC_doResp_1$whas =
	     WILL_FIRE_RL_spiCDC_recv_d && spiCDC_rPos == 6'd0 ||
	     WILL_FIRE_RL_spiCDC_rd_resp ;
  assign fcCdc_pulseAction_1$wget = 1'd1 ;
  assign fcCdc_pulseAction_1$whas = oneKHz_value == 18'd124999 ;
  assign wci_wslv_reqF_r_enq$whas = wci_wslv_wciReq$wget[71:69] != 3'd0 ;
  assign wci_wslv_reqF_r_deq$whas =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_start ;
  assign wci_wslv_reqF_r_clr$whas = 1'b0 ;
  assign wci_wslv_respF_enqueueing$whas =
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] != 2'b0 ||
	     WILL_FIRE_RL_spi_response ||
	     WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete ;
  assign wci_wslv_respF_dequeueing$whas = wci_wslv_respF_c_r != 2'd0 ;
  assign wci_wslv_sThreadBusy_pw$whas = 1'b0 ;
  assign wci_wslv_wci_cfwr_pw$whas =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd1 ;
  assign wci_wslv_wci_cfrd_pw$whas =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd2 ;
  assign wci_wslv_wci_ctrl_pw$whas =
	     wci_wslv_reqF$EMPTY_N && !wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd2 ;
  assign spiCDC_reqF_enq_pw$whas =
	     _dor1spiCDC_reqF_enq_pw$EN_wset &&
	     wci_wslv_reqF$D_OUT[43:42] == 2'b0 ;
  assign spiCDC_reqF_deq_pw$whas = MUX_spiCDC_rcv_d$write_1__SEL_1 ;
  assign spiCDC_reqF_sClear_pw$whas = 1'b0 ;
  assign spiCDC_reqF_dClear_pw$whas = 1'b0 ;
  assign spiCDC_reqF_deq_happened$whas = 1'b0 ;
  assign spiCDC_respF_enq_pw$whas = WILL_FIRE_RL_spiCDC_rd_resp ;
  assign spiCDC_respF_deq_pw$whas = WILL_FIRE_RL_spi_response ;
  assign spiCDC_respF_sClear_pw$whas = 1'b0 ;
  assign spiCDC_respF_dClear_pw$whas = 1'b0 ;
  assign spiCDC_respF_deq_happened$whas = 1'b0 ;
  assign fcCdc_grayCounter_pwIncrement$whas = 1'd1 ;
  assign fcCdc_grayCounter_pwDecrement$whas = 1'b0 ;
  assign oneKHz_incAction$whas = 1'd1 ;
  assign oneKHz_decAction$whas = 1'b0 ;
  assign spiCDC_sdiWs$wget = spiCDC_sdiP ;
  assign fcCdc_grayCounter_wdCounterCrossing$wget =
	     fcCdc_grayCounter_rsCounter ;

  // register fcCdc_countNow
  assign fcCdc_countNow$D_IN =
	     { fcCdc_grayCounter_rdCounter[17],
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d565,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d566,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d567,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d568,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d569,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d570,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d571,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d572,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d573,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d574,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d575,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d576,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d577,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d578,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d579,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d580,
	       fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d580 ^
	       fcCdc_grayCounter_rdCounter[0] } ;
  assign fcCdc_countNow$EN = fcCdc_pulseAction ;

  // register fcCdc_countPast
  assign fcCdc_countPast$D_IN = fcCdc_countNow ;
  assign fcCdc_countPast$EN = fcCdc_pulseAction ;

  // register fcCdc_frequency
  assign fcCdc_frequency$D_IN = fcCdc_countNow - fcCdc_countPast ;
  assign fcCdc_frequency$EN = fcCdc_pulseAction ;

  // register fcCdc_grayCounter_rdCounter
  assign fcCdc_grayCounter_rdCounter$D_IN = fcCdc_grayCounter_rdCounterPre ;
  assign fcCdc_grayCounter_rdCounter$EN = 1'd1 ;

  // register fcCdc_grayCounter_rdCounterPre
  assign fcCdc_grayCounter_rdCounterPre$D_IN = fcCdc_grayCounter_rsCounter ;
  assign fcCdc_grayCounter_rdCounterPre$EN = 1'd1 ;

  // register fcCdc_grayCounter_rsCounter
  assign fcCdc_grayCounter_rsCounter$D_IN =
	     MUX_fcCdc_grayCounter_rsCounter$write_1__VAL_1 ;
  assign fcCdc_grayCounter_rsCounter$EN = 1'b1 ;

  // register fcCdc_pulseAction
  assign fcCdc_pulseAction$D_IN = oneKHz_value == 18'd124999 ;
  assign fcCdc_pulseAction$EN = 1'd1 ;

  // register fcCdc_sampleCount
  assign fcCdc_sampleCount$D_IN = fcCdc_sampleCount + 16'd1 ;
  assign fcCdc_sampleCount$EN = fcCdc_pulseAction ;

  // register oneKHz_value
  assign oneKHz_value$D_IN = MUX_oneKHz_value$write_1__VAL_1 ;
  assign oneKHz_value$EN = 1'b1 ;

  // register spiCDC_cGate
  assign spiCDC_cGate$D_IN = spiCDC_cGate_1$whas && spiCDC_cGate_1$wget ;
  assign spiCDC_cGate$EN = 1'd1 ;

  // register spiCDC_capV
  assign spiCDC_capV$D_IN = { spiCDC_sdiP, spiCDC_capV[27:1] } ;
  assign spiCDC_capV$EN = WILL_FIRE_RL_spiCDC_recv_d ;

  // register spiCDC_csbR
  assign spiCDC_csbR$D_IN = !spiCDC_cGate_1$whas || spiCDC_csbR_1$wget ;
  assign spiCDC_csbR$EN = 1'd1 ;

  // register spiCDC_dPos
  assign spiCDC_dPos$D_IN =
	     WILL_FIRE_RL_spiCDC_send_d ?
	       MUX_spiCDC_dPos$write_1__VAL_1 :
	       5'd31 ;
  assign spiCDC_dPos$EN =
	     WILL_FIRE_RL_spiCDC_send_d || WILL_FIRE_RL_spiCDC_start_cs ;

  // register spiCDC_doResp
  assign spiCDC_doResp$D_IN =
	     spiCDC_doResp_1$whas && MUX_spiCDC_doResp_1$wset_1__SEL_1 ;
  assign spiCDC_doResp$EN = 1'd1 ;

  // register spiCDC_rPos
  assign spiCDC_rPos$D_IN =
	     WILL_FIRE_RL_spiCDC_start_cs ?
	       MUX_spiCDC_rPos$write_1__VAL_1 :
	       MUX_spiCDC_rPos$write_1__VAL_2 ;
  assign spiCDC_rPos$EN =
	     WILL_FIRE_RL_spiCDC_start_cs || WILL_FIRE_RL_spiCDC_recv_d ;

  // register spiCDC_rcv_d
  assign spiCDC_rcv_d$D_IN =
	     MUX_spiCDC_rcv_d$write_1__SEL_1 && spiCDC_reqS[32] ;
  assign spiCDC_rcv_d$EN =
	     WILL_FIRE_RL_spiCDC_send_d && spiCDC_dPos == 5'd0 ||
	     WILL_FIRE_RL_spiCDC_recv_d && spiCDC_rPos == 6'd0 ;

  // register spiCDC_reqF_head_wrapped
  assign spiCDC_reqF_head_wrapped$D_IN =
	     WILL_FIRE_RL_spiCDC_reqF_deq_update_head &&
	     !spiCDC_reqF_head_wrapped ;
  assign spiCDC_reqF_head_wrapped$EN =
	     WILL_FIRE_RL_spiCDC_reqF_deq_update_head ||
	     spiCDC_reqF_dInReset$VAL ;

  // register spiCDC_reqF_tail_wrapped
  assign spiCDC_reqF_tail_wrapped$D_IN =
	     WILL_FIRE_RL_spiCDC_reqF_enq_update_tail &&
	     !spiCDC_reqF_tail_wrapped ;
  assign spiCDC_reqF_tail_wrapped$EN =
	     WILL_FIRE_RL_spiCDC_reqF_enq_update_tail ||
	     spiCDC_reqF_sInReset$VAL ;

  // register spiCDC_reqS
  assign spiCDC_reqS$D_IN =
	     MUX_spiCDC_reqS$write_1__SEL_1 ?
	       MUX_spiCDC_reqS$write_1__VAL_1 :
	       MUX_spiCDC_reqS$write_1__VAL_2 ;
  assign spiCDC_reqS$EN =
	     WILL_FIRE_RL_wci_cfwr && wci_wslv_reqF$D_OUT[43:42] == 2'b0 ||
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] == 2'b0 ;

  // register spiCDC_respF_head_wrapped
  assign spiCDC_respF_head_wrapped$D_IN =
	     WILL_FIRE_RL_spiCDC_respF_deq_update_head &&
	     !spiCDC_respF_head_wrapped ;
  assign spiCDC_respF_head_wrapped$EN =
	     WILL_FIRE_RL_spiCDC_respF_deq_update_head ||
	     spiCDC_respF_dInReset$VAL ;

  // register spiCDC_respF_tail_wrapped
  assign spiCDC_respF_tail_wrapped$D_IN =
	     WILL_FIRE_RL_spiCDC_respF_enq_update_tail &&
	     !spiCDC_respF_tail_wrapped ;
  assign spiCDC_respF_tail_wrapped$EN =
	     WILL_FIRE_RL_spiCDC_respF_enq_update_tail ||
	     spiCDC_respF_sInReset$VAL ;

  // register spiCDC_respS
  assign spiCDC_respS$D_IN = { spiCDC_sdiP, spiCDC_capV[27:1] } ;
  assign spiCDC_respS$EN = WILL_FIRE_RL_spiCDC_rd_resp ;

  // register spiCDC_sdiP
  assign spiCDC_sdiP$D_IN = pads_sdi_arg ;
  assign spiCDC_sdiP$EN = 1'd1 ;

  // register spiCDC_sdoR
  assign spiCDC_sdoR$D_IN =
	     spiCDC_reqS[32] ?
	       _31_MINUS_spiCDC_dPos_31___d527 != 5'd0 &&
	       (_31_MINUS_spiCDC_dPos_31___d527 == 5'd1 ||
		_31_MINUS_spiCDC_dPos_31___d527 == 5'd2 ||
		_31_MINUS_spiCDC_dPos_31___d527 == 5'd3 ||
		CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2) :
	       CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 ;
  assign spiCDC_sdoR$EN = WILL_FIRE_RL_spiCDC_send_d ;

  // register spiCDC_xmt_d
  assign spiCDC_xmt_d$D_IN = !MUX_spiCDC_rcv_d$write_1__SEL_1 ;
  assign spiCDC_xmt_d$EN =
	     WILL_FIRE_RL_spiCDC_send_d && spiCDC_dPos == 5'd0 ||
	     WILL_FIRE_RL_spiCDC_start_cs ;

  // register splitReadInFlight
  assign splitReadInFlight$D_IN = MUX_spiCDC_reqS$write_1__SEL_2 ;
  assign splitReadInFlight$EN =
	     WILL_FIRE_RL_wci_cfrd && wci_wslv_reqF$D_OUT[43:42] == 2'b0 ||
	     WILL_FIRE_RL_spi_response ;

  // register wci_wslv_cEdge
  assign wci_wslv_cEdge$D_IN = wci_wslv_reqF$D_OUT[36:34] ;
  assign wci_wslv_cEdge$EN = WILL_FIRE_RL_wci_wslv_ctl_op_start ;

  // register wci_wslv_cState
  assign wci_wslv_cState$D_IN = wci_wslv_nState ;
  assign wci_wslv_cState$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge ;

  // register wci_wslv_ctlAckReg
  assign wci_wslv_ctlAckReg$D_IN = wci_wslv_ctlAckReg_1$whas ;
  assign wci_wslv_ctlAckReg$EN = 1'd1 ;

  // register wci_wslv_ctlOpActive
  assign wci_wslv_ctlOpActive$D_IN = !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;
  assign wci_wslv_ctlOpActive$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_start ;

  // register wci_wslv_illegalEdge
  assign wci_wslv_illegalEdge$D_IN =
	     !MUX_wci_wslv_illegalEdge$write_1__SEL_1 &&
	     MUX_wci_wslv_illegalEdge$write_1__VAL_2 ;
  assign wci_wslv_illegalEdge$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge ||
	     MUX_wci_wslv_illegalEdge$write_1__SEL_2 ;

  // register wci_wslv_isReset_isInReset
  assign wci_wslv_isReset_isInReset$D_IN = 1'd0 ;
  assign wci_wslv_isReset_isInReset$EN = wci_wslv_isReset_isInReset ;

  // register wci_wslv_nState
  always@(wci_wslv_reqF$D_OUT)
  begin
    case (wci_wslv_reqF$D_OUT[36:34])
      3'd0: wci_wslv_nState$D_IN = 3'd1;
      3'd1: wci_wslv_nState$D_IN = 3'd2;
      3'd2: wci_wslv_nState$D_IN = 3'd3;
      default: wci_wslv_nState$D_IN = 3'd0;
    endcase
  end
  assign wci_wslv_nState$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     (wci_wslv_reqF$D_OUT[36:34] == 3'd0 && wci_wslv_cState == 3'd0 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd1 &&
	      (wci_wslv_cState == 3'd1 || wci_wslv_cState == 3'd3) ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd2 && wci_wslv_cState == 3'd2 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd3 &&
	      (wci_wslv_cState == 3'd3 || wci_wslv_cState == 3'd2 ||
	       wci_wslv_cState == 3'd1)) ;

  // register wci_wslv_reqF_countReg
  assign wci_wslv_reqF_countReg$D_IN =
	     (wci_wslv_wciReq$wget[71:69] != 3'd0) ?
	       wci_wslv_reqF_countReg + 2'd1 :
	       wci_wslv_reqF_countReg - 2'd1 ;
  assign wci_wslv_reqF_countReg$EN =
	     (wci_wslv_wciReq$wget[71:69] != 3'd0) !=
	     wci_wslv_reqF_r_deq$whas ;

  // register wci_wslv_respF_c_r
  assign wci_wslv_respF_c_r$D_IN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr ?
	       MUX_wci_wslv_respF_c_r$write_1__VAL_1 :
	       MUX_wci_wslv_respF_c_r$write_1__VAL_2 ;
  assign wci_wslv_respF_c_r$EN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_respF_q_0
  always@(MUX_wci_wslv_respF_q_0$write_1__SEL_1 or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 or
	  WILL_FIRE_RL_wci_wslv_respF_both or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 or
	  WILL_FIRE_RL_wci_wslv_respF_decCtr or wci_wslv_respF_q_1)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_wci_wslv_respF_q_0$write_1__SEL_1:
	  wci_wslv_respF_q_0$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_1;
      WILL_FIRE_RL_wci_wslv_respF_both:
	  wci_wslv_respF_q_0$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_2;
      WILL_FIRE_RL_wci_wslv_respF_decCtr:
	  wci_wslv_respF_q_0$D_IN = wci_wslv_respF_q_1;
      default: wci_wslv_respF_q_0$D_IN =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_wslv_respF_q_0$EN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd0 ||
	     WILL_FIRE_RL_wci_wslv_respF_both ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_respF_q_1
  always@(MUX_wci_wslv_respF_q_1$write_1__SEL_1 or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 or
	  WILL_FIRE_RL_wci_wslv_respF_both or
	  MUX_wci_wslv_respF_q_1$write_1__VAL_2 or
	  WILL_FIRE_RL_wci_wslv_respF_decCtr)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_wci_wslv_respF_q_1$write_1__SEL_1:
	  wci_wslv_respF_q_1$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_1;
      WILL_FIRE_RL_wci_wslv_respF_both:
	  wci_wslv_respF_q_1$D_IN = MUX_wci_wslv_respF_q_1$write_1__VAL_2;
      WILL_FIRE_RL_wci_wslv_respF_decCtr:
	  wci_wslv_respF_q_1$D_IN = 34'h0AAAAAAAA;
      default: wci_wslv_respF_q_1$D_IN =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_wslv_respF_q_1$EN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd1 ||
	     WILL_FIRE_RL_wci_wslv_respF_both ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_sFlagReg
  assign wci_wslv_sFlagReg$D_IN = 1'b0 ;
  assign wci_wslv_sFlagReg$EN = 1'd1 ;

  // register wci_wslv_sThreadBusy_d
  assign wci_wslv_sThreadBusy_d$D_IN = 1'b0 ;
  assign wci_wslv_sThreadBusy_d$EN = 1'd1 ;

  // submodule wci_wslv_reqF
  assign wci_wslv_reqF$D_IN = wci_wslv_wciReq$wget ;
  assign wci_wslv_reqF$ENQ = wci_wslv_wciReq$wget[71:69] != 3'd0 ;
  assign wci_wslv_reqF$DEQ = wci_wslv_reqF_r_deq$whas ;
  assign wci_wslv_reqF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_OR__ETC___d558 =
	     (fcCdc_grayCounter_rsCounter[0] ||
	      fcCdc_grayCounter_rsCounter[1] ||
	      fcCdc_grayCounter_rsCounter[2] ||
	      fcCdc_grayCounter_rsCounter[3] ||
	      fcCdc_grayCounter_rsCounter[4] ||
	      fcCdc_grayCounter_rsCounter[5] ||
	      fcCdc_grayCounter_rsCounter[6] ||
	      fcCdc_grayCounter_rsCounter[7] ||
	      fcCdc_grayCounter_rsCounter[8] ||
	      fcCdc_grayCounter_rsCounter[9] ||
	      fcCdc_grayCounter_rsCounter[10] ||
	      fcCdc_grayCounter_rsCounter[11] ||
	      fcCdc_grayCounter_rsCounter[12] ||
	      fcCdc_grayCounter_rsCounter[13] ||
	      fcCdc_grayCounter_rsCounter[14] ||
	      fcCdc_grayCounter_rsCounter[15] ||
	      fcCdc_grayCounter_rsCounter[16]) ?
	       (fcCdc_grayCounter_rsCounter[0] ?
		  32'd1 :
		  (fcCdc_grayCounter_rsCounter[1] ?
		     32'd2 :
		     (fcCdc_grayCounter_rsCounter[2] ?
			32'd3 :
			(fcCdc_grayCounter_rsCounter[3] ?
			   32'd4 :
			   (fcCdc_grayCounter_rsCounter[4] ?
			      32'd5 :
			      (fcCdc_grayCounter_rsCounter[5] ?
				 32'd6 :
				 (fcCdc_grayCounter_rsCounter[6] ?
				    32'd7 :
				    (fcCdc_grayCounter_rsCounter[7] ?
				       32'd8 :
				       (fcCdc_grayCounter_rsCounter[8] ?
					  32'd9 :
					  (fcCdc_grayCounter_rsCounter[9] ?
					     32'd10 :
					     (fcCdc_grayCounter_rsCounter[10] ?
						32'd11 :
						(fcCdc_grayCounter_rsCounter[11] ?
						   32'd12 :
						   (fcCdc_grayCounter_rsCounter[12] ?
						      32'd13 :
						      (fcCdc_grayCounter_rsCounter[13] ?
							 32'd14 :
							 (fcCdc_grayCounter_rsCounter[14] ?
							    32'd15 :
							    (fcCdc_grayCounter_rsCounter[15] ?
							       32'd16 :
							       (fcCdc_grayCounter_rsCounter[16] ?
								  32'd17 :
								  (fcCdc_grayCounter_rsCounter[17] ?
								     32'd18 :
								     32'd19)))))))))))))))))) :
	       32'd17 ;
  assign IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_ETC___d559 =
	     fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_fc_ETC___d528 ?
	       IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_OR__ETC___d558 :
	       32'd0 ;
  assign _31_MINUS_spiCDC_dPos_31___d527 = 5'd31 - spiCDC_dPos ;
  assign _dor1spiCDC_reqF_enq_pw$EN_wset =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d565 =
	     fcCdc_grayCounter_rdCounter[17] ^
	     fcCdc_grayCounter_rdCounter[16] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d566 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d565 ^
	     fcCdc_grayCounter_rdCounter[15] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d567 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d566 ^
	     fcCdc_grayCounter_rdCounter[14] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d568 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d567 ^
	     fcCdc_grayCounter_rdCounter[13] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d569 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d568 ^
	     fcCdc_grayCounter_rdCounter[12] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d570 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d569 ^
	     fcCdc_grayCounter_rdCounter[11] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d571 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d570 ^
	     fcCdc_grayCounter_rdCounter[10] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d572 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d571 ^
	     fcCdc_grayCounter_rdCounter[9] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d573 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d572 ^
	     fcCdc_grayCounter_rdCounter[8] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d574 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d573 ^
	     fcCdc_grayCounter_rdCounter[7] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d575 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d574 ^
	     fcCdc_grayCounter_rdCounter[6] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d576 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d575 ^
	     fcCdc_grayCounter_rdCounter[5] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d577 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d576 ^
	     fcCdc_grayCounter_rdCounter[4] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d578 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d577 ^
	     fcCdc_grayCounter_rdCounter[3] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d579 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d578 ^
	     fcCdc_grayCounter_rdCounter[2] ;
  assign fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d580 =
	     fcCdc_grayCounter_rdCounter_82_BIT_17_83_XOR_f_ETC___d579 ^
	     fcCdc_grayCounter_rdCounter[1] ;
  assign fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_fc_ETC___d528 =
	     z__h27299 ^ fcCdc_grayCounter_rsCounter[17] ;
  assign rdat__h33002 = { 14'd0, fcCdc_frequency } ;
  assign spiCDC_reqF_head_wrapped_crossed__67_EQ_spiCDC_ETC___d451 =
	     spiCDC_reqF_head_wrapped == spiCDC_reqF_tail_wrapped &&
	     !spiCDC_reqF_sInReset$VAL &&
	     spiCDC_cd$PREEDGE ;
  assign spiCDC_reqS_BITS_27_TO_0__q1 = spiCDC_reqS[27:0] ;
  assign wci_wslv_reqF_i_notEmpty__4_AND_IF_wci_wslv_re_ETC___d472 =
	     wci_wslv_reqF$EMPTY_N &&
	     ((wci_wslv_reqF$D_OUT[43:42] == 2'b0) ?
		spiCDC_reqF_head_wrapped_crossed__67_EQ_spiCDC_ETC___d451 :
		wci_wslv_respF_c_r != 2'd2) ;
  assign x__h13470 = spiCDC_reqS_BITS_27_TO_0__q1[x__h13513] ;
  assign x__h13513 = 5'd27 - spiCDC_dPos ;
  assign x__h27174 =
	     18'd1 <<
	     IF_fcCdc_grayCounter_rsCounter_84_BIT_0_91_XOR_ETC___d559 ;
  assign y__h28579 = ~x__h27174 ;
  assign z__h27194 =
	     fcCdc_grayCounter_rsCounter[0] ^ fcCdc_grayCounter_rsCounter[1] ;
  assign z__h27201 = z__h27194 ^ fcCdc_grayCounter_rsCounter[2] ;
  assign z__h27208 = z__h27201 ^ fcCdc_grayCounter_rsCounter[3] ;
  assign z__h27215 = z__h27208 ^ fcCdc_grayCounter_rsCounter[4] ;
  assign z__h27222 = z__h27215 ^ fcCdc_grayCounter_rsCounter[5] ;
  assign z__h27229 = z__h27222 ^ fcCdc_grayCounter_rsCounter[6] ;
  assign z__h27236 = z__h27229 ^ fcCdc_grayCounter_rsCounter[7] ;
  assign z__h27243 = z__h27236 ^ fcCdc_grayCounter_rsCounter[8] ;
  assign z__h27250 = z__h27243 ^ fcCdc_grayCounter_rsCounter[9] ;
  assign z__h27257 = z__h27250 ^ fcCdc_grayCounter_rsCounter[10] ;
  assign z__h27264 = z__h27257 ^ fcCdc_grayCounter_rsCounter[11] ;
  assign z__h27271 = z__h27264 ^ fcCdc_grayCounter_rsCounter[12] ;
  assign z__h27278 = z__h27271 ^ fcCdc_grayCounter_rsCounter[13] ;
  assign z__h27285 = z__h27278 ^ fcCdc_grayCounter_rsCounter[14] ;
  assign z__h27292 = z__h27285 ^ fcCdc_grayCounter_rsCounter[15] ;
  assign z__h27299 = z__h27292 ^ fcCdc_grayCounter_rsCounter[16] ;
  always@(wci_wslv_reqF$D_OUT or rdat__h33002)
  begin
    case (wci_wslv_reqF$D_OUT[43:42])
      2'b0: rdat__h33126 = 32'd0;
      2'b01: rdat__h33126 = 32'hBEEFF00D;
      2'b10: rdat__h33126 = 32'hFEEDFACE;
      2'b11: rdat__h33126 = rdat__h33002;
    endcase
  end
  always@(_31_MINUS_spiCDC_dPos_31___d527 or spiCDC_reqS)
  begin
    case (_31_MINUS_spiCDC_dPos_31___d527)
      5'd4:
	  CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2 =
	      spiCDC_reqS[28];
      5'd5:
	  CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2 =
	      spiCDC_reqS[29];
      5'd6:
	  CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2 =
	      spiCDC_reqS[30];
      default: CASE_31_MINUS_spiCDC_dPos_31_27_31_MINUS_spiCD_ETC__q2 =
		   _31_MINUS_spiCDC_dPos_31___d527 == 5'd7 && spiCDC_reqS[31];
    endcase
  end
  always@(_31_MINUS_spiCDC_dPos_31___d527 or x__h13470 or spiCDC_reqS)
  begin
    case (_31_MINUS_spiCDC_dPos_31___d527)
      5'd0:
	  CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 =
	      spiCDC_reqS[28];
      5'd1:
	  CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 =
	      spiCDC_reqS[29];
      5'd2:
	  CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 =
	      spiCDC_reqS[30];
      5'd3:
	  CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 =
	      spiCDC_reqS[31];
      default: CASE_31_MINUS_spiCDC_dPos_31_27_x3470_0_spiCDC_ETC__q3 =
		   x__h13470;
    endcase
  end

  // handling of inlined registers

  always@(posedge wciS0_Clk)
  begin
    if (!wciS0_MReset_n)
      begin
        fcCdc_countNow <= `BSV_ASSIGNMENT_DELAY 18'd262143;
	fcCdc_countPast <= `BSV_ASSIGNMENT_DELAY 18'd262143;
	fcCdc_frequency <= `BSV_ASSIGNMENT_DELAY 18'd262143;
	fcCdc_pulseAction <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fcCdc_sampleCount <= `BSV_ASSIGNMENT_DELAY 16'd0;
	oneKHz_value <= `BSV_ASSIGNMENT_DELAY 18'd0;
	spiCDC_reqF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_respF_head_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	splitReadInFlight <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_cEdge <= `BSV_ASSIGNMENT_DELAY 3'h2;
	wci_wslv_cState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_wslv_ctlAckReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_ctlOpActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_illegalEdge <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_nState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_wslv_reqF_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_wslv_respF_c_r <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_wslv_respF_q_0 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_wslv_respF_q_1 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_wslv_sFlagReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (fcCdc_countNow$EN)
	  fcCdc_countNow <= `BSV_ASSIGNMENT_DELAY fcCdc_countNow$D_IN;
	if (fcCdc_countPast$EN)
	  fcCdc_countPast <= `BSV_ASSIGNMENT_DELAY fcCdc_countPast$D_IN;
	if (fcCdc_frequency$EN)
	  fcCdc_frequency <= `BSV_ASSIGNMENT_DELAY fcCdc_frequency$D_IN;
	if (fcCdc_pulseAction$EN)
	  fcCdc_pulseAction <= `BSV_ASSIGNMENT_DELAY fcCdc_pulseAction$D_IN;
	if (fcCdc_sampleCount$EN)
	  fcCdc_sampleCount <= `BSV_ASSIGNMENT_DELAY fcCdc_sampleCount$D_IN;
	if (oneKHz_value$EN)
	  oneKHz_value <= `BSV_ASSIGNMENT_DELAY oneKHz_value$D_IN;
	if (spiCDC_reqF_tail_wrapped$EN)
	  spiCDC_reqF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY
	      spiCDC_reqF_tail_wrapped$D_IN;
	if (spiCDC_respF_head_wrapped$EN)
	  spiCDC_respF_head_wrapped <= `BSV_ASSIGNMENT_DELAY
	      spiCDC_respF_head_wrapped$D_IN;
	if (splitReadInFlight$EN)
	  splitReadInFlight <= `BSV_ASSIGNMENT_DELAY splitReadInFlight$D_IN;
	if (wci_wslv_cEdge$EN)
	  wci_wslv_cEdge <= `BSV_ASSIGNMENT_DELAY wci_wslv_cEdge$D_IN;
	if (wci_wslv_cState$EN)
	  wci_wslv_cState <= `BSV_ASSIGNMENT_DELAY wci_wslv_cState$D_IN;
	if (wci_wslv_ctlAckReg$EN)
	  wci_wslv_ctlAckReg <= `BSV_ASSIGNMENT_DELAY wci_wslv_ctlAckReg$D_IN;
	if (wci_wslv_ctlOpActive$EN)
	  wci_wslv_ctlOpActive <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_ctlOpActive$D_IN;
	if (wci_wslv_illegalEdge$EN)
	  wci_wslv_illegalEdge <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_illegalEdge$D_IN;
	if (wci_wslv_nState$EN)
	  wci_wslv_nState <= `BSV_ASSIGNMENT_DELAY wci_wslv_nState$D_IN;
	if (wci_wslv_reqF_countReg$EN)
	  wci_wslv_reqF_countReg <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_reqF_countReg$D_IN;
	if (wci_wslv_respF_c_r$EN)
	  wci_wslv_respF_c_r <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_c_r$D_IN;
	if (wci_wslv_respF_q_0$EN)
	  wci_wslv_respF_q_0 <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_q_0$D_IN;
	if (wci_wslv_respF_q_1$EN)
	  wci_wslv_respF_q_1 <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_q_1$D_IN;
	if (wci_wslv_sFlagReg$EN)
	  wci_wslv_sFlagReg <= `BSV_ASSIGNMENT_DELAY wci_wslv_sFlagReg$D_IN;
	if (wci_wslv_sThreadBusy_d$EN)
	  wci_wslv_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_sThreadBusy_d$D_IN;
      end
    if (spiCDC_reqS$EN) spiCDC_reqS <= `BSV_ASSIGNMENT_DELAY spiCDC_reqS$D_IN;
  end

  always@(posedge spiCDC_cd$CLK_OUT)
  begin
    if (!spiCDC_slowReset$OUT_RST_N)
      begin
        spiCDC_cGate <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_capV <= `BSV_ASSIGNMENT_DELAY 28'd0;
	spiCDC_csbR <= `BSV_ASSIGNMENT_DELAY 1'd1;
	spiCDC_dPos <= `BSV_ASSIGNMENT_DELAY 5'd0;
	spiCDC_doResp <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_rPos <= `BSV_ASSIGNMENT_DELAY 6'd0;
	spiCDC_rcv_d <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_reqF_head_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_respF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiCDC_sdoR <= `BSV_ASSIGNMENT_DELAY 1'b0;
	spiCDC_xmt_d <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (spiCDC_cGate$EN)
	  spiCDC_cGate <= `BSV_ASSIGNMENT_DELAY spiCDC_cGate$D_IN;
	if (spiCDC_capV$EN)
	  spiCDC_capV <= `BSV_ASSIGNMENT_DELAY spiCDC_capV$D_IN;
	if (spiCDC_csbR$EN)
	  spiCDC_csbR <= `BSV_ASSIGNMENT_DELAY spiCDC_csbR$D_IN;
	if (spiCDC_dPos$EN)
	  spiCDC_dPos <= `BSV_ASSIGNMENT_DELAY spiCDC_dPos$D_IN;
	if (spiCDC_doResp$EN)
	  spiCDC_doResp <= `BSV_ASSIGNMENT_DELAY spiCDC_doResp$D_IN;
	if (spiCDC_rPos$EN)
	  spiCDC_rPos <= `BSV_ASSIGNMENT_DELAY spiCDC_rPos$D_IN;
	if (spiCDC_rcv_d$EN)
	  spiCDC_rcv_d <= `BSV_ASSIGNMENT_DELAY spiCDC_rcv_d$D_IN;
	if (spiCDC_reqF_head_wrapped$EN)
	  spiCDC_reqF_head_wrapped <= `BSV_ASSIGNMENT_DELAY
	      spiCDC_reqF_head_wrapped$D_IN;
	if (spiCDC_respF_tail_wrapped$EN)
	  spiCDC_respF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY
	      spiCDC_respF_tail_wrapped$D_IN;
	if (spiCDC_sdoR$EN)
	  spiCDC_sdoR <= `BSV_ASSIGNMENT_DELAY spiCDC_sdoR$D_IN;
	if (spiCDC_xmt_d$EN)
	  spiCDC_xmt_d <= `BSV_ASSIGNMENT_DELAY spiCDC_xmt_d$D_IN;
      end
    if (spiCDC_respS$EN)
      spiCDC_respS <= `BSV_ASSIGNMENT_DELAY spiCDC_respS$D_IN;
  end

  always@(posedge spiCDC_cinv$CLK_OUT)
  begin
    if (spiCDC_sdiP$EN) spiCDC_sdiP <= `BSV_ASSIGNMENT_DELAY spiCDC_sdiP$D_IN;
  end

  always@(posedge wciS0_Clk or negedge wciS0_MReset_n)
  if (!wciS0_MReset_n)
    begin
      fcCdc_grayCounter_rdCounter <= `BSV_ASSIGNMENT_DELAY 18'd0;
      fcCdc_grayCounter_rdCounterPre <= `BSV_ASSIGNMENT_DELAY 18'd0;
      wci_wslv_isReset_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
    end
  else
    begin
      if (fcCdc_grayCounter_rdCounter$EN)
	fcCdc_grayCounter_rdCounter <= `BSV_ASSIGNMENT_DELAY
	    fcCdc_grayCounter_rdCounter$D_IN;
      if (fcCdc_grayCounter_rdCounterPre$EN)
	fcCdc_grayCounter_rdCounterPre <= `BSV_ASSIGNMENT_DELAY
	    fcCdc_grayCounter_rdCounterPre$D_IN;
      if (wci_wslv_isReset_isInReset$EN)
	wci_wslv_isReset_isInReset <= `BSV_ASSIGNMENT_DELAY
	    wci_wslv_isReset_isInReset$D_IN;
    end

  always@(posedge CLK_flp_clk)
  begin
    if (fcCdc_grayCounter_rsCounter$EN)
      fcCdc_grayCounter_rsCounter <= `BSV_ASSIGNMENT_DELAY
	  fcCdc_grayCounter_rsCounter$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fcCdc_countNow = 18'h2AAAA;
    fcCdc_countPast = 18'h2AAAA;
    fcCdc_frequency = 18'h2AAAA;
    fcCdc_grayCounter_rdCounter = 18'h2AAAA;
    fcCdc_grayCounter_rdCounterPre = 18'h2AAAA;
    fcCdc_grayCounter_rsCounter = 18'h2AAAA;
    fcCdc_pulseAction = 1'h0;
    fcCdc_sampleCount = 16'hAAAA;
    oneKHz_value = 18'h2AAAA;
    spiCDC_cGate = 1'h0;
    spiCDC_capV = 28'hAAAAAAA;
    spiCDC_csbR = 1'h0;
    spiCDC_dPos = 5'h0A;
    spiCDC_doResp = 1'h0;
    spiCDC_rPos = 6'h2A;
    spiCDC_rcv_d = 1'h0;
    spiCDC_reqF_head_wrapped = 1'h0;
    spiCDC_reqF_tail_wrapped = 1'h0;
    spiCDC_reqS = 33'h0AAAAAAAA;
    spiCDC_respF_head_wrapped = 1'h0;
    spiCDC_respF_tail_wrapped = 1'h0;
    spiCDC_respS = 28'hAAAAAAA;
    spiCDC_sdiP = 1'h0;
    spiCDC_sdoR = 1'h0;
    spiCDC_xmt_d = 1'h0;
    splitReadInFlight = 1'h0;
    wci_wslv_cEdge = 3'h2;
    wci_wslv_cState = 3'h2;
    wci_wslv_ctlAckReg = 1'h0;
    wci_wslv_ctlOpActive = 1'h0;
    wci_wslv_illegalEdge = 1'h0;
    wci_wslv_isReset_isInReset = 1'h0;
    wci_wslv_nState = 3'h2;
    wci_wslv_reqF_countReg = 2'h2;
    wci_wslv_respF_c_r = 2'h2;
    wci_wslv_respF_q_0 = 34'h2AAAAAAAA;
    wci_wslv_respF_q_1 = 34'h2AAAAAAAA;
    wci_wslv_sFlagReg = 1'h0;
    wci_wslv_sThreadBusy_d = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge wciS0_Clk)
  begin
    #0;
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr)
	begin
	  v__h32653 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr)
	$display("[%0d]: %m: WCI CONFIG WRITE Addr:%0x BE:%0x Data:%0x",
		 v__h32653,
		 wci_wslv_reqF$D_OUT[63:32],
		 wci_wslv_reqF$D_OUT[67:64],
		 wci_wslv_reqF$D_OUT[31:0]);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd)
	begin
	  v__h33142 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd)
	$display("[%0d]: %m: WCI CONFIG READ Addr:%0x BE:%0x Data:%0x",
		 v__h33142,
		 wci_wslv_reqF$D_OUT[63:32],
		 wci_wslv_reqF$D_OUT[67:64],
		 rdat__h33126);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_start)
	begin
	  v__h3616 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_start)
	$display("[%0d]: %m: WCI ControlOp: Starting-transition edge:%x from:%x",
		 v__h3616,
		 wci_wslv_reqF$D_OUT[36:34],
		 wci_wslv_cState);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_spi_response)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_spi_response] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_EiI] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_cfrd)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and [RL_wci_cfrd] )\n  fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_spi_response && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 88: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_spi_response] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_spi_response && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 88: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_spi_response] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_spi_response && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 88: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_spi_response] and\n  [RL_wci_ctrl_EiI] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_spi_response)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_spi_response] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_EiI] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 46: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_EiI] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 46: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_EiI] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_ctrl_IsO && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/dev/FMC150.bsv\", line 59, column 60: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_IsO] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge)
	begin
	  v__h3934 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: ILLEGAL-EDGE Completed-transition edge:%x from:%x",
		 v__h3934,
		 wci_wslv_cEdge,
		 wci_wslv_cState);
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge)
	begin
	  v__h3790 = $time;
	  #0;
	end
    if (wciS0_MReset_n)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: Completed-transition edge:%x from:%x to:%x",
		 v__h3790,
		 wci_wslv_cEdge,
		 wci_wslv_cState,
		 wci_wslv_nState);
  end
  // synopsys translate_on
endmodule  // mkFMC150

