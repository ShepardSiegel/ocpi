//
// Generated by Bluespec Compiler, version 2010.10.beta1 (build 22431, 2010-10-28)
//
// On Wed Nov 10 07:46:52 EST 2010
//
//
// Ports:
// Name                         I/O  size props
// wciO0_Clk                      I     1 clock
// wciO0_MReset_n                 I     1 reset
// wciO0_MCmd                     I     3 reg
// wciO0_MAddrSpace               I     1 reg
// wciO0_MByteEn                  I     4 reg
// wciO0_MAddr                    I    20 reg
// wciO0_MData                    I    32 reg
// wciO0_SResp                    I     2 reg
// wciO0_SData                    I    32 reg
// wciO0_SFlag                    I     2 reg
// wciO0_MFlag                    I     2 reg
// wciO0_SThreadBusy              I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkWciOcpMonitor(wciO0_Clk,
		       wciO0_MReset_n,

		       wciO0_MCmd,

		       wciO0_MAddrSpace,

		       wciO0_MByteEn,

		       wciO0_MAddr,

		       wciO0_MData,

		       wciO0_SResp,

		       wciO0_SData,

		       wciO0_SThreadBusy,

		       wciO0_SFlag,

		       wciO0_MFlag);
  input  wciO0_Clk;
  input  wciO0_MReset_n;

  // action method wciO0_mCmd
  input  [2 : 0] wciO0_MCmd;

  // action method wciO0_mAddrSpace
  input  wciO0_MAddrSpace;

  // action method wciO0_mByteEn
  input  [3 : 0] wciO0_MByteEn;

  // action method wciO0_mAddr
  input  [19 : 0] wciO0_MAddr;

  // action method wciO0_mData
  input  [31 : 0] wciO0_MData;

  // action method wciO0_sResp
  input  [1 : 0] wciO0_SResp;

  // action method wciO0_sData
  input  [31 : 0] wciO0_SData;

  // action method wciO0_sThreadBusy
  input  wciO0_SThreadBusy;

  // action method wciO0_sFlag
  input  [1 : 0] wciO0_SFlag;

  // action method wciO0_mFlag
  input  [1 : 0] wciO0_MFlag;

  // inlined wires
  wire observer_r_sThreadBusy_1$wget, observer_r_sThreadBusy_1$whas;

  // register observer_r_mAddr
  reg [19 : 0] observer_r_mAddr;
  wire [19 : 0] observer_r_mAddr$D_IN;
  wire observer_r_mAddr$EN;

  // register observer_r_mAddrSpace
  reg observer_r_mAddrSpace;
  wire observer_r_mAddrSpace$D_IN, observer_r_mAddrSpace$EN;

  // register observer_r_mByteEn
  reg [3 : 0] observer_r_mByteEn;
  wire [3 : 0] observer_r_mByteEn$D_IN;
  wire observer_r_mByteEn$EN;

  // register observer_r_mCmd
  reg [2 : 0] observer_r_mCmd;
  wire [2 : 0] observer_r_mCmd$D_IN;
  wire observer_r_mCmd$EN;

  // register observer_r_mCmdD
  reg [2 : 0] observer_r_mCmdD;
  wire [2 : 0] observer_r_mCmdD$D_IN;
  wire observer_r_mCmdD$EN;

  // register observer_r_mData
  reg [31 : 0] observer_r_mData;
  wire [31 : 0] observer_r_mData$D_IN;
  wire observer_r_mData$EN;

  // register observer_r_mFlag
  reg [1 : 0] observer_r_mFlag;
  wire [1 : 0] observer_r_mFlag$D_IN;
  wire observer_r_mFlag$EN;

  // register observer_r_sData
  reg [31 : 0] observer_r_sData;
  wire [31 : 0] observer_r_sData$D_IN;
  wire observer_r_sData$EN;

  // register observer_r_sFlag
  reg [1 : 0] observer_r_sFlag;
  wire [1 : 0] observer_r_sFlag$D_IN;
  wire observer_r_sFlag$EN;

  // register observer_r_sResp
  reg [1 : 0] observer_r_sResp;
  wire [1 : 0] observer_r_sResp$D_IN;
  wire observer_r_sResp$EN;

  // register observer_r_sThreadBusy
  reg observer_r_sThreadBusy;
  wire observer_r_sThreadBusy$D_IN, observer_r_sThreadBusy$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_observer_cmd_start,
       CAN_FIRE_RL_observer_mCmd_state,
       CAN_FIRE_RL_observer_r_sThreadBusy__dreg_update,
       CAN_FIRE_wciO0_mAddr,
       CAN_FIRE_wciO0_mAddrSpace,
       CAN_FIRE_wciO0_mByteEn,
       CAN_FIRE_wciO0_mCmd,
       CAN_FIRE_wciO0_mData,
       CAN_FIRE_wciO0_mFlag,
       CAN_FIRE_wciO0_sData,
       CAN_FIRE_wciO0_sFlag,
       CAN_FIRE_wciO0_sResp,
       CAN_FIRE_wciO0_sThreadBusy,
       WILL_FIRE_RL_observer_cmd_start,
       WILL_FIRE_RL_observer_mCmd_state,
       WILL_FIRE_RL_observer_r_sThreadBusy__dreg_update,
       WILL_FIRE_wciO0_mAddr,
       WILL_FIRE_wciO0_mAddrSpace,
       WILL_FIRE_wciO0_mByteEn,
       WILL_FIRE_wciO0_mCmd,
       WILL_FIRE_wciO0_mData,
       WILL_FIRE_wciO0_mFlag,
       WILL_FIRE_wciO0_sData,
       WILL_FIRE_wciO0_sFlag,
       WILL_FIRE_wciO0_sResp,
       WILL_FIRE_wciO0_sThreadBusy;

  // remaining internal signals
  reg [63 : 0] v__h694;

  // action method wciO0_mCmd
  assign CAN_FIRE_wciO0_mCmd = 1'd1 ;
  assign WILL_FIRE_wciO0_mCmd = 1'd1 ;

  // action method wciO0_mAddrSpace
  assign CAN_FIRE_wciO0_mAddrSpace = 1'd1 ;
  assign WILL_FIRE_wciO0_mAddrSpace = 1'd1 ;

  // action method wciO0_mByteEn
  assign CAN_FIRE_wciO0_mByteEn = 1'd1 ;
  assign WILL_FIRE_wciO0_mByteEn = 1'd1 ;

  // action method wciO0_mAddr
  assign CAN_FIRE_wciO0_mAddr = 1'd1 ;
  assign WILL_FIRE_wciO0_mAddr = 1'd1 ;

  // action method wciO0_mData
  assign CAN_FIRE_wciO0_mData = 1'd1 ;
  assign WILL_FIRE_wciO0_mData = 1'd1 ;

  // action method wciO0_sResp
  assign CAN_FIRE_wciO0_sResp = 1'd1 ;
  assign WILL_FIRE_wciO0_sResp = 1'd1 ;

  // action method wciO0_sData
  assign CAN_FIRE_wciO0_sData = 1'd1 ;
  assign WILL_FIRE_wciO0_sData = 1'd1 ;

  // action method wciO0_sThreadBusy
  assign CAN_FIRE_wciO0_sThreadBusy = 1'd1 ;
  assign WILL_FIRE_wciO0_sThreadBusy = wciO0_SThreadBusy ;

  // action method wciO0_sFlag
  assign CAN_FIRE_wciO0_sFlag = 1'd1 ;
  assign WILL_FIRE_wciO0_sFlag = 1'd1 ;

  // action method wciO0_mFlag
  assign CAN_FIRE_wciO0_mFlag = 1'd1 ;
  assign WILL_FIRE_wciO0_mFlag = 1'd1 ;

  // rule RL_observer_cmd_start
  assign CAN_FIRE_RL_observer_cmd_start =
	     observer_r_mCmdD == 3'd0 && observer_r_mCmd != 3'd0 ;
  assign WILL_FIRE_RL_observer_cmd_start = CAN_FIRE_RL_observer_cmd_start ;

  // rule RL_observer_mCmd_state
  assign CAN_FIRE_RL_observer_mCmd_state = 1'd1 ;
  assign WILL_FIRE_RL_observer_mCmd_state = 1'd1 ;

  // rule RL_observer_r_sThreadBusy__dreg_update
  assign CAN_FIRE_RL_observer_r_sThreadBusy__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_observer_r_sThreadBusy__dreg_update = 1'd1 ;

  // inlined wires
  assign observer_r_sThreadBusy_1$wget = 1'b1 ;
  assign observer_r_sThreadBusy_1$whas = wciO0_SThreadBusy ;

  // register observer_r_mAddr
  assign observer_r_mAddr$D_IN = wciO0_MAddr ;
  assign observer_r_mAddr$EN = 1'd1 ;

  // register observer_r_mAddrSpace
  assign observer_r_mAddrSpace$D_IN = wciO0_MAddrSpace ;
  assign observer_r_mAddrSpace$EN = 1'd1 ;

  // register observer_r_mByteEn
  assign observer_r_mByteEn$D_IN = wciO0_MByteEn ;
  assign observer_r_mByteEn$EN = 1'd1 ;

  // register observer_r_mCmd
  assign observer_r_mCmd$D_IN = wciO0_MCmd ;
  assign observer_r_mCmd$EN = 1'd1 ;

  // register observer_r_mCmdD
  assign observer_r_mCmdD$D_IN = observer_r_mCmd ;
  assign observer_r_mCmdD$EN = 1'd1 ;

  // register observer_r_mData
  assign observer_r_mData$D_IN = wciO0_MData ;
  assign observer_r_mData$EN = 1'd1 ;

  // register observer_r_mFlag
  assign observer_r_mFlag$D_IN = wciO0_MFlag ;
  assign observer_r_mFlag$EN = 1'd1 ;

  // register observer_r_sData
  assign observer_r_sData$D_IN = wciO0_SData ;
  assign observer_r_sData$EN = 1'd1 ;

  // register observer_r_sFlag
  assign observer_r_sFlag$D_IN = wciO0_SFlag ;
  assign observer_r_sFlag$EN = 1'd1 ;

  // register observer_r_sResp
  assign observer_r_sResp$D_IN = wciO0_SResp ;
  assign observer_r_sResp$EN = 1'd1 ;

  // register observer_r_sThreadBusy
  assign observer_r_sThreadBusy$D_IN = wciO0_SThreadBusy ;
  assign observer_r_sThreadBusy$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge wciO0_Clk)
  begin
    if (!wciO0_MReset_n)
      begin
        observer_r_mAddr <= `BSV_ASSIGNMENT_DELAY 20'd0;
	observer_r_mAddrSpace <= `BSV_ASSIGNMENT_DELAY 1'd0;
	observer_r_mByteEn <= `BSV_ASSIGNMENT_DELAY 4'd0;
	observer_r_mCmd <= `BSV_ASSIGNMENT_DELAY 3'd0;
	observer_r_mCmdD <= `BSV_ASSIGNMENT_DELAY 3'd0;
	observer_r_mData <= `BSV_ASSIGNMENT_DELAY 32'd0;
	observer_r_mFlag <= `BSV_ASSIGNMENT_DELAY 2'd0;
	observer_r_sData <= `BSV_ASSIGNMENT_DELAY 32'd0;
	observer_r_sFlag <= `BSV_ASSIGNMENT_DELAY 2'd0;
	observer_r_sResp <= `BSV_ASSIGNMENT_DELAY 2'd0;
	observer_r_sThreadBusy <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (observer_r_mAddr$EN)
	  observer_r_mAddr <= `BSV_ASSIGNMENT_DELAY observer_r_mAddr$D_IN;
	if (observer_r_mAddrSpace$EN)
	  observer_r_mAddrSpace <= `BSV_ASSIGNMENT_DELAY
	      observer_r_mAddrSpace$D_IN;
	if (observer_r_mByteEn$EN)
	  observer_r_mByteEn <= `BSV_ASSIGNMENT_DELAY observer_r_mByteEn$D_IN;
	if (observer_r_mCmd$EN)
	  observer_r_mCmd <= `BSV_ASSIGNMENT_DELAY observer_r_mCmd$D_IN;
	if (observer_r_mCmdD$EN)
	  observer_r_mCmdD <= `BSV_ASSIGNMENT_DELAY observer_r_mCmdD$D_IN;
	if (observer_r_mData$EN)
	  observer_r_mData <= `BSV_ASSIGNMENT_DELAY observer_r_mData$D_IN;
	if (observer_r_mFlag$EN)
	  observer_r_mFlag <= `BSV_ASSIGNMENT_DELAY observer_r_mFlag$D_IN;
	if (observer_r_sData$EN)
	  observer_r_sData <= `BSV_ASSIGNMENT_DELAY observer_r_sData$D_IN;
	if (observer_r_sFlag$EN)
	  observer_r_sFlag <= `BSV_ASSIGNMENT_DELAY observer_r_sFlag$D_IN;
	if (observer_r_sResp$EN)
	  observer_r_sResp <= `BSV_ASSIGNMENT_DELAY observer_r_sResp$D_IN;
	if (observer_r_sThreadBusy$EN)
	  observer_r_sThreadBusy <= `BSV_ASSIGNMENT_DELAY
	      observer_r_sThreadBusy$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    observer_r_mAddr = 20'hAAAAA;
    observer_r_mAddrSpace = 1'h0;
    observer_r_mByteEn = 4'hA;
    observer_r_mCmd = 3'h2;
    observer_r_mCmdD = 3'h2;
    observer_r_mData = 32'hAAAAAAAA;
    observer_r_mFlag = 2'h2;
    observer_r_sData = 32'hAAAAAAAA;
    observer_r_sFlag = 2'h2;
    observer_r_sResp = 2'h2;
    observer_r_sThreadBusy = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge wciO0_Clk)
  begin
    #0;
    if (wciO0_MReset_n)
      if (WILL_FIRE_RL_observer_cmd_start)
	begin
	  v__h694 = $time;
	  #0;
	end
    if (wciO0_MReset_n)
      if (WILL_FIRE_RL_observer_cmd_start)
	$display("[%0d]: %m: WCI mcmd %0x", v__h694, observer_r_mCmd);
  end
  // synopsys translate_on
endmodule  // mkWciOcpMonitor

