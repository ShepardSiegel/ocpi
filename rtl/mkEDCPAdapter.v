//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Tue Sep  4 12:28:43 EDT 2012
//
//
// Ports:
// Name                         I/O  size props
// RDY_server_request_put         O     1 reg
// server_response_get            O    40
// RDY_server_response_get        O     1 reg
// client_request_get             O    59 reg
// RDY_client_request_get         O     1 reg
// RDY_client_response_put        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// server_request_put             I    40
// client_response_put            I    40 reg
// EN_server_request_put          I     1
// EN_client_response_put         I     1
// EN_server_response_get         I     1
// EN_client_request_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkEDCPAdapter(CLK,
		     RST_N,

		     server_request_put,
		     EN_server_request_put,
		     RDY_server_request_put,

		     EN_server_response_get,
		     server_response_get,
		     RDY_server_response_get,

		     EN_client_request_get,
		     client_request_get,
		     RDY_client_request_get,

		     client_response_put,
		     EN_client_response_put,
		     RDY_client_response_put);
  input  CLK;
  input  RST_N;

  // action method server_request_put
  input  [39 : 0] server_request_put;
  input  EN_server_request_put;
  output RDY_server_request_put;

  // actionvalue method server_response_get
  input  EN_server_response_get;
  output [39 : 0] server_response_get;
  output RDY_server_response_get;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [58 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [39 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // signals for module outputs
  wire [58 : 0] client_request_get;
  wire [39 : 0] server_response_get;
  wire RDY_client_request_get,
       RDY_client_response_put,
       RDY_server_request_put,
       RDY_server_response_get;

  // inlined wires
  wire eDoReq_1$wget, eDoReq_1$whas;

  // register doInFlight
  reg doInFlight;
  wire doInFlight$D_IN, doInFlight$EN;

  // register eAddr
  reg [31 : 0] eAddr;
  wire [31 : 0] eAddr$D_IN;
  wire eAddr$EN;

  // register eDMH
  reg [31 : 0] eDMH;
  wire [31 : 0] eDMH$D_IN;
  wire eDMH$EN;

  // register eData
  reg [31 : 0] eData;
  wire [31 : 0] eData$D_IN;
  wire eData$EN;

  // register eDoReq
  reg eDoReq;
  wire eDoReq$D_IN, eDoReq$EN;

  // register eMAddr
  reg [47 : 0] eMAddr;
  wire [47 : 0] eMAddr$D_IN;
  wire eMAddr$EN;

  // register ePli
  reg [15 : 0] ePli;
  wire [15 : 0] ePli$D_IN;
  wire ePli$EN;

  // register eTyp
  reg [15 : 0] eTyp;
  wire [15 : 0] eTyp$D_IN;
  wire eTyp$EN;

  // register lastResp
  reg [44 : 0] lastResp;
  wire [44 : 0] lastResp$D_IN;
  wire lastResp$EN;

  // register lastTag
  reg [8 : 0] lastTag;
  wire [8 : 0] lastTag$D_IN;
  wire lastTag$EN;

  // register ptr
  reg [3 : 0] ptr;
  wire [3 : 0] ptr$D_IN;
  wire ptr$EN;

  // ports of submodule cpReqF
  wire [58 : 0] cpReqF$D_IN, cpReqF$D_OUT;
  wire cpReqF$CLR, cpReqF$DEQ, cpReqF$EMPTY_N, cpReqF$ENQ, cpReqF$FULL_N;

  // ports of submodule cpRespF
  wire [39 : 0] cpRespF$D_IN, cpRespF$D_OUT;
  wire cpRespF$CLR, cpRespF$DEQ, cpRespF$EMPTY_N, cpRespF$ENQ, cpRespF$FULL_N;

  // ports of submodule dcpReqF
  reg [78 : 0] dcpReqF$D_IN;
  wire [78 : 0] dcpReqF$D_OUT;
  wire dcpReqF$CLR, dcpReqF$DEQ, dcpReqF$EMPTY_N, dcpReqF$ENQ, dcpReqF$FULL_N;

  // ports of submodule dcpRespF
  wire [44 : 0] dcpRespF$D_IN;
  wire dcpRespF$CLR, dcpRespF$DEQ, dcpRespF$ENQ, dcpRespF$FULL_N;

  // ports of submodule eMAddrF
  wire [47 : 0] eMAddrF$D_IN;
  wire eMAddrF$CLR, eMAddrF$DEQ, eMAddrF$ENQ, eMAddrF$FULL_N;

  // ports of submodule ecpReqF
  wire [39 : 0] ecpReqF$D_IN, ecpReqF$D_OUT;
  wire ecpReqF$CLR, ecpReqF$DEQ, ecpReqF$EMPTY_N, ecpReqF$ENQ, ecpReqF$FULL_N;

  // ports of submodule ecpRespF
  wire [39 : 0] ecpRespF$D_IN, ecpRespF$D_OUT;
  wire ecpRespF$CLR, ecpRespF$DEQ, ecpRespF$EMPTY_N, ecpRespF$ENQ;

  // rule scheduling signals
  wire WILL_FIRE_RL_cp_response,
       WILL_FIRE_RL_dcp_request,
       WILL_FIRE_RL_ecp_ingress;

  // inputs to muxes for submodule ports
  reg [44 : 0] MUX_dcpRespF$enq_1__VAL_1;
  wire [44 : 0] MUX_dcpRespF$enq_1__VAL_2;
  wire MUX_dcpRespF$enq_1__SEL_1, MUX_doInFlight$write_1__SEL_1;

  // remaining internal signals
  reg [1 : 0] CASE_ecpRespFD_OUT_BITS_19_TO_18_3_0_ecpRespF_ETC__q3,
	      CASE_ecpRespFD_OUT_BITS_29_TO_28_3_0_ecpRespF_ETC__q2,
	      CASE_ecpRespFD_OUT_BITS_39_TO_38_3_0_ecpRespF_ETC__q1,
	      CASE_ecpRespFD_OUT_BITS_9_TO_8_3_0_ecpRespFD_ETC__q4,
	      CASE_server_request_put_BITS_19_TO_18_3_0_serv_ETC__q8,
	      CASE_server_request_put_BITS_29_TO_28_3_0_serv_ETC__q7,
	      CASE_server_request_put_BITS_39_TO_38_3_0_serv_ETC__q6,
	      CASE_server_request_put_BITS_9_TO_8_3_0_server_ETC__q9;
  reg CASE_eDMH_BITS_21_TO_20_NOT_eDMH_BITS_21_TO_20_ETC__q5;
  wire [47 : 0] x__h2980, x__h3877;
  wire [31 : 0] dw__h1488;
  wire [15 : 0] x__h3909, x__h3951;
  wire [3 : 0] x__h1513;
  wire IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02__ETC___d133,
       IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04__ETC___d131,
       dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352,
       dcpReqF_first__00_BITS_71_TO_64_18_EQ_IF_lastT_ETC___d353,
       dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02_OR__ETC___d136,
       dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04_AND_ETC___d177,
       eMAddrF_i_notFull__0_AND_IF_eDMH_1_BITS_21_TO__ETC___d81;

  // action method server_request_put
  assign RDY_server_request_put = ecpReqF$FULL_N ;

  // actionvalue method server_response_get
  assign server_response_get =
	     { CASE_ecpRespFD_OUT_BITS_39_TO_38_3_0_ecpRespF_ETC__q1,
	       ecpRespF$D_OUT[37:30],
	       CASE_ecpRespFD_OUT_BITS_29_TO_28_3_0_ecpRespF_ETC__q2,
	       ecpRespF$D_OUT[27:20],
	       CASE_ecpRespFD_OUT_BITS_19_TO_18_3_0_ecpRespF_ETC__q3,
	       ecpRespF$D_OUT[17:10],
	       CASE_ecpRespFD_OUT_BITS_9_TO_8_3_0_ecpRespFD_ETC__q4,
	       ecpRespF$D_OUT[7:0] } ;
  assign RDY_server_response_get = ecpRespF$EMPTY_N ;

  // actionvalue method client_request_get
  assign client_request_get = cpReqF$D_OUT ;
  assign RDY_client_request_get = cpReqF$EMPTY_N ;

  // action method client_response_put
  assign RDY_client_response_put = cpRespF$FULL_N ;

  // submodule cpReqF
  FIFO2 #(.width(32'd59), .guarded(32'd1)) cpReqF(.RST_N(RST_N),
						  .CLK(CLK),
						  .D_IN(cpReqF$D_IN),
						  .ENQ(cpReqF$ENQ),
						  .DEQ(cpReqF$DEQ),
						  .CLR(cpReqF$CLR),
						  .D_OUT(cpReqF$D_OUT),
						  .FULL_N(cpReqF$FULL_N),
						  .EMPTY_N(cpReqF$EMPTY_N));

  // submodule cpRespF
  FIFO2 #(.width(32'd40), .guarded(32'd1)) cpRespF(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(cpRespF$D_IN),
						   .ENQ(cpRespF$ENQ),
						   .DEQ(cpRespF$DEQ),
						   .CLR(cpRespF$CLR),
						   .D_OUT(cpRespF$D_OUT),
						   .FULL_N(cpRespF$FULL_N),
						   .EMPTY_N(cpRespF$EMPTY_N));

  // submodule dcpReqF
  FIFO2 #(.width(32'd79), .guarded(32'd1)) dcpReqF(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(dcpReqF$D_IN),
						   .ENQ(dcpReqF$ENQ),
						   .DEQ(dcpReqF$DEQ),
						   .CLR(dcpReqF$CLR),
						   .D_OUT(dcpReqF$D_OUT),
						   .FULL_N(dcpReqF$FULL_N),
						   .EMPTY_N(dcpReqF$EMPTY_N));

  // submodule dcpRespF
  FIFO2 #(.width(32'd45), .guarded(32'd1)) dcpRespF(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(dcpRespF$D_IN),
						    .ENQ(dcpRespF$ENQ),
						    .DEQ(dcpRespF$DEQ),
						    .CLR(dcpRespF$CLR),
						    .D_OUT(),
						    .FULL_N(dcpRespF$FULL_N),
						    .EMPTY_N());

  // submodule eMAddrF
  FIFO1 #(.width(32'd48), .guarded(32'd1)) eMAddrF(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(eMAddrF$D_IN),
						   .ENQ(eMAddrF$ENQ),
						   .DEQ(eMAddrF$DEQ),
						   .CLR(eMAddrF$CLR),
						   .D_OUT(),
						   .FULL_N(eMAddrF$FULL_N),
						   .EMPTY_N());

  // submodule ecpReqF
  FIFO2 #(.width(32'd40), .guarded(32'd1)) ecpReqF(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(ecpReqF$D_IN),
						   .ENQ(ecpReqF$ENQ),
						   .DEQ(ecpReqF$DEQ),
						   .CLR(ecpReqF$CLR),
						   .D_OUT(ecpReqF$D_OUT),
						   .FULL_N(ecpReqF$FULL_N),
						   .EMPTY_N(ecpReqF$EMPTY_N));

  // submodule ecpRespF
  FIFO2 #(.width(32'd40), .guarded(32'd1)) ecpRespF(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(ecpRespF$D_IN),
						    .ENQ(ecpRespF$ENQ),
						    .DEQ(ecpRespF$DEQ),
						    .CLR(ecpRespF$CLR),
						    .D_OUT(ecpRespF$D_OUT),
						    .FULL_N(),
						    .EMPTY_N(ecpRespF$EMPTY_N));

  // rule RL_ecp_ingress
  assign WILL_FIRE_RL_ecp_ingress = ecpReqF$EMPTY_N && !eDoReq ;

  // rule RL_dcp_request
  assign WILL_FIRE_RL_dcp_request =
	     dcpReqF$EMPTY_N &&
	     IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02__ETC___d133 ;

  // rule RL_cp_response
  assign WILL_FIRE_RL_cp_response =
	     dcpRespF$FULL_N && cpRespF$EMPTY_N && !WILL_FIRE_RL_dcp_request ;

  // inputs to muxes for submodule ports
  assign MUX_dcpRespF$enq_1__SEL_1 =
	     WILL_FIRE_RL_dcp_request &&
	     dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02_OR__ETC___d136 ;
  assign MUX_doInFlight$write_1__SEL_1 =
	     WILL_FIRE_RL_dcp_request &&
	     (dcpReqF$D_OUT[78:77] == 2'd0 && dcpReqF$D_OUT[40] ||
	      dcpReqF$D_OUT[78:77] != 2'd0 &&
	      (dcpReqF$D_OUT[78:77] == 2'd1 && dcpReqF$D_OUT[76] ||
	       dcpReqF$D_OUT[78:77] != 2'd1 && dcpReqF$D_OUT[44])) ;
  always@(dcpReqF$D_OUT or lastResp)
  begin
    case (dcpReqF$D_OUT[78:77])
      2'd0:
	  MUX_dcpRespF$enq_1__VAL_1 =
	      { 2'd0,
		dcpReqF$D_OUT[40],
		32'h40000001,
		dcpReqF$D_OUT[39:32],
		2'd0 };
      2'd1:
	  MUX_dcpRespF$enq_1__VAL_1 =
	      { dcpReqF$D_OUT[78:77],
		32'hAAAAAAAA,
		dcpReqF$D_OUT[76],
		dcpReqF$D_OUT[71:64],
		2'd0 };
      default: MUX_dcpRespF$enq_1__VAL_1 =
		   { (lastResp[44:43] == 2'd0 || lastResp[44:43] == 2'd1) ?
		       lastResp[44:43] :
		       2'd2,
		     lastResp[42:0] };
    endcase
  end
  assign MUX_dcpRespF$enq_1__VAL_2 =
	     { 2'd2,
	       doInFlight,
	       cpRespF$D_OUT[31:0],
	       cpRespF$D_OUT[39:32],
	       2'd0 } ;

  // inlined wires
  assign eDoReq_1$wget =
	     eTyp == 16'hF040 && x__h1513 != 4'd0 &&
	     (ePli == 16'd10 && ptr == 4'd5 ||
	      ePli == 16'd14 && ptr == 4'd6) ;
  assign eDoReq_1$whas = WILL_FIRE_RL_ecp_ingress ;

  // register doInFlight
  assign doInFlight$D_IN = MUX_doInFlight$write_1__SEL_1 ;
  assign doInFlight$EN =
	     WILL_FIRE_RL_dcp_request &&
	     (dcpReqF$D_OUT[78:77] == 2'd0 && dcpReqF$D_OUT[40] ||
	      dcpReqF$D_OUT[78:77] != 2'd0 &&
	      (dcpReqF$D_OUT[78:77] == 2'd1 && dcpReqF$D_OUT[76] ||
	       dcpReqF$D_OUT[78:77] != 2'd1 && dcpReqF$D_OUT[44])) ||
	     WILL_FIRE_RL_cp_response ;

  // register eAddr
  assign eAddr$D_IN = dw__h1488 ;
  assign eAddr$EN = WILL_FIRE_RL_ecp_ingress && ptr == 4'd5 ;

  // register eDMH
  assign eDMH$D_IN = dw__h1488 ;
  assign eDMH$EN = WILL_FIRE_RL_ecp_ingress && ptr == 4'd4 ;

  // register eData
  assign eData$D_IN = dw__h1488 ;
  assign eData$EN = WILL_FIRE_RL_ecp_ingress && ptr == 4'd6 ;

  // register eDoReq
  assign eDoReq$D_IN = WILL_FIRE_RL_ecp_ingress && eDoReq_1$wget ;
  assign eDoReq$EN = 1'd1 ;

  // register eMAddr
  assign eMAddr$D_IN = (ptr == 4'd1) ? x__h2980 : x__h3877 ;
  assign eMAddr$EN =
	     WILL_FIRE_RL_ecp_ingress && (ptr == 4'd1 || ptr == 4'd2) ;

  // register ePli
  assign ePli$D_IN = x__h3951 ;
  assign ePli$EN = WILL_FIRE_RL_ecp_ingress && ptr == 4'd3 ;

  // register eTyp
  assign eTyp$D_IN = x__h3909 ;
  assign eTyp$EN = WILL_FIRE_RL_ecp_ingress && ptr == 4'd3 ;

  // register lastResp
  assign lastResp$D_IN = MUX_dcpRespF$enq_1__VAL_2 ;
  assign lastResp$EN = WILL_FIRE_RL_cp_response && !doInFlight ;

  // register lastTag
  assign lastTag$D_IN =
	     { dcpReqF$D_OUT[78:77] != 2'd0,
	       (dcpReqF$D_OUT[78:77] == 2'd1) ?
		 dcpReqF$D_OUT[71:64] :
		 dcpReqF$D_OUT[39:32] } ;
  assign lastTag$EN =
	     WILL_FIRE_RL_dcp_request &&
	     (dcpReqF$D_OUT[78:77] == 2'd0 && !dcpReqF$D_OUT[40] ||
	      dcpReqF$D_OUT[78:77] != 2'd0 &&
	      (dcpReqF$D_OUT[78:77] == 2'd1 &&
	       (!dcpReqF_first__00_BITS_71_TO_64_18_EQ_IF_lastT_ETC___d353 ||
		!lastTag[8]) &&
	       !dcpReqF$D_OUT[76] ||
	       dcpReqF$D_OUT[78:77] != 2'd1 &&
	       (!dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 ||
		!lastTag[8]) &&
	       !dcpReqF$D_OUT[44])) ;

  // register ptr
  assign ptr$D_IN =
	     (x__h1513 == 4'd0) ? ((ptr == 4'd6) ? ptr : ptr + 4'd1) : 4'd0 ;
  assign ptr$EN = WILL_FIRE_RL_ecp_ingress ;

  // submodule cpReqF
  assign cpReqF$D_IN =
	     { dcpReqF$D_OUT[78:77] != 2'd1,
	       (dcpReqF$D_OUT[78:77] == 2'd1) ?
		 { dcpReqF$D_OUT[23:2],
		   dcpReqF$D_OUT[75:72],
		   dcpReqF$D_OUT[63:32] } :
		 { 24'hAAAAAA,
		   dcpReqF$D_OUT[39:32],
		   dcpReqF$D_OUT[23:2],
		   dcpReqF$D_OUT[43:40] } } ;
  assign cpReqF$ENQ =
	     WILL_FIRE_RL_dcp_request && dcpReqF$D_OUT[78:77] != 2'd0 &&
	     dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04_AND_ETC___d177 ;
  assign cpReqF$DEQ = EN_client_request_get ;
  assign cpReqF$CLR = 1'b0 ;

  // submodule cpRespF
  assign cpRespF$D_IN = client_response_put ;
  assign cpRespF$ENQ = EN_client_response_put ;
  assign cpRespF$DEQ = WILL_FIRE_RL_cp_response ;
  assign cpRespF$CLR = 1'b0 ;

  // submodule dcpReqF
  always@(eDMH or eAddr or eData)
  begin
    case (eDMH[21:20])
      2'd0: dcpReqF$D_IN = { 38'h0AAAAAAAAA, eDMH[22], eDMH[31:24], eAddr };
      2'd1:
	  dcpReqF$D_IN =
	      { eDMH[21:20],
		eDMH[22],
		eDMH[19:16],
		eDMH[31:24],
		eData,
		eAddr };
      default: dcpReqF$D_IN =
		   { 34'h2AAAAAAAA,
		     eDMH[22],
		     eDMH[19:16],
		     eDMH[31:24],
		     eAddr };
    endcase
  end
  assign dcpReqF$ENQ =
	     eMAddrF_i_notFull__0_AND_IF_eDMH_1_BITS_21_TO__ETC___d81 &&
	     eDoReq &&
	     (eDMH[21:20] == 2'd0 || eDMH[21:20] == 2'd1 ||
	      eDMH[21:20] == 2'd2) ;
  assign dcpReqF$DEQ = WILL_FIRE_RL_dcp_request ;
  assign dcpReqF$CLR = 1'b0 ;

  // submodule dcpRespF
  assign dcpRespF$D_IN =
	     MUX_dcpRespF$enq_1__SEL_1 ?
	       MUX_dcpRespF$enq_1__VAL_1 :
	       MUX_dcpRespF$enq_1__VAL_2 ;
  assign dcpRespF$ENQ =
	     WILL_FIRE_RL_dcp_request &&
	     dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02_OR__ETC___d136 ||
	     WILL_FIRE_RL_cp_response ;
  assign dcpRespF$DEQ = 1'b0 ;
  assign dcpRespF$CLR = 1'b0 ;

  // submodule eMAddrF
  assign eMAddrF$D_IN = eMAddr ;
  assign eMAddrF$ENQ =
	     eMAddrF_i_notFull__0_AND_IF_eDMH_1_BITS_21_TO__ETC___d81 &&
	     eDoReq ;
  assign eMAddrF$DEQ = 1'b0 ;
  assign eMAddrF$CLR = 1'b0 ;

  // submodule ecpReqF
  assign ecpReqF$D_IN =
	     { CASE_server_request_put_BITS_39_TO_38_3_0_serv_ETC__q6,
	       server_request_put[37:30],
	       CASE_server_request_put_BITS_29_TO_28_3_0_serv_ETC__q7,
	       server_request_put[27:20],
	       CASE_server_request_put_BITS_19_TO_18_3_0_serv_ETC__q8,
	       server_request_put[17:10],
	       CASE_server_request_put_BITS_9_TO_8_3_0_server_ETC__q9,
	       server_request_put[7:0] } ;
  assign ecpReqF$ENQ = EN_server_request_put ;
  assign ecpReqF$DEQ = WILL_FIRE_RL_ecp_ingress ;
  assign ecpReqF$CLR = 1'b0 ;

  // submodule ecpRespF
  assign ecpRespF$D_IN = 40'h0 ;
  assign ecpRespF$ENQ = 1'b0 ;
  assign ecpRespF$DEQ = EN_server_response_get ;
  assign ecpRespF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02__ETC___d133 =
	     (dcpReqF$D_OUT[78:77] == 2'd0) ?
	       dcpRespF$FULL_N :
	       (dcpReqF$D_OUT[78:77] == 2'd1 ||
		!dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 ||
		!lastTag[8] ||
		dcpReqF$D_OUT[44] ||
		dcpRespF$FULL_N) &&
	       IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04__ETC___d131 ;
  assign IF_dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04__ETC___d131 =
	     (dcpReqF$D_OUT[78:77] == 2'd1) ?
	       dcpRespF$FULL_N &&
	       (dcpReqF_first__00_BITS_71_TO_64_18_EQ_IF_lastT_ETC___d353 &&
		lastTag[8] &&
		!dcpReqF$D_OUT[76] ||
		cpReqF$FULL_N) :
	       dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 &&
	       lastTag[8] &&
	       !dcpReqF$D_OUT[44] ||
	       cpReqF$FULL_N ;
  assign dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 =
	     dcpReqF$D_OUT[39:32] == lastTag[7:0] ;
  assign dcpReqF_first__00_BITS_71_TO_64_18_EQ_IF_lastT_ETC___d353 =
	     dcpReqF$D_OUT[71:64] == lastTag[7:0] ;
  assign dcpReqF_first__00_BITS_78_TO_77_01_EQ_0_02_OR__ETC___d136 =
	     dcpReqF$D_OUT[78:77] == 2'd0 || dcpReqF$D_OUT[78:77] == 2'd1 ||
	     dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 &&
	     lastTag[8] &&
	     !dcpReqF$D_OUT[44] ;
  assign dcpReqF_first__00_BITS_78_TO_77_01_EQ_1_04_AND_ETC___d177 =
	     dcpReqF$D_OUT[78:77] == 2'd1 &&
	     (!dcpReqF_first__00_BITS_71_TO_64_18_EQ_IF_lastT_ETC___d353 ||
	      !lastTag[8] ||
	      dcpReqF$D_OUT[76]) ||
	     dcpReqF$D_OUT[78:77] != 2'd1 &&
	     (!dcpReqF_first__00_BITS_39_TO_32_05_EQ_IF_lastT_ETC___d352 ||
	      !lastTag[8] ||
	      dcpReqF$D_OUT[44]) ;
  assign dw__h1488 = { x__h3951, ecpReqF$D_OUT[17:10], ecpReqF$D_OUT[7:0] } ;
  assign eMAddrF_i_notFull__0_AND_IF_eDMH_1_BITS_21_TO__ETC___d81 =
	     eMAddrF$FULL_N &&
	     CASE_eDMH_BITS_21_TO_20_NOT_eDMH_BITS_21_TO_20_ETC__q5 ;
  assign x__h1513 =
	     { ecpReqF$D_OUT[39:38] != 2'd0,
	       ecpReqF$D_OUT[29:28] != 2'd0,
	       ecpReqF$D_OUT[19:18] != 2'd0,
	       ecpReqF$D_OUT[9:8] != 2'd0 } ;
  assign x__h2980 = { x__h3909, 32'h0 } ;
  assign x__h3877 = eMAddr | { 16'd0, dw__h1488 } ;
  assign x__h3909 = { ecpReqF$D_OUT[17:10], ecpReqF$D_OUT[7:0] } ;
  assign x__h3951 = { ecpReqF$D_OUT[37:30], ecpReqF$D_OUT[27:20] } ;
  always@(ecpRespF$D_OUT)
  begin
    case (ecpRespF$D_OUT[39:38])
      2'd0, 2'd1, 2'd2:
	  CASE_ecpRespFD_OUT_BITS_39_TO_38_3_0_ecpRespF_ETC__q1 =
	      ecpRespF$D_OUT[39:38];
      2'd3: CASE_ecpRespFD_OUT_BITS_39_TO_38_3_0_ecpRespF_ETC__q1 = 2'd3;
    endcase
  end
  always@(ecpRespF$D_OUT)
  begin
    case (ecpRespF$D_OUT[29:28])
      2'd0, 2'd1, 2'd2:
	  CASE_ecpRespFD_OUT_BITS_29_TO_28_3_0_ecpRespF_ETC__q2 =
	      ecpRespF$D_OUT[29:28];
      2'd3: CASE_ecpRespFD_OUT_BITS_29_TO_28_3_0_ecpRespF_ETC__q2 = 2'd3;
    endcase
  end
  always@(ecpRespF$D_OUT)
  begin
    case (ecpRespF$D_OUT[19:18])
      2'd0, 2'd1, 2'd2:
	  CASE_ecpRespFD_OUT_BITS_19_TO_18_3_0_ecpRespF_ETC__q3 =
	      ecpRespF$D_OUT[19:18];
      2'd3: CASE_ecpRespFD_OUT_BITS_19_TO_18_3_0_ecpRespF_ETC__q3 = 2'd3;
    endcase
  end
  always@(ecpRespF$D_OUT)
  begin
    case (ecpRespF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_ecpRespFD_OUT_BITS_9_TO_8_3_0_ecpRespFD_ETC__q4 =
	      ecpRespF$D_OUT[9:8];
      2'd3: CASE_ecpRespFD_OUT_BITS_9_TO_8_3_0_ecpRespFD_ETC__q4 = 2'd3;
    endcase
  end
  always@(eDMH or dcpReqF$FULL_N)
  begin
    case (eDMH[21:20])
      2'd0, 2'd1:
	  CASE_eDMH_BITS_21_TO_20_NOT_eDMH_BITS_21_TO_20_ETC__q5 =
	      dcpReqF$FULL_N;
      default: CASE_eDMH_BITS_21_TO_20_NOT_eDMH_BITS_21_TO_20_ETC__q5 =
		   eDMH[21:20] != 2'd2 || dcpReqF$FULL_N;
    endcase
  end
  always@(server_request_put)
  begin
    case (server_request_put[39:38])
      2'd0, 2'd1, 2'd2:
	  CASE_server_request_put_BITS_39_TO_38_3_0_serv_ETC__q6 =
	      server_request_put[39:38];
      2'd3: CASE_server_request_put_BITS_39_TO_38_3_0_serv_ETC__q6 = 2'd3;
    endcase
  end
  always@(server_request_put)
  begin
    case (server_request_put[29:28])
      2'd0, 2'd1, 2'd2:
	  CASE_server_request_put_BITS_29_TO_28_3_0_serv_ETC__q7 =
	      server_request_put[29:28];
      2'd3: CASE_server_request_put_BITS_29_TO_28_3_0_serv_ETC__q7 = 2'd3;
    endcase
  end
  always@(server_request_put)
  begin
    case (server_request_put[19:18])
      2'd0, 2'd1, 2'd2:
	  CASE_server_request_put_BITS_19_TO_18_3_0_serv_ETC__q8 =
	      server_request_put[19:18];
      2'd3: CASE_server_request_put_BITS_19_TO_18_3_0_serv_ETC__q8 = 2'd3;
    endcase
  end
  always@(server_request_put)
  begin
    case (server_request_put[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_server_request_put_BITS_9_TO_8_3_0_server_ETC__q9 =
	      server_request_put[9:8];
      2'd3: CASE_server_request_put_BITS_9_TO_8_3_0_server_ETC__q9 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        doInFlight <= `BSV_ASSIGNMENT_DELAY 1'd0;
	eDoReq <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lastTag <= `BSV_ASSIGNMENT_DELAY 9'd170;
	ptr <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (doInFlight$EN)
	  doInFlight <= `BSV_ASSIGNMENT_DELAY doInFlight$D_IN;
	if (eDoReq$EN) eDoReq <= `BSV_ASSIGNMENT_DELAY eDoReq$D_IN;
	if (lastTag$EN) lastTag <= `BSV_ASSIGNMENT_DELAY lastTag$D_IN;
	if (ptr$EN) ptr <= `BSV_ASSIGNMENT_DELAY ptr$D_IN;
      end
    if (eAddr$EN) eAddr <= `BSV_ASSIGNMENT_DELAY eAddr$D_IN;
    if (eDMH$EN) eDMH <= `BSV_ASSIGNMENT_DELAY eDMH$D_IN;
    if (eData$EN) eData <= `BSV_ASSIGNMENT_DELAY eData$D_IN;
    if (eMAddr$EN) eMAddr <= `BSV_ASSIGNMENT_DELAY eMAddr$D_IN;
    if (ePli$EN) ePli <= `BSV_ASSIGNMENT_DELAY ePli$D_IN;
    if (eTyp$EN) eTyp <= `BSV_ASSIGNMENT_DELAY eTyp$D_IN;
    if (lastResp$EN) lastResp <= `BSV_ASSIGNMENT_DELAY lastResp$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    doInFlight = 1'h0;
    eAddr = 32'hAAAAAAAA;
    eDMH = 32'hAAAAAAAA;
    eData = 32'hAAAAAAAA;
    eDoReq = 1'h0;
    eMAddr = 48'hAAAAAAAAAAAA;
    ePli = 16'hAAAA;
    eTyp = 16'hAAAA;
    lastResp = 45'h0AAAAAAAAAAA;
    lastTag = 9'h0AA;
    ptr = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkEDCPAdapter

