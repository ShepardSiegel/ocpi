//
// Generated by Bluespec Compiler, version 2010.10.beta1 (build 22431, 2010-10-28)
//
// On Mon Nov  8 12:20:40 EST 2010
//
//
// Ports:
// Name                         I/O  size props
// wciM0_MCmd                     O     3
// wciM0_MAddrSpace               O     1
// wciM0_MByteEn                  O     4
// wciM0_MAddr                    O    20
// wciM0_MData                    O    32 reg
// wciM0_MFlag                    O     2 reg
// bar_wciM0_foo                  O     1 reset
// CLK                            I     1 clock
// bar                            I     1 reset
// wciM0_SResp                    I     2
// wciM0_SData                    I    32
// wciM0_SFlag                    I     2 reg
// wciM0_SThreadBusy              I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkWciOcpInitiator(CLK,
			 bar,

			 wciM0_MCmd,

			 wciM0_MAddrSpace,

			 wciM0_MByteEn,

			 wciM0_MAddr,

			 wciM0_MData,

			 wciM0_SResp,

			 wciM0_SData,

			 wciM0_SThreadBusy,

			 wciM0_SFlag,

			 wciM0_MFlag,

			 bar_wciM0_foo);
  input  CLK;
  input  bar;

  // value method wciM0_mCmd
  output [2 : 0] wciM0_MCmd;

  // value method wciM0_mAddrSpace
  output wciM0_MAddrSpace;

  // value method wciM0_mByteEn
  output [3 : 0] wciM0_MByteEn;

  // value method wciM0_mAddr
  output [19 : 0] wciM0_MAddr;

  // value method wciM0_mData
  output [31 : 0] wciM0_MData;

  // action method wciM0_sResp
  input  [1 : 0] wciM0_SResp;

  // action method wciM0_sData
  input  [31 : 0] wciM0_SData;

  // action method wciM0_sThreadBusy
  input  wciM0_SThreadBusy;

  // action method wciM0_sFlag
  input  [1 : 0] wciM0_SFlag;

  // value method wciM0_mFlag
  output [1 : 0] wciM0_MFlag;

  // output resets
  output bar_wciM0_foo;

  // signals for module outputs
  wire [31 : 0] wciM0_MData;
  wire [19 : 0] wciM0_MAddr;
  wire [3 : 0] wciM0_MByteEn;
  wire [2 : 0] wciM0_MCmd;
  wire [1 : 0] wciM0_MFlag;
  wire bar_wciM0_foo, wciM0_MAddrSpace;

  // inlined wires
  wire [59 : 0] initiator_reqF_x_wire$wget;
  wire [33 : 0] initiator_wciResponse$wget;
  wire [31 : 0] wci_Em_respData_w$wget;
  wire [1 : 0] wci_Em_resp_w$wget;
  wire initiator_reqF_dequeueing$whas,
       initiator_reqF_enqueueing$whas,
       initiator_reqF_x_wire$whas,
       initiator_sThreadBusy_pw$whas,
       initiator_sfCapClear_1$wget,
       initiator_sfCapClear_1$whas,
       initiator_sfCapSet_1$wget,
       initiator_sfCapSet_1$whas,
       initiator_wciResponse$whas,
       wci_Em_respData_w$whas,
       wci_Em_resp_w$whas;

  // register initiator_busy
  reg initiator_busy;
  wire initiator_busy$D_IN, initiator_busy$EN;

  // register initiator_lastConfigAddr
  reg [32 : 0] initiator_lastConfigAddr;
  wire [32 : 0] initiator_lastConfigAddr$D_IN;
  wire initiator_lastConfigAddr$EN;

  // register initiator_lastConfigBE
  reg [4 : 0] initiator_lastConfigBE;
  wire [4 : 0] initiator_lastConfigBE$D_IN;
  wire initiator_lastConfigBE$EN;

  // register initiator_lastControlOp
  reg [3 : 0] initiator_lastControlOp;
  wire [3 : 0] initiator_lastControlOp$D_IN;
  wire initiator_lastControlOp$EN;

  // register initiator_lastOpWrite
  reg [1 : 0] initiator_lastOpWrite;
  wire [1 : 0] initiator_lastOpWrite$D_IN;
  wire initiator_lastOpWrite$EN;

  // register initiator_mFlagReg
  reg [1 : 0] initiator_mFlagReg;
  wire [1 : 0] initiator_mFlagReg$D_IN;
  wire initiator_mFlagReg$EN;

  // register initiator_reqERR
  reg [2 : 0] initiator_reqERR;
  reg [2 : 0] initiator_reqERR$D_IN;
  wire initiator_reqERR$EN;

  // register initiator_reqFAIL
  reg [2 : 0] initiator_reqFAIL;
  reg [2 : 0] initiator_reqFAIL$D_IN;
  wire initiator_reqFAIL$EN;

  // register initiator_reqF_c_r
  reg initiator_reqF_c_r;
  wire initiator_reqF_c_r$D_IN, initiator_reqF_c_r$EN;

  // register initiator_reqF_q_0
  reg [59 : 0] initiator_reqF_q_0;
  wire [59 : 0] initiator_reqF_q_0$D_IN;
  wire initiator_reqF_q_0$EN;

  // register initiator_reqPend
  reg [1 : 0] initiator_reqPend;
  wire [1 : 0] initiator_reqPend$D_IN;
  wire initiator_reqPend$EN;

  // register initiator_reqTO
  reg [2 : 0] initiator_reqTO;
  reg [2 : 0] initiator_reqTO$D_IN;
  wire initiator_reqTO$EN;

  // register initiator_respTimr
  reg [31 : 0] initiator_respTimr;
  wire [31 : 0] initiator_respTimr$D_IN;
  wire initiator_respTimr$EN;

  // register initiator_respTimrAct
  reg initiator_respTimrAct;
  wire initiator_respTimrAct$D_IN, initiator_respTimrAct$EN;

  // register initiator_sThreadBusy_d
  reg initiator_sThreadBusy_d;
  wire initiator_sThreadBusy_d$D_IN, initiator_sThreadBusy_d$EN;

  // register initiator_sfCap
  reg initiator_sfCap;
  wire initiator_sfCap$D_IN, initiator_sfCap$EN;

  // register initiator_sfCapClear
  reg initiator_sfCapClear;
  wire initiator_sfCapClear$D_IN, initiator_sfCapClear$EN;

  // register initiator_sfCapSet
  reg initiator_sfCapSet;
  wire initiator_sfCapSet$D_IN, initiator_sfCapSet$EN;

  // register initiator_slvPresent
  reg initiator_slvPresent;
  wire initiator_slvPresent$D_IN, initiator_slvPresent$EN;

  // register initiator_wReset_n
  reg initiator_wReset_n;
  wire initiator_wReset_n$D_IN, initiator_wReset_n$EN;

  // register initiator_wStatus
  reg [31 : 0] initiator_wStatus;
  wire [31 : 0] initiator_wStatus$D_IN;
  wire initiator_wStatus$EN;

  // register initiator_wTimeout
  reg [4 : 0] initiator_wTimeout;
  wire [4 : 0] initiator_wTimeout$D_IN;
  wire initiator_wTimeout$EN;

  // ports of submodule initiator_mReset
  wire initiator_mReset$ASSERT_IN, initiator_mReset$OUT_RST_N;

  // ports of submodule initiator_respF
  wire [33 : 0] initiator_respF$D_IN;
  wire initiator_respF$CLR,
       initiator_respF$DEQ,
       initiator_respF$ENQ,
       initiator_respF$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_initiator_reqF_both,
       CAN_FIRE_RL_initiator_reqF_decCtr,
       CAN_FIRE_RL_initiator_reqF_deq,
       CAN_FIRE_RL_initiator_reqF_incCtr,
       CAN_FIRE_RL_initiator_sThreadBusy_reg,
       CAN_FIRE_RL_initiator_sfCapClear__dreg_update,
       CAN_FIRE_RL_initiator_sfCapSet__dreg_update,
       CAN_FIRE_RL_initiator_sflagUpdate,
       CAN_FIRE_RL_initiator_startTimer,
       CAN_FIRE_RL_initiator_updateStatus,
       CAN_FIRE_RL_initiator_workerReset,
       CAN_FIRE_RL_initiator_wrkBusy,
       CAN_FIRE_RL_wci_Em_doAlways,
       CAN_FIRE_wciM0_sData,
       CAN_FIRE_wciM0_sFlag,
       CAN_FIRE_wciM0_sResp,
       CAN_FIRE_wciM0_sThreadBusy,
       WILL_FIRE_RL_initiator_reqF_both,
       WILL_FIRE_RL_initiator_reqF_decCtr,
       WILL_FIRE_RL_initiator_reqF_deq,
       WILL_FIRE_RL_initiator_reqF_incCtr,
       WILL_FIRE_RL_initiator_sThreadBusy_reg,
       WILL_FIRE_RL_initiator_sfCapClear__dreg_update,
       WILL_FIRE_RL_initiator_sfCapSet__dreg_update,
       WILL_FIRE_RL_initiator_sflagUpdate,
       WILL_FIRE_RL_initiator_startTimer,
       WILL_FIRE_RL_initiator_updateStatus,
       WILL_FIRE_RL_initiator_workerReset,
       WILL_FIRE_RL_initiator_wrkBusy,
       WILL_FIRE_RL_wci_Em_doAlways,
       WILL_FIRE_wciM0_sData,
       WILL_FIRE_wciM0_sFlag,
       WILL_FIRE_wciM0_sResp,
       WILL_FIRE_wciM0_sThreadBusy;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_initiator_respTimr$write_1__VAL_2;
  wire MUX_initiator_reqF_c_r$write_1__VAL_2,
       MUX_initiator_respTimrAct$write_1__SEL_2;

  // remaining internal signals
  reg [63 : 0] v__h2674,
	       v__h2764,
	       v__h2853,
	       v__h3077,
	       v__h3167,
	       v__h3256,
	       v__h3485,
	       v__h3575,
	       v__h3664;
  wire [31 : 0] toCount__h2379, x__h2541;
  wire [26 : 0] IF_initiator_lastControlOp_22_BIT_3_23_THEN_in_ETC___d137;
  wire initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179;

  // output resets
  assign bar_wciM0_foo = initiator_mReset$OUT_RST_N ;

  // value method wciM0_mCmd
  assign wciM0_MCmd =
	     initiator_sThreadBusy_d ? 3'd0 : initiator_reqF_q_0[59:57] ;

  // value method wciM0_mAddrSpace
  assign wciM0_MAddrSpace =
	     !initiator_sThreadBusy_d && initiator_reqF_q_0[56] ;

  // value method wciM0_mByteEn
  assign wciM0_MByteEn =
	     initiator_sThreadBusy_d ? 4'd0 : initiator_reqF_q_0[55:52] ;

  // value method wciM0_mAddr
  assign wciM0_MAddr =
	     initiator_sThreadBusy_d ? 20'd0 : initiator_reqF_q_0[51:32] ;

  // value method wciM0_mData
  assign wciM0_MData = initiator_reqF_q_0[31:0] ;

  // action method wciM0_sResp
  assign CAN_FIRE_wciM0_sResp = 1'd1 ;
  assign WILL_FIRE_wciM0_sResp = 1'd1 ;

  // action method wciM0_sData
  assign CAN_FIRE_wciM0_sData = 1'd1 ;
  assign WILL_FIRE_wciM0_sData = 1'd1 ;

  // action method wciM0_sThreadBusy
  assign CAN_FIRE_wciM0_sThreadBusy = 1'd1 ;
  assign WILL_FIRE_wciM0_sThreadBusy = wciM0_SThreadBusy ;

  // action method wciM0_sFlag
  assign CAN_FIRE_wciM0_sFlag = 1'd1 ;
  assign WILL_FIRE_wciM0_sFlag = 1'd1 ;

  // value method wciM0_mFlag
  assign wciM0_MFlag = initiator_mFlagReg ;

  // submodule initiator_mReset
  MakeResetA #(.RSTDELAY(32'd16), .init(1'd0)) initiator_mReset(.CLK(CLK),
								.RST_N(bar),
								.DST_CLK(CLK),
								.ASSERT_IN(initiator_mReset$ASSERT_IN),
								.ASSERT_OUT(),
								.OUT_RST_N(initiator_mReset$OUT_RST_N));

  // submodule initiator_respF
  FIFO1 #(.width(32'd34), .guarded(32'd1)) initiator_respF(.RST_N(bar),
							   .CLK(CLK),
							   .D_IN(initiator_respF$D_IN),
							   .ENQ(initiator_respF$ENQ),
							   .DEQ(initiator_respF$DEQ),
							   .CLR(initiator_respF$CLR),
							   .D_OUT(),
							   .FULL_N(initiator_respF$FULL_N),
							   .EMPTY_N());

  // rule RL_initiator_workerReset
  assign CAN_FIRE_RL_initiator_workerReset = !initiator_wReset_n ;
  assign WILL_FIRE_RL_initiator_workerReset =
	     CAN_FIRE_RL_initiator_workerReset ;

  // rule RL_initiator_updateStatus
  assign CAN_FIRE_RL_initiator_updateStatus = 1'd1 ;
  assign WILL_FIRE_RL_initiator_updateStatus = 1'd1 ;

  // rule RL_initiator_sflagUpdate
  assign CAN_FIRE_RL_initiator_sflagUpdate = 1'd1 ;
  assign WILL_FIRE_RL_initiator_sflagUpdate = 1'd1 ;

  // rule RL_initiator_sfCapSet__dreg_update
  assign CAN_FIRE_RL_initiator_sfCapSet__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_initiator_sfCapSet__dreg_update = 1'd1 ;

  // rule RL_initiator_sfCapClear__dreg_update
  assign CAN_FIRE_RL_initiator_sfCapClear__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_initiator_sfCapClear__dreg_update = 1'd1 ;

  // rule RL_wci_Em_doAlways
  assign CAN_FIRE_RL_wci_Em_doAlways = 1'd1 ;
  assign WILL_FIRE_RL_wci_Em_doAlways = 1'd1 ;

  // rule RL_initiator_reqF_deq
  assign CAN_FIRE_RL_initiator_reqF_deq =
	     !initiator_sThreadBusy_d &&
	     initiator_wciResponse$wget[33:32] == 2'd0 ;
  assign WILL_FIRE_RL_initiator_reqF_deq = CAN_FIRE_RL_initiator_reqF_deq ;

  // rule RL_initiator_sThreadBusy_reg
  assign CAN_FIRE_RL_initiator_sThreadBusy_reg = 1'd1 ;
  assign WILL_FIRE_RL_initiator_sThreadBusy_reg = 1'd1 ;

  // rule RL_initiator_wrkBusy
  assign CAN_FIRE_RL_initiator_wrkBusy =
	     ((initiator_wciResponse$wget[33:32] == 2'd0) ?
		initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 ||
		initiator_respF$FULL_N :
		initiator_respF$FULL_N) &&
	     initiator_busy ;
  assign WILL_FIRE_RL_initiator_wrkBusy = CAN_FIRE_RL_initiator_wrkBusy ;

  // rule RL_initiator_startTimer
  assign CAN_FIRE_RL_initiator_startTimer = initiator_reqF_c_r ;
  assign WILL_FIRE_RL_initiator_startTimer = initiator_reqF_c_r ;

  // rule RL_initiator_reqF_incCtr
  assign CAN_FIRE_RL_initiator_reqF_incCtr = 1'b0 ;
  assign WILL_FIRE_RL_initiator_reqF_incCtr = 1'b0 ;

  // rule RL_initiator_reqF_decCtr
  assign CAN_FIRE_RL_initiator_reqF_decCtr = initiator_reqF_dequeueing$whas ;
  assign WILL_FIRE_RL_initiator_reqF_decCtr = initiator_reqF_dequeueing$whas ;

  // rule RL_initiator_reqF_both
  assign CAN_FIRE_RL_initiator_reqF_both = 1'b0 ;
  assign WILL_FIRE_RL_initiator_reqF_both = 1'b0 ;

  // inputs to muxes for submodule ports
  assign MUX_initiator_respTimrAct$write_1__SEL_2 =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     (!initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 ||
	      initiator_wciResponse$wget[33:32] != 2'd0) ;
  assign MUX_initiator_reqF_c_r$write_1__VAL_2 = initiator_reqF_c_r - 1'd1 ;
  assign MUX_initiator_respTimr$write_1__VAL_2 =
	     (initiator_wciResponse$wget[33:32] == 2'd0) ?
	       (initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 ?
		  x__h2541 :
		  32'd0) :
	       32'd0 ;

  // inlined wires
  assign initiator_reqF_x_wire$wget = 60'h0 ;
  assign initiator_reqF_x_wire$whas = 1'b0 ;
  assign initiator_wciResponse$wget = { wciM0_SResp, wciM0_SData } ;
  assign initiator_wciResponse$whas = 1'd1 ;
  assign initiator_sfCapSet_1$wget = wciM0_SFlag[0] ;
  assign initiator_sfCapSet_1$whas = 1'd1 ;
  assign initiator_sfCapClear_1$wget = 1'b0 ;
  assign initiator_sfCapClear_1$whas = 1'b0 ;
  assign wci_Em_resp_w$wget = wciM0_SResp ;
  assign wci_Em_resp_w$whas = 1'd1 ;
  assign wci_Em_respData_w$wget = wciM0_SData ;
  assign wci_Em_respData_w$whas = 1'd1 ;
  assign initiator_reqF_enqueueing$whas = 1'b0 ;
  assign initiator_reqF_dequeueing$whas =
	     WILL_FIRE_RL_initiator_reqF_deq && initiator_reqF_c_r ;
  assign initiator_sThreadBusy_pw$whas = wciM0_SThreadBusy ;

  // register initiator_busy
  assign initiator_busy$D_IN = 1'd0 ;
  assign initiator_busy$EN = MUX_initiator_respTimrAct$write_1__SEL_2 ;

  // register initiator_lastConfigAddr
  assign initiator_lastConfigAddr$D_IN = 33'h0 ;
  assign initiator_lastConfigAddr$EN = 1'b0 ;

  // register initiator_lastConfigBE
  assign initiator_lastConfigBE$D_IN = 5'h0 ;
  assign initiator_lastConfigBE$EN = 1'b0 ;

  // register initiator_lastControlOp
  assign initiator_lastControlOp$D_IN = 4'h0 ;
  assign initiator_lastControlOp$EN = 1'b0 ;

  // register initiator_lastOpWrite
  assign initiator_lastOpWrite$D_IN = 2'h0 ;
  assign initiator_lastOpWrite$EN = 1'b0 ;

  // register initiator_mFlagReg
  assign initiator_mFlagReg$D_IN = 2'h0 ;
  assign initiator_mFlagReg$EN = 1'b0 ;

  // register initiator_reqERR
  always@(initiator_reqPend or initiator_reqERR)
  begin
    case (initiator_reqPend)
      2'd1: initiator_reqERR$D_IN = { 1'd1, initiator_reqERR[1:0] };
      2'd2:
	  initiator_reqERR$D_IN =
	      { initiator_reqERR[2], 1'd1, initiator_reqERR[0] };
      default: initiator_reqERR$D_IN = { initiator_reqERR[2:1], 1'd1 };
    endcase
  end
  assign initiator_reqERR$EN =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     initiator_wciResponse$wget[33:32] == 2'd3 &&
	     (initiator_reqPend == 2'd1 || initiator_reqPend == 2'd2 ||
	      initiator_reqPend == 2'd3) ;

  // register initiator_reqFAIL
  always@(initiator_reqPend or initiator_reqFAIL)
  begin
    case (initiator_reqPend)
      2'd1: initiator_reqFAIL$D_IN = { 1'd1, initiator_reqFAIL[1:0] };
      2'd2:
	  initiator_reqFAIL$D_IN =
	      { initiator_reqFAIL[2], 1'd1, initiator_reqFAIL[0] };
      default: initiator_reqFAIL$D_IN = { initiator_reqFAIL[2:1], 1'd1 };
    endcase
  end
  assign initiator_reqFAIL$EN =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     initiator_wciResponse$wget[33:32] == 2'd2 &&
	     (initiator_reqPend == 2'd1 || initiator_reqPend == 2'd2 ||
	      initiator_reqPend == 2'd3) ;

  // register initiator_reqF_c_r
  assign initiator_reqF_c_r$D_IN = MUX_initiator_reqF_c_r$write_1__VAL_2 ;
  assign initiator_reqF_c_r$EN = initiator_reqF_dequeueing$whas ;

  // register initiator_reqF_q_0
  assign initiator_reqF_q_0$D_IN = 60'h0000000AAAAAAAA ;
  assign initiator_reqF_q_0$EN = initiator_reqF_dequeueing$whas ;

  // register initiator_reqPend
  assign initiator_reqPend$D_IN = 2'd0 ;
  assign initiator_reqPend$EN =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     initiator_wciResponse$wget[33:32] != 2'd0 ;

  // register initiator_reqTO
  always@(initiator_reqPend or initiator_reqTO)
  begin
    case (initiator_reqPend)
      2'd1: initiator_reqTO$D_IN = { 1'd1, initiator_reqTO[1:0] };
      2'd2:
	  initiator_reqTO$D_IN =
	      { initiator_reqTO[2], 1'd1, initiator_reqTO[0] };
      default: initiator_reqTO$D_IN = { initiator_reqTO[2:1], 1'd1 };
    endcase
  end
  assign initiator_reqTO$EN =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     initiator_wciResponse$wget[33:32] == 2'd0 &&
	     !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	     (initiator_reqPend == 2'd1 || initiator_reqPend == 2'd2 ||
	      initiator_reqPend == 2'd3) ;

  // register initiator_respTimr
  assign initiator_respTimr$D_IN =
	     initiator_reqF_c_r ?
	       32'd0 :
	       MUX_initiator_respTimr$write_1__VAL_2 ;
  assign initiator_respTimr$EN =
	     WILL_FIRE_RL_initiator_wrkBusy || initiator_reqF_c_r ;

  // register initiator_respTimrAct
  assign initiator_respTimrAct$D_IN = initiator_reqF_c_r ;
  assign initiator_respTimrAct$EN =
	     WILL_FIRE_RL_initiator_wrkBusy &&
	     (!initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 ||
	      initiator_wciResponse$wget[33:32] != 2'd0) ||
	     initiator_reqF_c_r ;

  // register initiator_sThreadBusy_d
  assign initiator_sThreadBusy_d$D_IN = wciM0_SThreadBusy ;
  assign initiator_sThreadBusy_d$EN = 1'd1 ;

  // register initiator_sfCap
  assign initiator_sfCap$D_IN = initiator_sfCapSet ;
  assign initiator_sfCap$EN = initiator_sfCapSet || initiator_sfCapClear ;

  // register initiator_sfCapClear
  assign initiator_sfCapClear$D_IN = 1'b0 ;
  assign initiator_sfCapClear$EN = 1'd1 ;

  // register initiator_sfCapSet
  assign initiator_sfCapSet$D_IN = wciM0_SFlag[0] ;
  assign initiator_sfCapSet$EN = 1'd1 ;

  // register initiator_slvPresent
  assign initiator_slvPresent$D_IN = wciM0_SFlag[1] ;
  assign initiator_slvPresent$EN = 1'd1 ;

  // register initiator_wReset_n
  assign initiator_wReset_n$D_IN = 1'b0 ;
  assign initiator_wReset_n$EN = 1'b0 ;

  // register initiator_wStatus
  assign initiator_wStatus$D_IN =
	     { 4'b0,
	       !initiator_lastOpWrite[1] || initiator_lastOpWrite[0],
	       IF_initiator_lastControlOp_22_BIT_3_23_THEN_in_ETC___d137 } ;
  assign initiator_wStatus$EN = 1'd1 ;

  // register initiator_wTimeout
  assign initiator_wTimeout$D_IN = 5'h0 ;
  assign initiator_wTimeout$EN = 1'b0 ;

  // submodule initiator_mReset
  assign initiator_mReset$ASSERT_IN = CAN_FIRE_RL_initiator_workerReset ;

  // submodule initiator_respF
  assign initiator_respF$D_IN =
	     (initiator_wciResponse$wget[33:32] == 2'd0) ?
	       34'h1C0DE4203 :
	       initiator_wciResponse$wget ;
  assign initiator_respF$ENQ = MUX_initiator_respTimrAct$write_1__SEL_2 ;
  assign initiator_respF$DEQ = 1'b0 ;
  assign initiator_respF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_initiator_lastControlOp_22_BIT_3_23_THEN_in_ETC___d137 =
	     { initiator_lastControlOp[3] ?
		 initiator_lastControlOp[2:0] :
		 3'b111,
	       initiator_lastConfigBE[4] ? initiator_lastConfigBE[3:0] : 4'hF,
	       initiator_lastOpWrite[1],
	       initiator_lastControlOp[3],
	       initiator_lastConfigBE[4],
	       initiator_lastConfigAddr[32],
	       6'b0,
	       initiator_sfCap,
	       initiator_reqTO,
	       initiator_reqFAIL,
	       initiator_reqERR } ;
  assign initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 =
	     initiator_respTimr < toCount__h2379 ;
  assign toCount__h2379 = 32'd1 << initiator_wTimeout ;
  assign x__h2541 = initiator_respTimr + 32'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!bar)
      begin
        initiator_busy <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_lastConfigAddr <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
	initiator_lastConfigBE <= `BSV_ASSIGNMENT_DELAY 5'd10;
	initiator_lastControlOp <= `BSV_ASSIGNMENT_DELAY 4'd2;
	initiator_lastOpWrite <= `BSV_ASSIGNMENT_DELAY 2'd0;
	initiator_mFlagReg <= `BSV_ASSIGNMENT_DELAY 2'b10;
	initiator_reqERR <= `BSV_ASSIGNMENT_DELAY 3'd0;
	initiator_reqFAIL <= `BSV_ASSIGNMENT_DELAY 3'd0;
	initiator_reqF_c_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_reqF_q_0 <= `BSV_ASSIGNMENT_DELAY 60'h0000000AAAAAAAA;
	initiator_reqPend <= `BSV_ASSIGNMENT_DELAY 2'd0;
	initiator_reqTO <= `BSV_ASSIGNMENT_DELAY 3'd0;
	initiator_respTimr <= `BSV_ASSIGNMENT_DELAY 32'd0;
	initiator_respTimrAct <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY 1'd1;
	initiator_sfCap <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_sfCapClear <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_sfCapSet <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_slvPresent <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_wReset_n <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initiator_wTimeout <= `BSV_ASSIGNMENT_DELAY 5'h04;
      end
    else
      begin
        if (initiator_busy$EN)
	  initiator_busy <= `BSV_ASSIGNMENT_DELAY initiator_busy$D_IN;
	if (initiator_lastConfigAddr$EN)
	  initiator_lastConfigAddr <= `BSV_ASSIGNMENT_DELAY
	      initiator_lastConfigAddr$D_IN;
	if (initiator_lastConfigBE$EN)
	  initiator_lastConfigBE <= `BSV_ASSIGNMENT_DELAY
	      initiator_lastConfigBE$D_IN;
	if (initiator_lastControlOp$EN)
	  initiator_lastControlOp <= `BSV_ASSIGNMENT_DELAY
	      initiator_lastControlOp$D_IN;
	if (initiator_lastOpWrite$EN)
	  initiator_lastOpWrite <= `BSV_ASSIGNMENT_DELAY
	      initiator_lastOpWrite$D_IN;
	if (initiator_mFlagReg$EN)
	  initiator_mFlagReg <= `BSV_ASSIGNMENT_DELAY initiator_mFlagReg$D_IN;
	if (initiator_reqERR$EN)
	  initiator_reqERR <= `BSV_ASSIGNMENT_DELAY initiator_reqERR$D_IN;
	if (initiator_reqFAIL$EN)
	  initiator_reqFAIL <= `BSV_ASSIGNMENT_DELAY initiator_reqFAIL$D_IN;
	if (initiator_reqF_c_r$EN)
	  initiator_reqF_c_r <= `BSV_ASSIGNMENT_DELAY initiator_reqF_c_r$D_IN;
	if (initiator_reqF_q_0$EN)
	  initiator_reqF_q_0 <= `BSV_ASSIGNMENT_DELAY initiator_reqF_q_0$D_IN;
	if (initiator_reqPend$EN)
	  initiator_reqPend <= `BSV_ASSIGNMENT_DELAY initiator_reqPend$D_IN;
	if (initiator_reqTO$EN)
	  initiator_reqTO <= `BSV_ASSIGNMENT_DELAY initiator_reqTO$D_IN;
	if (initiator_respTimr$EN)
	  initiator_respTimr <= `BSV_ASSIGNMENT_DELAY initiator_respTimr$D_IN;
	if (initiator_respTimrAct$EN)
	  initiator_respTimrAct <= `BSV_ASSIGNMENT_DELAY
	      initiator_respTimrAct$D_IN;
	if (initiator_sThreadBusy_d$EN)
	  initiator_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY
	      initiator_sThreadBusy_d$D_IN;
	if (initiator_sfCap$EN)
	  initiator_sfCap <= `BSV_ASSIGNMENT_DELAY initiator_sfCap$D_IN;
	if (initiator_sfCapClear$EN)
	  initiator_sfCapClear <= `BSV_ASSIGNMENT_DELAY
	      initiator_sfCapClear$D_IN;
	if (initiator_sfCapSet$EN)
	  initiator_sfCapSet <= `BSV_ASSIGNMENT_DELAY initiator_sfCapSet$D_IN;
	if (initiator_slvPresent$EN)
	  initiator_slvPresent <= `BSV_ASSIGNMENT_DELAY
	      initiator_slvPresent$D_IN;
	if (initiator_wReset_n$EN)
	  initiator_wReset_n <= `BSV_ASSIGNMENT_DELAY initiator_wReset_n$D_IN;
	if (initiator_wTimeout$EN)
	  initiator_wTimeout <= `BSV_ASSIGNMENT_DELAY initiator_wTimeout$D_IN;
      end
    if (initiator_wStatus$EN)
      initiator_wStatus <= `BSV_ASSIGNMENT_DELAY initiator_wStatus$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    initiator_busy = 1'h0;
    initiator_lastConfigAddr = 33'h0AAAAAAAA;
    initiator_lastConfigBE = 5'h0A;
    initiator_lastControlOp = 4'hA;
    initiator_lastOpWrite = 2'h2;
    initiator_mFlagReg = 2'h2;
    initiator_reqERR = 3'h2;
    initiator_reqFAIL = 3'h2;
    initiator_reqF_c_r = 1'h0;
    initiator_reqF_q_0 = 60'hAAAAAAAAAAAAAAA;
    initiator_reqPend = 2'h2;
    initiator_reqTO = 3'h2;
    initiator_respTimr = 32'hAAAAAAAA;
    initiator_respTimrAct = 1'h0;
    initiator_sThreadBusy_d = 1'h0;
    initiator_sfCap = 1'h0;
    initiator_sfCapClear = 1'h0;
    initiator_sfCapSet = 1'h0;
    initiator_slvPresent = 1'h0;
    initiator_wReset_n = 1'h0;
    initiator_wStatus = 32'hAAAAAAAA;
    initiator_wTimeout = 5'h0A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd1)
	begin
	  v__h2674 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd1)
	$display("[%0d]: %m: WORKER CONFIG-WRITE TIMEOUT", v__h2674);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd2)
	begin
	  v__h2764 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd2)
	$display("[%0d]: %m: WORKER CONFIG-READ  TIMEOUT", v__h2764);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd3)
	begin
	  v__h2853 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd0 &&
	  !initiator_respTimr_7_ULT_1_SL_initiator_wTimeo_ETC___d179 &&
	  initiator_reqPend == 2'd3)
	$display("[%0d]: %m: WORKER CONTROL-OP   TIMEOUT", v__h2853);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd1)
	begin
	  v__h3077 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd1)
	$display("[%0d]: %m: WORKER CONFIG-WRITE RESPONSE-FAIL", v__h3077);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd2)
	begin
	  v__h3167 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd2)
	$display("[%0d]: %m: WORKER CONFIG-READ  RESPONSE-FAIL", v__h3167);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd3)
	begin
	  v__h3256 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd2 &&
	  initiator_reqPend == 2'd3)
	$display("[%0d]: %m: WORKER CONTROL-OP   RESPONSE-FAIL", v__h3256);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd1)
	begin
	  v__h3485 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd1)
	$display("[%0d]: %m: WORKER CONFIG-WRITE RESPONSE-ERR", v__h3485);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd2)
	begin
	  v__h3575 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd2)
	$display("[%0d]: %m: WORKER CONFIG-READ  RESPONSE-ERR", v__h3575);
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd3)
	begin
	  v__h3664 = $time;
	  #0;
	end
    if (bar)
      if (WILL_FIRE_RL_initiator_wrkBusy &&
	  initiator_wciResponse$wget[33:32] == 2'd3 &&
	  initiator_reqPend == 2'd3)
	$display("[%0d]: %m: WORKER CONTROL-OP   RESPONSE-ERR", v__h3664);
  end
  // synopsys translate_on
endmodule  // mkWciOcpInitiator

