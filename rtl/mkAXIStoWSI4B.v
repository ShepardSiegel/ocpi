//
// Generated by Bluespec Compiler, version 2010.10.beta1 (build 22431, 2010-10-28)
//
// On Thu Feb 10 10:47:41 EST 2011
//
//
// Ports:
// Name                         I/O  size props
// axi_TREADY                     O     1
// reqGet_get                     O    61 reg
// RDY_reqGet_get                 O     1 reg
// RDY_operate                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi_TDATA                      I    32 reg
// axi_TSTRB                      I     4 reg
// axi_TUSER                      I    32 reg
// axi_TVALID                     I     1
// axi_TLAST                      I     1 reg
// EN_operate                     I     1 reg
// EN_reqGet_get                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkAXIStoWSI4B(CLK,
		     RST_N,

		     axi_TVALID,

		     axi_TREADY,

		     axi_TDATA,

		     axi_TSTRB,

		     axi_TUSER,

		     axi_TLAST,

		     EN_reqGet_get,
		     reqGet_get,
		     RDY_reqGet_get,

		     EN_operate,
		     RDY_operate);
  input  CLK;
  input  RST_N;

  // action method axi_mTVALID
  input  axi_TVALID;

  // value method axi_sTREADY
  output axi_TREADY;

  // action method axi_mTDATA
  input  [31 : 0] axi_TDATA;

  // action method axi_mTSTRB
  input  [3 : 0] axi_TSTRB;

  // action method axi_mTUSER
  input  [31 : 0] axi_TUSER;

  // action method axi_mTKEEP

  // action method axi_mTLAST
  input  axi_TLAST;

  // actionvalue method reqGet_get
  input  EN_reqGet_get;
  output [60 : 0] reqGet_get;
  output RDY_reqGet_get;

  // action method operate
  input  EN_operate;
  output RDY_operate;

  // signals for module outputs
  wire [60 : 0] reqGet_get;
  wire RDY_operate, RDY_reqGet_get, axi_TREADY;

  // inlined wires
  wire [68 : 0] axiS_data_wire$wget;
  wire [31 : 0] axi_Es_mTData_w$wget, axi_Es_mTUser_w$wget;
  wire [3 : 0] axi_Es_mTStrb_w$wget;
  wire axiS_enq_enq$whas,
       axiS_enq_valid$whas,
       axi_Es_mTData_w$whas,
       axi_Es_mTKeep_w$whas,
       axi_Es_mTLast_w$wget,
       axi_Es_mTLast_w$whas,
       axi_Es_mTStrb_w$whas,
       axi_Es_mTUser_w$whas,
       axi_Es_mTVal_w$wget,
       axi_Es_mTVal_w$whas,
       operateD_1$wget,
       operateD_1$whas,
       reqFifo_doResetClr$whas,
       reqFifo_doResetDeq$whas,
       reqFifo_doResetEnq$whas,
       reqFifo_r_clr$whas,
       reqFifo_r_deq$whas,
       reqFifo_r_enq$whas;

  // register operateD
  reg operateD;
  wire operateD$D_IN, operateD$EN;

  // register reqFifo_countReg
  reg [1 : 0] reqFifo_countReg;
  wire [1 : 0] reqFifo_countReg$D_IN;
  wire reqFifo_countReg$EN;

  // register reqFifo_levelsValid
  reg reqFifo_levelsValid;
  wire reqFifo_levelsValid$D_IN, reqFifo_levelsValid$EN;

  // ports of submodule axiS_fifof
  wire [68 : 0] axiS_fifof$D_IN, axiS_fifof$D_OUT;
  wire axiS_fifof$CLR,
       axiS_fifof$DEQ,
       axiS_fifof$EMPTY_N,
       axiS_fifof$ENQ,
       axiS_fifof$FULL_N;

  // ports of submodule reqFifo
  wire [60 : 0] reqFifo$D_IN, reqFifo$D_OUT;
  wire reqFifo$CLR, reqFifo$DEQ, reqFifo$EMPTY_N, reqFifo$ENQ, reqFifo$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_advance_data,
       CAN_FIRE_RL_axiS_do_enq,
       CAN_FIRE_RL_axi_Es_doAlways,
       CAN_FIRE_RL_operateD__dreg_update,
       CAN_FIRE_RL_reqFifo__updateLevelCounter,
       CAN_FIRE_RL_reqFifo_reset,
       CAN_FIRE_axi_mTDATA,
       CAN_FIRE_axi_mTKEEP,
       CAN_FIRE_axi_mTLAST,
       CAN_FIRE_axi_mTSTRB,
       CAN_FIRE_axi_mTUSER,
       CAN_FIRE_axi_mTVALID,
       CAN_FIRE_operate,
       CAN_FIRE_reqGet_get,
       WILL_FIRE_RL_advance_data,
       WILL_FIRE_RL_axiS_do_enq,
       WILL_FIRE_RL_axi_Es_doAlways,
       WILL_FIRE_RL_operateD__dreg_update,
       WILL_FIRE_RL_reqFifo__updateLevelCounter,
       WILL_FIRE_RL_reqFifo_reset,
       WILL_FIRE_axi_mTDATA,
       WILL_FIRE_axi_mTKEEP,
       WILL_FIRE_axi_mTLAST,
       WILL_FIRE_axi_mTSTRB,
       WILL_FIRE_axi_mTUSER,
       WILL_FIRE_axi_mTVALID,
       WILL_FIRE_operate,
       WILL_FIRE_reqGet_get;

  // remaining internal signals
  wire [15 : 0] x__h1243;

  // action method axi_mTVALID
  assign CAN_FIRE_axi_mTVALID = 1'd1 ;
  assign WILL_FIRE_axi_mTVALID = axi_TVALID ;

  // value method axi_sTREADY
  assign axi_TREADY = axiS_fifof$FULL_N ;

  // action method axi_mTDATA
  assign CAN_FIRE_axi_mTDATA = 1'd1 ;
  assign WILL_FIRE_axi_mTDATA = 1'd1 ;

  // action method axi_mTSTRB
  assign CAN_FIRE_axi_mTSTRB = 1'd1 ;
  assign WILL_FIRE_axi_mTSTRB = 1'd1 ;

  // action method axi_mTUSER
  assign CAN_FIRE_axi_mTUSER = 1'd1 ;
  assign WILL_FIRE_axi_mTUSER = 1'd1 ;

  // action method axi_mTKEEP
  assign CAN_FIRE_axi_mTKEEP = 1'd1 ;
  assign WILL_FIRE_axi_mTKEEP = 1'd1 ;

  // action method axi_mTLAST
  assign CAN_FIRE_axi_mTLAST = 1'd1 ;
  assign WILL_FIRE_axi_mTLAST = axi_TLAST ;

  // actionvalue method reqGet_get
  assign reqGet_get = reqFifo$D_OUT ;
  assign RDY_reqGet_get = reqFifo$EMPTY_N ;
  assign CAN_FIRE_reqGet_get = reqFifo$EMPTY_N ;
  assign WILL_FIRE_reqGet_get = EN_reqGet_get ;

  // action method operate
  assign RDY_operate = 1'd1 ;
  assign CAN_FIRE_operate = 1'd1 ;
  assign WILL_FIRE_operate = EN_operate ;

  // submodule axiS_fifof
  FIFO2 #(.width(32'd69), .guarded(32'd1)) axiS_fifof(.RST_N(RST_N),
						      .CLK(CLK),
						      .D_IN(axiS_fifof$D_IN),
						      .ENQ(axiS_fifof$ENQ),
						      .DEQ(axiS_fifof$DEQ),
						      .CLR(axiS_fifof$CLR),
						      .D_OUT(axiS_fifof$D_OUT),
						      .FULL_N(axiS_fifof$FULL_N),
						      .EMPTY_N(axiS_fifof$EMPTY_N));

  // submodule reqFifo
  SizedFIFO #(.p1width(32'd61),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) reqFifo(.RST_N(RST_N),
				       .CLK(CLK),
				       .D_IN(reqFifo$D_IN),
				       .ENQ(reqFifo$ENQ),
				       .DEQ(reqFifo$DEQ),
				       .CLR(reqFifo$CLR),
				       .D_OUT(reqFifo$D_OUT),
				       .FULL_N(reqFifo$FULL_N),
				       .EMPTY_N(reqFifo$EMPTY_N));

  // rule RL_advance_data
  assign CAN_FIRE_RL_advance_data =
	     axiS_fifof$EMPTY_N && reqFifo$FULL_N && operateD ;
  assign WILL_FIRE_RL_advance_data = CAN_FIRE_RL_advance_data ;

  // rule RL_reqFifo__updateLevelCounter
  assign CAN_FIRE_RL_reqFifo__updateLevelCounter =
	     CAN_FIRE_RL_advance_data != EN_reqGet_get ;
  assign WILL_FIRE_RL_reqFifo__updateLevelCounter =
	     CAN_FIRE_RL_reqFifo__updateLevelCounter ;

  // rule RL_reqFifo_reset
  assign CAN_FIRE_RL_reqFifo_reset =
	     CAN_FIRE_RL_advance_data || EN_reqGet_get ;
  assign WILL_FIRE_RL_reqFifo_reset = CAN_FIRE_RL_reqFifo_reset ;

  // rule RL_operateD__dreg_update
  assign CAN_FIRE_RL_operateD__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_operateD__dreg_update = 1'd1 ;

  // rule RL_axi_Es_doAlways
  assign CAN_FIRE_RL_axi_Es_doAlways = 1'd1 ;
  assign WILL_FIRE_RL_axi_Es_doAlways = 1'd1 ;

  // rule RL_axiS_do_enq
  assign CAN_FIRE_RL_axiS_do_enq = axiS_fifof$FULL_N && axi_TVALID ;
  assign WILL_FIRE_RL_axiS_do_enq = CAN_FIRE_RL_axiS_do_enq ;

  // inlined wires
  assign operateD_1$wget = 1'd1 ;
  assign operateD_1$whas = EN_operate ;
  assign axi_Es_mTVal_w$wget = 1'd1 ;
  assign axi_Es_mTVal_w$whas = axi_TVALID ;
  assign axi_Es_mTLast_w$wget = 1'd1 ;
  assign axi_Es_mTLast_w$whas = axi_TLAST ;
  assign axi_Es_mTData_w$wget = axi_TDATA ;
  assign axi_Es_mTData_w$whas = 1'd1 ;
  assign axi_Es_mTStrb_w$wget = axi_TSTRB ;
  assign axi_Es_mTStrb_w$whas = 1'd1 ;
  assign axi_Es_mTUser_w$wget = axi_TUSER ;
  assign axi_Es_mTUser_w$whas = 1'd1 ;
  assign axiS_enq_valid$whas = axi_TVALID ;
  assign axiS_enq_enq$whas = 1'b0 ;
  assign reqFifo_r_enq$whas = CAN_FIRE_RL_advance_data ;
  assign reqFifo_r_deq$whas = EN_reqGet_get ;
  assign reqFifo_r_clr$whas = 1'b0 ;
  assign reqFifo_doResetEnq$whas = CAN_FIRE_RL_advance_data ;
  assign reqFifo_doResetDeq$whas = EN_reqGet_get ;
  assign reqFifo_doResetClr$whas = 1'b0 ;
  assign axi_Es_mTKeep_w$whas = 1'd1 ;
  assign axiS_data_wire$wget =
	     { axi_TDATA, axi_TSTRB, axi_TUSER, axi_TLAST } ;

  // register operateD
  assign operateD$D_IN = EN_operate ;
  assign operateD$EN = 1'd1 ;

  // register reqFifo_countReg
  assign reqFifo_countReg$D_IN =
	     CAN_FIRE_RL_advance_data ?
	       reqFifo_countReg + 2'd1 :
	       reqFifo_countReg - 2'd1 ;
  assign reqFifo_countReg$EN = CAN_FIRE_RL_reqFifo__updateLevelCounter ;

  // register reqFifo_levelsValid
  assign reqFifo_levelsValid$D_IN = WILL_FIRE_RL_reqFifo_reset ;
  assign reqFifo_levelsValid$EN =
	     WILL_FIRE_RL_advance_data || EN_reqGet_get ||
	     WILL_FIRE_RL_reqFifo_reset ;

  // submodule axiS_fifof
  assign axiS_fifof$D_IN = axiS_data_wire$wget ;
  assign axiS_fifof$ENQ = CAN_FIRE_RL_axiS_do_enq ;
  assign axiS_fifof$DEQ = CAN_FIRE_RL_advance_data ;
  assign axiS_fifof$CLR = 1'b0 ;

  // submodule reqFifo
  assign reqFifo$D_IN =
	     { 3'd1,
	       axiS_fifof$D_OUT[0],
	       1'd1,
	       x__h1243[11:0],
	       axiS_fifof$D_OUT[68:33],
	       axiS_fifof$D_OUT[8:1] } ;
  assign reqFifo$ENQ = CAN_FIRE_RL_advance_data ;
  assign reqFifo$DEQ = EN_reqGet_get ;
  assign reqFifo$CLR = 1'b0 ;

  // remaining internal signals
  assign x__h1243 = axiS_fifof$D_OUT[32:17] >> 2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        operateD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	reqFifo_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	reqFifo_levelsValid <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (operateD$EN) operateD <= `BSV_ASSIGNMENT_DELAY operateD$D_IN;
	if (reqFifo_countReg$EN)
	  reqFifo_countReg <= `BSV_ASSIGNMENT_DELAY reqFifo_countReg$D_IN;
	if (reqFifo_levelsValid$EN)
	  reqFifo_levelsValid <= `BSV_ASSIGNMENT_DELAY
	      reqFifo_levelsValid$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    operateD = 1'h0;
    reqFifo_countReg = 2'h2;
    reqFifo_levelsValid = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAXIStoWSI4B

