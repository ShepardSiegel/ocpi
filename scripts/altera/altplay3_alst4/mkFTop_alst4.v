//
// Generated by Bluespec Compiler, version 2011.03.beta1 (build 23381, 2011-03-08)
//
// On Thu May 26 08:20:45 EDT 2011
//
//
// Ports:
// Name                         I/O  size props
// pcie_tx                        O     4
// led                            O    16
// p125clk                        O     1 clock
// CLK_GATE_p125clk               O     1 const
// p125rst                        O     1 reset
// sys0_clk                       I     1 clock
// sys0_rstn                      I     1 reset
// pcie_clk                       I     1 clock
// pcie_rstn                      I     1 reset
// pcie_rx_i                      I     4
// usr_sw_i                       I     8 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFTop_alst4(sys0_clk,
		    sys0_rstn,
		    pcie_clk,
		    pcie_rstn,

		    pcie_rx_i,

		    pcie_tx,

		    usr_sw_i,

		    led,

		    p125clk,
		    CLK_GATE_p125clk,

		    p125rst);
  input  sys0_clk;
  input  sys0_rstn;
  input  pcie_clk;
  input  pcie_rstn;

  // action method pcie_rx
  input  [3 : 0] pcie_rx_i;

  // value method pcie_tx
  output [3 : 0] pcie_tx;

  // action method usr_sw
  input  [7 : 0] usr_sw_i;

  // value method led
  output [15 : 0] led;

  // oscillator and gates for output clock p125clk
  output p125clk;
  output CLK_GATE_p125clk;

  // output resets
  output p125rst;

  // signals for module outputs
  wire [15 : 0] led;
  wire [3 : 0] pcie_tx;
  wire CLK_GATE_p125clk, p125clk, p125rst;

  // inlined wires
  wire pciw_pwAvaRx$whas, pciw_pwAvaTx$whas;

  // register freeCnt
  reg [31 : 0] freeCnt;
  wire [31 : 0] freeCnt$D_IN;
  wire freeCnt$EN;

  // register pciw_rxSerPos
  reg [1 : 0] pciw_rxSerPos;
  wire [1 : 0] pciw_rxSerPos$D_IN;
  wire pciw_rxSerPos$EN;

  // register pciw_txHeadPushed
  reg pciw_txHeadPushed;
  wire pciw_txHeadPushed$D_IN, pciw_txHeadPushed$EN;

  // register pciw_txSerPos
  reg [1 : 0] pciw_txSerPos;
  wire [1 : 0] pciw_txSerPos$D_IN;
  wire pciw_txSerPos$EN;

  // register swReg
  reg [7 : 0] swReg;
  wire [7 : 0] swReg$D_IN;
  wire swReg$EN;

  // ports of submodule aliveLed_sb
  wire aliveLed_sb$dD_OUT, aliveLed_sb$sD_IN, aliveLed_sb$sEN;

  // ports of submodule linkLed_sb
  wire linkLed_sb$dD_OUT, linkLed_sb$sD_IN, linkLed_sb$sEN;

  // ports of submodule pciw_pcie_ep
  wire [127 : 0] pciw_pcie_ep$rx_st_data0, pciw_pcie_ep$tx_st_data0;
  wire [15 : 0] pciw_pcie_ep$rx_st_be0;
  wire [7 : 0] pciw_pcie_ep$rx_st_bardec0;
  wire [3 : 0] pciw_pcie_ep$pcie_rx_in, pciw_pcie_ep$pcie_tx_out;
  wire pciw_pcie_ep$ava_alive,
       pciw_pcie_ep$ava_core_clk_out,
       pciw_pcie_ep$ava_lnk_up,
       pciw_pcie_ep$ava_srstn,
       pciw_pcie_ep$rx_st_eop0,
       pciw_pcie_ep$rx_st_mask0,
       pciw_pcie_ep$rx_st_ready0,
       pciw_pcie_ep$rx_st_sop0,
       pciw_pcie_ep$rx_st_valid0,
       pciw_pcie_ep$tx_st_empty0,
       pciw_pcie_ep$tx_st_eop0,
       pciw_pcie_ep$tx_st_err0,
       pciw_pcie_ep$tx_st_ready0,
       pciw_pcie_ep$tx_st_sop0,
       pciw_pcie_ep$tx_st_valid0;

  // ports of submodule pciw_rxOutF
  wire [152 : 0] pciw_rxOutF$D_IN;
  wire pciw_rxOutF$CLR, pciw_rxOutF$DEQ, pciw_rxOutF$ENQ, pciw_rxOutF$FULL_N;

  // ports of submodule pciw_rxStageF
  wire [152 : 0] pciw_rxStageF$D_IN, pciw_rxStageF$D_OUT;
  wire pciw_rxStageF$CLR,
       pciw_rxStageF$DEQ,
       pciw_rxStageF$EMPTY_N,
       pciw_rxStageF$ENQ,
       pciw_rxStageF$FULL_N;

  // ports of submodule pciw_txInF
  wire [152 : 0] pciw_txInF$D_IN, pciw_txInF$D_OUT;
  wire pciw_txInF$CLR, pciw_txInF$DEQ, pciw_txInF$EMPTY_N, pciw_txInF$ENQ;

  // ports of submodule pciw_txStageF
  wire [152 : 0] pciw_txStageF$D_IN, pciw_txStageF$D_OUT;
  wire pciw_txStageF$CLR,
       pciw_txStageF$DEQ,
       pciw_txStageF$EMPTY_N,
       pciw_txStageF$ENQ,
       pciw_txStageF$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_pciw_rx_destage,
       WILL_FIRE_RL_pciw_rx_enstage,
       WILL_FIRE_RL_pciw_tx_destage,
       WILL_FIRE_RL_pciw_tx_enstage;

  // inputs to muxes for submodule ports
  wire [152 : 0] MUX_pciw_rxOutF$enq_1__VAL_1, MUX_pciw_rxOutF$enq_1__VAL_2;
  wire [127 : 0] MUX_pciw_pcie_ep$ava_tx_data_1__VAL_1,
		 MUX_pciw_pcie_ep$ava_tx_data_1__VAL_2;
  wire [1 : 0] MUX_pciw_rxSerPos$write_1__VAL_1;
  wire MUX_pciw_rxOutF$enq_1__SEL_1, MUX_pciw_rxSerPos$write_1__SEL_1;

  // remaining internal signals
  wire [127 : 0] data__h1194, data__h1754, y_avValue_snd__h1590;
  wire [15 : 0] be__h1193;
  wire IF_pciw_rxSerPos_EQ_0_AND_NOT_pciw_pcie_ep_ava_ETC___d13,
       swParity__h135,
       z__h5810,
       z__h5817,
       z__h5824,
       z__h5831,
       z__h5838,
       z__h5845;

  // oscillator and gates for output clock p125clk
  assign p125clk = pciw_pcie_ep$ava_core_clk_out ;
  assign CLK_GATE_p125clk = 1'b1 ;

  // output resets
  assign p125rst = pciw_pcie_ep$ava_srstn ;

  // value method pcie_tx
  assign pcie_tx = pciw_pcie_ep$pcie_tx_out ;

  // value method led
  assign led =
	     { 8'h42,
	       ~swParity__h135,
	       swParity__h135,
	       aliveLed_sb$dD_OUT,
	       linkLed_sb$dD_OUT,
	       freeCnt[29:26] } ;

  // submodule aliveLed_sb
  SyncBit #(.init(1'd0)) aliveLed_sb(.sCLK(pciw_pcie_ep$ava_core_clk_out),
				     .dCLK(sys0_clk),
				     .sRST_N(pciw_pcie_ep$ava_srstn),
				     .sD_IN(aliveLed_sb$sD_IN),
				     .sEN(aliveLed_sb$sEN),
				     .dD_OUT(aliveLed_sb$dD_OUT));

  // submodule linkLed_sb
  SyncBit #(.init(1'd0)) linkLed_sb(.sCLK(pciw_pcie_ep$ava_core_clk_out),
				    .dCLK(sys0_clk),
				    .sRST_N(pciw_pcie_ep$ava_srstn),
				    .sD_IN(linkLed_sb$sD_IN),
				    .sEN(linkLed_sb$sEN),
				    .dD_OUT(linkLed_sb$dD_OUT));

  // submodule pciw_pcie_ep
  pcie_hip_s4gx_gen2_x4_128_wrapper pciw_pcie_ep(.sys0_clk(sys0_clk),
						 .sys0_rstn(sys0_rstn),
						 .pcie_clk(pcie_clk),
						 .pcie_rstn(pcie_rstn),
						 .pcie_rx_in(pciw_pcie_ep$pcie_rx_in),
						 .rx_st_mask0(pciw_pcie_ep$rx_st_mask0),
						 .rx_st_ready0(pciw_pcie_ep$rx_st_ready0),
						 .tx_st_data0(pciw_pcie_ep$tx_st_data0),
						 .tx_st_empty0(pciw_pcie_ep$tx_st_empty0),
						 .tx_st_eop0(pciw_pcie_ep$tx_st_eop0),
						 .tx_st_err0(pciw_pcie_ep$tx_st_err0),
						 .tx_st_sop0(pciw_pcie_ep$tx_st_sop0),
						 .tx_st_valid0(pciw_pcie_ep$tx_st_valid0),
						 .pcie_tx_out(pciw_pcie_ep$pcie_tx_out),
						 .ava_alive(pciw_pcie_ep$ava_alive),
						 .ava_lnk_up(pciw_pcie_ep$ava_lnk_up),
						 .rx_st_valid0(pciw_pcie_ep$rx_st_valid0),
						 .rx_st_bardec0(pciw_pcie_ep$rx_st_bardec0),
						 .rx_st_be0(pciw_pcie_ep$rx_st_be0),
						 .rx_st_data0(pciw_pcie_ep$rx_st_data0),
						 .rx_st_sop0(pciw_pcie_ep$rx_st_sop0),
						 .rx_st_eop0(pciw_pcie_ep$rx_st_eop0),
						 .rx_st_empty0(),
						 .rx_st_err0(),
						 .tx_st_ready0(pciw_pcie_ep$tx_st_ready0),
						 .tx_cred0(),
						 .tx_fifo_empty0(),
						 .ava_core_clk_out(pciw_pcie_ep$ava_core_clk_out),
						 .ava_srstn(pciw_pcie_ep$ava_srstn));

  // submodule pciw_rxOutF
  FIFO2 #(.width(32'd153),
	  .guarded(32'd1)) pciw_rxOutF(.RST_N(pciw_pcie_ep$ava_srstn),
				       .CLK(pciw_pcie_ep$ava_core_clk_out),
				       .D_IN(pciw_rxOutF$D_IN),
				       .ENQ(pciw_rxOutF$ENQ),
				       .DEQ(pciw_rxOutF$DEQ),
				       .CLR(pciw_rxOutF$CLR),
				       .D_OUT(),
				       .FULL_N(pciw_rxOutF$FULL_N),
				       .EMPTY_N());

  // submodule pciw_rxStageF
  FIFO1 #(.width(32'd153),
	  .guarded(32'd1)) pciw_rxStageF(.RST_N(pciw_pcie_ep$ava_srstn),
					 .CLK(pciw_pcie_ep$ava_core_clk_out),
					 .D_IN(pciw_rxStageF$D_IN),
					 .ENQ(pciw_rxStageF$ENQ),
					 .DEQ(pciw_rxStageF$DEQ),
					 .CLR(pciw_rxStageF$CLR),
					 .D_OUT(pciw_rxStageF$D_OUT),
					 .FULL_N(pciw_rxStageF$FULL_N),
					 .EMPTY_N(pciw_rxStageF$EMPTY_N));

  // submodule pciw_txInF
  FIFO2 #(.width(32'd153),
	  .guarded(32'd1)) pciw_txInF(.RST_N(pciw_pcie_ep$ava_srstn),
				      .CLK(pciw_pcie_ep$ava_core_clk_out),
				      .D_IN(pciw_txInF$D_IN),
				      .ENQ(pciw_txInF$ENQ),
				      .DEQ(pciw_txInF$DEQ),
				      .CLR(pciw_txInF$CLR),
				      .D_OUT(pciw_txInF$D_OUT),
				      .FULL_N(),
				      .EMPTY_N(pciw_txInF$EMPTY_N));

  // submodule pciw_txStageF
  FIFO1 #(.width(32'd153),
	  .guarded(32'd1)) pciw_txStageF(.RST_N(pciw_pcie_ep$ava_srstn),
					 .CLK(pciw_pcie_ep$ava_core_clk_out),
					 .D_IN(pciw_txStageF$D_IN),
					 .ENQ(pciw_txStageF$ENQ),
					 .DEQ(pciw_txStageF$DEQ),
					 .CLR(pciw_txStageF$CLR),
					 .D_OUT(pciw_txStageF$D_OUT),
					 .FULL_N(pciw_txStageF$FULL_N),
					 .EMPTY_N(pciw_txStageF$EMPTY_N));

  // rule RL_pciw_rx_enstage
  assign WILL_FIRE_RL_pciw_rx_enstage =
	     IF_pciw_rxSerPos_EQ_0_AND_NOT_pciw_pcie_ep_ava_ETC___d13 &&
	     pciw_pcie_ep$rx_st_valid0 &&
	     !pciw_rxStageF$EMPTY_N ;

  // rule RL_pciw_rx_destage
  assign WILL_FIRE_RL_pciw_rx_destage =
	     pciw_rxOutF$FULL_N && pciw_rxStageF$EMPTY_N &&
	     pciw_pcie_ep$rx_st_valid0 ;

  // rule RL_pciw_tx_enstage
  assign WILL_FIRE_RL_pciw_tx_enstage =
	     pciw_txInF$EMPTY_N &&
	     (!pciw_txInF$D_OUT[152] || pciw_txInF$D_OUT[34] ||
	      pciw_txStageF$FULL_N) &&
	     pciw_pcie_ep$tx_st_ready0 &&
	     !pciw_txStageF$EMPTY_N ;

  // rule RL_pciw_tx_destage
  assign WILL_FIRE_RL_pciw_tx_destage =
	     pciw_txInF$EMPTY_N && pciw_txStageF$EMPTY_N &&
	     pciw_pcie_ep$tx_st_ready0 ;

  // inputs to muxes for submodule ports
  assign MUX_pciw_rxOutF$enq_1__SEL_1 =
	     WILL_FIRE_RL_pciw_rx_enstage && pciw_rxSerPos == 2'd0 &&
	     (!pciw_pcie_ep$rx_st_sop0 || pciw_pcie_ep$rx_st_data0[34]) ;
  assign MUX_pciw_rxSerPos$write_1__SEL_1 =
	     WILL_FIRE_RL_pciw_rx_enstage &&
	     (pciw_rxSerPos != 2'd0 ||
	      pciw_pcie_ep$rx_st_sop0 && !pciw_pcie_ep$rx_st_data0[34]) ;
  assign MUX_pciw_pcie_ep$ava_tx_data_1__VAL_1 =
	     (!pciw_txInF$D_OUT[152] || pciw_txInF$D_OUT[34]) ?
	       data__h1754 :
	       y_avValue_snd__h1590 ;
  assign MUX_pciw_pcie_ep$ava_tx_data_1__VAL_2 =
	     { pciw_txInF$D_OUT[31:0],
	       pciw_txInF$D_OUT[63:32],
	       pciw_txInF$D_OUT[95:64],
	       pciw_txStageF$D_OUT[127:96] } ;
  assign MUX_pciw_rxOutF$enq_1__VAL_1 =
	     { pciw_pcie_ep$rx_st_sop0,
	       pciw_pcie_ep$rx_st_eop0,
	       pciw_pcie_ep$rx_st_bardec0[6:0],
	       pciw_pcie_ep$rx_st_be0,
	       pciw_pcie_ep$rx_st_data0 } ;
  assign MUX_pciw_rxOutF$enq_1__VAL_2 =
	     { pciw_pcie_ep$rx_st_sop0,
	       pciw_pcie_ep$rx_st_eop0,
	       pciw_pcie_ep$rx_st_bardec0[6:0],
	       be__h1193,
	       data__h1194 } ;
  assign MUX_pciw_rxSerPos$write_1__VAL_1 = pciw_rxSerPos + 2'd3 ;

  // inlined wires
  assign pciw_pwAvaTx$whas =
	     WILL_FIRE_RL_pciw_tx_destage || WILL_FIRE_RL_pciw_tx_enstage ;
  assign pciw_pwAvaRx$whas =
	     WILL_FIRE_RL_pciw_rx_destage || WILL_FIRE_RL_pciw_rx_enstage ;

  // register freeCnt
  assign freeCnt$D_IN = freeCnt + 32'd1 ;
  assign freeCnt$EN = 1'd1 ;

  // register pciw_rxSerPos
  assign pciw_rxSerPos$D_IN =
	     MUX_pciw_rxSerPos$write_1__SEL_1 ?
	       MUX_pciw_rxSerPos$write_1__VAL_1 :
	       2'd0 ;
  assign pciw_rxSerPos$EN =
	     MUX_pciw_rxSerPos$write_1__SEL_1 ||
	     WILL_FIRE_RL_pciw_rx_destage && pciw_pcie_ep$rx_st_eop0 ;

  // register pciw_txHeadPushed
  assign pciw_txHeadPushed$D_IN = 1'd0 ;
  assign pciw_txHeadPushed$EN =
	     WILL_FIRE_RL_pciw_tx_enstage && pciw_txInF$D_OUT[151] &&
	     (!pciw_txInF$D_OUT[152] || pciw_txInF$D_OUT[34]) ||
	     WILL_FIRE_RL_pciw_tx_destage && pciw_txInF$D_OUT[151] ;

  // register pciw_txSerPos
  assign pciw_txSerPos$D_IN = 2'd0 ;
  assign pciw_txSerPos$EN =
	     WILL_FIRE_RL_pciw_tx_enstage && pciw_txInF$D_OUT[151] &&
	     (!pciw_txInF$D_OUT[152] || pciw_txInF$D_OUT[34]) ||
	     WILL_FIRE_RL_pciw_tx_destage && pciw_txInF$D_OUT[151] ;

  // register swReg
  assign swReg$D_IN = usr_sw_i ;
  assign swReg$EN = 1'd1 ;

  // submodule aliveLed_sb
  assign aliveLed_sb$sD_IN = pciw_pcie_ep$ava_alive ;
  assign aliveLed_sb$sEN = 1'd1 ;

  // submodule linkLed_sb
  assign linkLed_sb$sD_IN = pciw_pcie_ep$ava_lnk_up ;
  assign linkLed_sb$sEN = 1'd1 ;

  // submodule pciw_pcie_ep
  assign pciw_pcie_ep$pcie_rx_in = pcie_rx_i ;
  assign pciw_pcie_ep$rx_st_mask0 = 1'b0 ;
  assign pciw_pcie_ep$rx_st_ready0 = pciw_pwAvaRx$whas ;
  assign pciw_pcie_ep$tx_st_data0 =
	     WILL_FIRE_RL_pciw_tx_enstage ?
	       MUX_pciw_pcie_ep$ava_tx_data_1__VAL_1 :
	       MUX_pciw_pcie_ep$ava_tx_data_1__VAL_2 ;
  assign pciw_pcie_ep$tx_st_empty0 = 1'd0 ;
  assign pciw_pcie_ep$tx_st_eop0 = pciw_txInF$D_OUT[151] ;
  assign pciw_pcie_ep$tx_st_err0 = 1'b0 ;
  assign pciw_pcie_ep$tx_st_sop0 = pciw_txInF$D_OUT[152] ;
  assign pciw_pcie_ep$tx_st_valid0 = pciw_pwAvaTx$whas ;

  // submodule pciw_rxOutF
  assign pciw_rxOutF$D_IN =
	     MUX_pciw_rxOutF$enq_1__SEL_1 ?
	       MUX_pciw_rxOutF$enq_1__VAL_1 :
	       MUX_pciw_rxOutF$enq_1__VAL_2 ;
  assign pciw_rxOutF$ENQ =
	     WILL_FIRE_RL_pciw_rx_enstage && pciw_rxSerPos == 2'd0 &&
	     (!pciw_pcie_ep$rx_st_sop0 || pciw_pcie_ep$rx_st_data0[34]) ||
	     WILL_FIRE_RL_pciw_rx_destage ;
  assign pciw_rxOutF$DEQ = 1'b0 ;
  assign pciw_rxOutF$CLR = 1'b0 ;

  // submodule pciw_rxStageF
  assign pciw_rxStageF$D_IN = MUX_pciw_rxOutF$enq_1__VAL_1 ;
  assign pciw_rxStageF$ENQ = MUX_pciw_rxSerPos$write_1__SEL_1 ;
  assign pciw_rxStageF$DEQ = WILL_FIRE_RL_pciw_rx_destage ;
  assign pciw_rxStageF$CLR = 1'b0 ;

  // submodule pciw_txInF
  assign pciw_txInF$D_IN = 153'h0 ;
  assign pciw_txInF$ENQ = 1'b0 ;
  assign pciw_txInF$DEQ = pciw_pwAvaTx$whas ;
  assign pciw_txInF$CLR = 1'b0 ;

  // submodule pciw_txStageF
  assign pciw_txStageF$D_IN = pciw_txInF$D_OUT ;
  assign pciw_txStageF$ENQ =
	     WILL_FIRE_RL_pciw_tx_enstage && pciw_txInF$D_OUT[152] &&
	     !pciw_txInF$D_OUT[34] ;
  assign pciw_txStageF$DEQ = WILL_FIRE_RL_pciw_tx_destage ;
  assign pciw_txStageF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_pciw_rxSerPos_EQ_0_AND_NOT_pciw_pcie_ep_ava_ETC___d13 =
	     (pciw_rxSerPos == 2'd0 &&
	      (!pciw_pcie_ep$rx_st_sop0 || pciw_pcie_ep$rx_st_data0[34])) ?
	       pciw_rxOutF$FULL_N :
	       pciw_rxStageF$FULL_N ;
  assign be__h1193 =
	     { pciw_pcie_ep$rx_st_be0[3:0], pciw_rxStageF$D_OUT[139:128] } ;
  assign data__h1194 =
	     { pciw_pcie_ep$rx_st_data0[15:0], pciw_rxStageF$D_OUT[111:0] } ;
  assign data__h1754 =
	     { pciw_txInF$D_OUT[31:0],
	       pciw_txInF$D_OUT[63:32],
	       pciw_txInF$D_OUT[95:64],
	       pciw_txInF$D_OUT[127:96] } ;
  assign swParity__h135 = z__h5845 ^ swReg[7] ;
  assign y_avValue_snd__h1590 =
	     { 16'h0,
	       pciw_txInF$D_OUT[15:0],
	       pciw_txInF$D_OUT[63:32],
	       pciw_txInF$D_OUT[95:64],
	       pciw_txInF$D_OUT[127:96] } ;
  assign z__h5810 = swReg[0] ^ swReg[1] ;
  assign z__h5817 = z__h5810 ^ swReg[2] ;
  assign z__h5824 = z__h5817 ^ swReg[3] ;
  assign z__h5831 = z__h5824 ^ swReg[4] ;
  assign z__h5838 = z__h5831 ^ swReg[5] ;
  assign z__h5845 = z__h5838 ^ swReg[6] ;

  // handling of inlined registers

  always@(posedge sys0_clk)
  begin
    if (!sys0_rstn)
      begin
        freeCnt <= `BSV_ASSIGNMENT_DELAY 32'd0;
	swReg <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (freeCnt$EN) freeCnt <= `BSV_ASSIGNMENT_DELAY freeCnt$D_IN;
	if (swReg$EN) swReg <= `BSV_ASSIGNMENT_DELAY swReg$D_IN;
      end
  end

  always@(posedge pciw_pcie_ep$ava_core_clk_out)
  begin
    if (!pciw_pcie_ep$ava_srstn)
      begin
        pciw_rxSerPos <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pciw_txHeadPushed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pciw_txSerPos <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (pciw_rxSerPos$EN)
	  pciw_rxSerPos <= `BSV_ASSIGNMENT_DELAY pciw_rxSerPos$D_IN;
	if (pciw_txHeadPushed$EN)
	  pciw_txHeadPushed <= `BSV_ASSIGNMENT_DELAY pciw_txHeadPushed$D_IN;
	if (pciw_txSerPos$EN)
	  pciw_txSerPos <= `BSV_ASSIGNMENT_DELAY pciw_txSerPos$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    freeCnt = 32'hAAAAAAAA;
    pciw_rxSerPos = 2'h2;
    pciw_txHeadPushed = 1'h0;
    pciw_txSerPos = 2'h2;
    swReg = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFTop_alst4

