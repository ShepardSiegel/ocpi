//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Tue Feb 28 16:22:43 EST 2012
//
//
// Ports:
// Name                         I/O  size props
// rxf_get                        O    12 reg
// RDY_rxf_get                    O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// gmii_rxd_i                     I     8 reg
// gmii_rx_dv_i                   I     1 reg
// gmii_rx_er_i                   I     1 reg
// EN_rxf_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkRxRS(CLK,
	      RST_N,

	      gmii_rxd_i,

	      gmii_rx_dv_i,

	      gmii_rx_er_i,

	      EN_rxf_get,
	      rxf_get,
	      RDY_rxf_get);
  input  CLK;
  input  RST_N;

  // action method gmii_rxd
  input  [7 : 0] gmii_rxd_i;

  // action method gmii_rx_dv
  input  gmii_rx_dv_i;

  // action method gmii_rx_er
  input  gmii_rx_er_i;

  // actionvalue method rxf_get
  input  EN_rxf_get;
  output [11 : 0] rxf_get;
  output RDY_rxf_get;

  // signals for module outputs
  wire [11 : 0] rxf_get;
  wire RDY_rxf_get;

  // inlined wires
  wire [1 : 0] eof_1$wget;
  wire crcDbgCnt_decAction$whas,
       crcDbgCnt_incAction$whas,
       eof_1$whas,
       preambleCnt_decAction$whas,
       preambleCnt_incAction$whas;

  // register crcDbgCnt_value
  reg [11 : 0] crcDbgCnt_value;
  wire [11 : 0] crcDbgCnt_value$D_IN;
  wire crcDbgCnt_value$EN;

  // register crcEnd
  reg crcEnd;
  wire crcEnd$D_IN, crcEnd$EN;

  // register eof
  reg [1 : 0] eof;
  wire [1 : 0] eof$D_IN;
  wire eof$EN;

  // register isSOF
  reg isSOF;
  wire isSOF$D_IN, isSOF$EN;

  // register preambleCnt_value
  reg [3 : 0] preambleCnt_value;
  wire [3 : 0] preambleCnt_value$D_IN;
  wire preambleCnt_value$EN;

  // register rxAPipe
  reg [5 : 0] rxAPipe;
  wire [5 : 0] rxAPipe$D_IN;
  wire rxAPipe$EN;

  // register rxActive
  reg rxActive;
  wire rxActive$D_IN, rxActive$EN;

  // register rxDV
  reg rxDV;
  wire rxDV$D_IN, rxDV$EN;

  // register rxDVD
  reg rxDVD;
  wire rxDVD$D_IN, rxDVD$EN;

  // register rxDVD2
  reg rxDVD2;
  wire rxDVD2$D_IN, rxDVD2$EN;

  // register rxData
  reg [7 : 0] rxData;
  wire [7 : 0] rxData$D_IN;
  wire rxData$EN;

  // register rxER
  reg rxER;
  wire rxER$D_IN, rxER$EN;

  // register rxPipe
  reg [47 : 0] rxPipe;
  wire [47 : 0] rxPipe$D_IN;
  wire rxPipe$EN;

  // ports of submodule crc
  wire [31 : 0] crc$complete;
  wire [7 : 0] crc$add_data;
  wire crc$EN_add, crc$EN_clear, crc$EN_complete;

  // ports of submodule rxF
  wire [11 : 0] rxF$D_IN, rxF$D_OUT;
  wire rxF$CLR, rxF$DEQ, rxF$EMPTY_N, rxF$ENQ, rxF$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_crcDbgCnt_ruleInc, WILL_FIRE_RL_egress_data;

  // inputs to muxes for submodule ports
  wire [11 : 0] MUX_crcDbgCnt_value$write_1__VAL_1,
		MUX_rxF$enq_1__VAL_1,
		MUX_rxF$enq_1__VAL_2;
  wire [5 : 0] MUX_rxAPipe$write_1__VAL_2;
  wire [3 : 0] MUX_preambleCnt_value$write_1__VAL_3;
  wire MUX_crcDbgCnt_value$write_1__SEL_3, MUX_rxF$enq_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h6006;
  wire crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d83;

  // actionvalue method rxf_get
  assign rxf_get = rxF$D_OUT ;
  assign RDY_rxf_get = rxF$EMPTY_N ;

  // submodule crc
  mkCRC32 crc(.CLK(CLK),
	      .RST_N(RST_N),
	      .add_data(crc$add_data),
	      .EN_add(crc$EN_add),
	      .EN_clear(crc$EN_clear),
	      .EN_complete(crc$EN_complete),
	      .RDY_add(),
	      .RDY_clear(),
	      .result(),
	      .RDY_result(),
	      .complete(crc$complete),
	      .RDY_complete());

  // submodule rxF
  FIFO2 #(.width(32'd12), .guarded(32'd1)) rxF(.RST_N(RST_N),
					       .CLK(CLK),
					       .D_IN(rxF$D_IN),
					       .ENQ(rxF$ENQ),
					       .DEQ(rxF$DEQ),
					       .CLR(rxF$CLR),
					       .D_OUT(rxF$D_OUT),
					       .FULL_N(rxF$FULL_N),
					       .EMPTY_N(rxF$EMPTY_N));

  // rule RL_egress_data
  assign WILL_FIRE_RL_egress_data = rxF$FULL_N && rxDVD && rxAPipe[5] ;

  // rule RL_crcDbgCnt_ruleInc
  assign WILL_FIRE_RL_crcDbgCnt_ruleInc =
	     crcDbgCnt_incAction$whas && !MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // inputs to muxes for submodule ports
  assign MUX_crcDbgCnt_value$write_1__SEL_3 =
	     (!rxActive || rxF$FULL_N) && !rxDVD && rxAPipe[0] &&
	     rxAPipe[1] &&
	     rxAPipe[2] &&
	     rxAPipe[3] &&
	     rxAPipe[4] &&
	     rxAPipe[5] &&
	     !crcEnd ;
  assign MUX_rxF$enq_1__SEL_1 =
	     MUX_crcDbgCnt_value$write_1__SEL_3 && rxActive ;
  assign MUX_crcDbgCnt_value$write_1__VAL_1 =
	     (crcDbgCnt_value == 12'd4095) ?
	       crcDbgCnt_value :
	       crcDbgCnt_value + 12'd1 ;
  assign MUX_preambleCnt_value$write_1__VAL_3 =
	     (preambleCnt_value == 4'd15) ?
	       preambleCnt_value :
	       preambleCnt_value + 4'd1 ;
  assign MUX_rxAPipe$write_1__VAL_2 = { rxAPipe[4:0], rxActive } ;
  assign MUX_rxF$enq_1__VAL_1 =
	     { !crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d83,
	       2'd0,
	       crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d83,
	       rxPipe[39:32] } ;
  assign MUX_rxF$enq_1__VAL_2 = { 2'd0, isSOF, 1'd0, rxPipe[47:40] } ;

  // inlined wires
  assign eof_1$wget =
	     crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d83 ? 2'd1 : 2'd2 ;
  assign eof_1$whas = MUX_rxF$enq_1__SEL_1 ;
  assign preambleCnt_incAction$whas = rxDV && rxData == 8'd85 ;
  assign preambleCnt_decAction$whas = 1'b0 ;
  assign crcDbgCnt_incAction$whas = rxDV && rxAPipe[3] ;
  assign crcDbgCnt_decAction$whas = 1'b0 ;

  // register crcDbgCnt_value
  assign crcDbgCnt_value$D_IN =
	     WILL_FIRE_RL_crcDbgCnt_ruleInc ?
	       MUX_crcDbgCnt_value$write_1__VAL_1 :
	       12'd0 ;
  assign crcDbgCnt_value$EN =
	     WILL_FIRE_RL_crcDbgCnt_ruleInc ||
	     MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // register crcEnd
  assign crcEnd$D_IN = !crcEnd ;
  assign crcEnd$EN = crcEnd || MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // register eof
  assign eof$D_IN = MUX_rxF$enq_1__SEL_1 ? eof_1$wget : 2'd0 ;
  assign eof$EN = 1'd1 ;

  // register isSOF
  assign isSOF$D_IN = crcEnd ;
  assign isSOF$EN = WILL_FIRE_RL_egress_data || crcEnd ;

  // register preambleCnt_value
  assign preambleCnt_value$D_IN =
	     crcEnd ? 4'd0 : MUX_preambleCnt_value$write_1__VAL_3 ;
  assign preambleCnt_value$EN = preambleCnt_incAction$whas || crcEnd ;

  // register rxAPipe
  assign rxAPipe$D_IN = crcEnd ? 6'd0 : MUX_rxAPipe$write_1__VAL_2 ;
  assign rxAPipe$EN = rxDV || crcEnd ;

  // register rxActive
  assign rxActive$D_IN = !crcEnd ;
  assign rxActive$EN =
	     rxDV && preambleCnt_value > 4'd6 && rxData == 8'd213 || crcEnd ;

  // register rxDV
  assign rxDV$D_IN = gmii_rx_dv_i ;
  assign rxDV$EN = 1'd1 ;

  // register rxDVD
  assign rxDVD$D_IN = rxDV ;
  assign rxDVD$EN = 1'd1 ;

  // register rxDVD2
  assign rxDVD2$D_IN = rxDVD ;
  assign rxDVD2$EN = 1'd1 ;

  // register rxData
  assign rxData$D_IN = gmii_rxd_i ;
  assign rxData$EN = 1'd1 ;

  // register rxER
  assign rxER$D_IN = gmii_rx_er_i ;
  assign rxER$EN = 1'd1 ;

  // register rxPipe
  assign rxPipe$D_IN = { rxPipe[39:0], rxData } ;
  assign rxPipe$EN = rxDV ;

  // submodule crc
  assign crc$add_data = rxPipe[31:24] ;
  assign crc$EN_add = rxDV && rxAPipe[3] ;
  assign crc$EN_clear = 1'b0 ;
  assign crc$EN_complete = MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // submodule rxF
  assign rxF$D_IN =
	     MUX_rxF$enq_1__SEL_1 ?
	       MUX_rxF$enq_1__VAL_1 :
	       MUX_rxF$enq_1__VAL_2 ;
  assign rxF$ENQ =
	     MUX_crcDbgCnt_value$write_1__SEL_3 && rxActive ||
	     WILL_FIRE_RL_egress_data ;
  assign rxF$DEQ = EN_rxf_get ;
  assign rxF$CLR = 1'b0 ;

  // remaining internal signals
  assign crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d83 =
	     crc$complete == rxPipe[31:0] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	crcEnd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	eof <= `BSV_ASSIGNMENT_DELAY 2'd0;
	isSOF <= `BSV_ASSIGNMENT_DELAY 1'd1;
	preambleCnt_value <= `BSV_ASSIGNMENT_DELAY 4'd0;
	rxAPipe <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rxActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDVD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDVD2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxER <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (crcDbgCnt_value$EN)
	  crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY crcDbgCnt_value$D_IN;
	if (crcEnd$EN) crcEnd <= `BSV_ASSIGNMENT_DELAY crcEnd$D_IN;
	if (eof$EN) eof <= `BSV_ASSIGNMENT_DELAY eof$D_IN;
	if (isSOF$EN) isSOF <= `BSV_ASSIGNMENT_DELAY isSOF$D_IN;
	if (preambleCnt_value$EN)
	  preambleCnt_value <= `BSV_ASSIGNMENT_DELAY preambleCnt_value$D_IN;
	if (rxAPipe$EN) rxAPipe <= `BSV_ASSIGNMENT_DELAY rxAPipe$D_IN;
	if (rxActive$EN) rxActive <= `BSV_ASSIGNMENT_DELAY rxActive$D_IN;
	if (rxDV$EN) rxDV <= `BSV_ASSIGNMENT_DELAY rxDV$D_IN;
	if (rxDVD$EN) rxDVD <= `BSV_ASSIGNMENT_DELAY rxDVD$D_IN;
	if (rxDVD2$EN) rxDVD2 <= `BSV_ASSIGNMENT_DELAY rxDVD2$D_IN;
	if (rxER$EN) rxER <= `BSV_ASSIGNMENT_DELAY rxER$D_IN;
      end
    if (rxData$EN) rxData <= `BSV_ASSIGNMENT_DELAY rxData$D_IN;
    if (rxPipe$EN) rxPipe <= `BSV_ASSIGNMENT_DELAY rxPipe$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    crcDbgCnt_value = 12'hAAA;
    crcEnd = 1'h0;
    eof = 2'h2;
    isSOF = 1'h0;
    preambleCnt_value = 4'hA;
    rxAPipe = 6'h2A;
    rxActive = 1'h0;
    rxDV = 1'h0;
    rxDVD = 1'h0;
    rxDVD2 = 1'h0;
    rxData = 8'hAA;
    rxER = 1'h0;
    rxPipe = 48'hAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (MUX_crcDbgCnt_value$write_1__SEL_3)
	begin
	  v__h6006 = $time;
	  #0;
	end
    if (RST_N)
      if (MUX_crcDbgCnt_value$write_1__SEL_3)
	$display("[%0d]: %m: RX FCS:%08x from %d elements",
		 v__h6006,
		 crc$complete,
		 $unsigned(crcDbgCnt_value));
  end
  // synopsys translate_on
endmodule  // mkRxRS

