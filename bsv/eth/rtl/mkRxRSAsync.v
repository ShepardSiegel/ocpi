//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Mar  2 13:59:14 EST 2012
//
//
// Ports:
// Name                         I/O  size props
// rxf_get                        O    10
// RDY_rxf_get                    O     1
// CLK_rxClk                      I     1 clock
// CLK                            I     1 clock
// RST_N                          I     1 reset
// gmii_rxd_i                     I     8 reg
// gmii_rx_dv_i                   I     1 reg
// gmii_rx_er_i                   I     1 reg
// EN_rxf_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkRxRSAsync(CLK_rxClk,
		   CLK,
		   RST_N,

		   gmii_rxd_i,

		   gmii_rx_dv_i,

		   gmii_rx_er_i,

		   EN_rxf_get,
		   rxf_get,
		   RDY_rxf_get);
  input  CLK_rxClk;
  input  CLK;
  input  RST_N;

  // action method gmii_rxd
  input  [7 : 0] gmii_rxd_i;

  // action method gmii_rx_dv
  input  gmii_rx_dv_i;

  // action method gmii_rx_er
  input  gmii_rx_er_i;

  // actionvalue method rxf_get
  input  EN_rxf_get;
  output [9 : 0] rxf_get;
  output RDY_rxf_get;

  // signals for module outputs
  wire [9 : 0] rxf_get;
  wire RDY_rxf_get;

  // inlined wires
  wire [1 : 0] eof_1$wget;
  wire crcDbgCnt_decAction$whas,
       crcDbgCnt_incAction$whas,
       eof_1$whas,
       preambleCnt_decAction$whas,
       preambleCnt_incAction$whas;

  // register crcDbgCnt_value
  reg [11 : 0] crcDbgCnt_value;
  wire [11 : 0] crcDbgCnt_value$D_IN;
  wire crcDbgCnt_value$EN;

  // register crcEnd
  reg crcEnd;
  wire crcEnd$D_IN, crcEnd$EN;

  // register eof
  reg [1 : 0] eof;
  wire [1 : 0] eof$D_IN;
  wire eof$EN;

  // register isSOF
  reg isSOF;
  wire isSOF$D_IN, isSOF$EN;

  // register preambleCnt_value
  reg [3 : 0] preambleCnt_value;
  wire [3 : 0] preambleCnt_value$D_IN;
  wire preambleCnt_value$EN;

  // register rxAPipe
  reg [5 : 0] rxAPipe;
  wire [5 : 0] rxAPipe$D_IN;
  wire rxAPipe$EN;

  // register rxActive
  reg rxActive;
  wire rxActive$D_IN, rxActive$EN;

  // register rxDV
  reg rxDV;
  wire rxDV$D_IN, rxDV$EN;

  // register rxDVD
  reg rxDVD;
  wire rxDVD$D_IN, rxDVD$EN;

  // register rxDVD2
  reg rxDVD2;
  wire rxDVD2$D_IN, rxDVD2$EN;

  // register rxData
  reg [7 : 0] rxData;
  wire [7 : 0] rxData$D_IN;
  wire rxData$EN;

  // register rxER
  reg rxER;
  wire rxER$D_IN, rxER$EN;

  // register rxPipe
  reg [47 : 0] rxPipe;
  wire [47 : 0] rxPipe$D_IN;
  wire rxPipe$EN;

  // ports of submodule crc
  wire [31 : 0] crc$complete;
  wire [7 : 0] crc$add_data;
  wire crc$EN_add, crc$EN_clear, crc$EN_complete;

  // ports of submodule rxF
  wire [9 : 0] rxF$dD_OUT, rxF$sD_IN;
  wire rxF$dDEQ, rxF$dEMPTY_N, rxF$sENQ, rxF$sFULL_N;

  // ports of submodule rxRst
  wire rxRst$OUT_RST_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_crcDbgCnt_ruleInc;

  // inputs to muxes for submodule ports
  wire [11 : 0] MUX_crcDbgCnt_value$write_1__VAL_1;
  wire [9 : 0] MUX_rxF$enq_1__VAL_1, MUX_rxF$enq_1__VAL_2;
  wire [5 : 0] MUX_rxAPipe$write_1__VAL_2;
  wire [3 : 0] MUX_preambleCnt_value$write_1__VAL_3;
  wire MUX_crcDbgCnt_value$write_1__SEL_3,
       MUX_isSOF$write_1__SEL_2,
       MUX_rxF$enq_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h6218;
  reg [1 : 0] CASE_rxFdD_OUT_BITS_9_TO_8_3_0_rxFdD_OUT_BIT_ETC__q1;
  wire crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d106;

  // actionvalue method rxf_get
  assign rxf_get =
	     { CASE_rxFdD_OUT_BITS_9_TO_8_3_0_rxFdD_OUT_BIT_ETC__q1,
	       rxF$dD_OUT[7:0] } ;
  assign RDY_rxf_get = rxF$dEMPTY_N ;

  // submodule crc
  mkCRC32 crc(.CLK(CLK_rxClk),
	      .RST_N(rxRst$OUT_RST_N),
	      .add_data(crc$add_data),
	      .EN_add(crc$EN_add),
	      .EN_clear(crc$EN_clear),
	      .EN_complete(crc$EN_complete),
	      .RDY_add(),
	      .RDY_clear(),
	      .result(),
	      .RDY_result(),
	      .complete(crc$complete),
	      .RDY_complete());

  // submodule rxF
  SyncFIFO #(.dataWidth(32'd10),
	     .depth(32'd4),
	     .indxWidth(32'd2)) rxF(.sCLK(CLK_rxClk),
				    .dCLK(CLK),
				    .sRST_N(rxRst$OUT_RST_N),
				    .sD_IN(rxF$sD_IN),
				    .sENQ(rxF$sENQ),
				    .dDEQ(rxF$dDEQ),
				    .dD_OUT(rxF$dD_OUT),
				    .sFULL_N(rxF$sFULL_N),
				    .dEMPTY_N(rxF$dEMPTY_N));

  // submodule rxRst
  SyncResetA #(.RSTDELAY(32'd1)) rxRst(.CLK(CLK_rxClk),
				       .IN_RST_N(RST_N),
				       .OUT_RST_N(rxRst$OUT_RST_N));

  // rule RL_crcDbgCnt_ruleInc
  assign WILL_FIRE_RL_crcDbgCnt_ruleInc =
	     crcDbgCnt_incAction$whas && !MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // inputs to muxes for submodule ports
  assign MUX_crcDbgCnt_value$write_1__SEL_3 =
	     (!rxActive || rxF$sFULL_N) && !rxDVD && rxAPipe[0] &&
	     rxAPipe[1] &&
	     rxAPipe[2] &&
	     rxAPipe[3] &&
	     rxAPipe[4] &&
	     rxAPipe[5] &&
	     !crcEnd ;
  assign MUX_isSOF$write_1__SEL_2 = rxF$sFULL_N && rxDVD && rxAPipe[5] ;
  assign MUX_rxF$enq_1__SEL_1 =
	     MUX_crcDbgCnt_value$write_1__SEL_3 && rxActive ;
  assign MUX_crcDbgCnt_value$write_1__VAL_1 =
	     (crcDbgCnt_value == 12'd4095) ?
	       crcDbgCnt_value :
	       crcDbgCnt_value + 12'd1 ;
  assign MUX_preambleCnt_value$write_1__VAL_3 =
	     (preambleCnt_value == 4'd15) ?
	       preambleCnt_value :
	       preambleCnt_value + 4'd1 ;
  assign MUX_rxAPipe$write_1__VAL_2 = { rxAPipe[4:0], rxActive } ;
  assign MUX_rxF$enq_1__VAL_1 =
	     crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d106 ?
	       { 2'd1, rxPipe[39:32] } :
	       { 2'd3, rxPipe[39:32] } ;
  assign MUX_rxF$enq_1__VAL_2 = { 2'd0, rxPipe[47:40] } ;

  // inlined wires
  assign eof_1$wget =
	     crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d106 ? 2'd1 : 2'd2 ;
  assign eof_1$whas = MUX_rxF$enq_1__SEL_1 ;
  assign preambleCnt_incAction$whas = rxDV && rxData == 8'd85 ;
  assign preambleCnt_decAction$whas = 1'b0 ;
  assign crcDbgCnt_incAction$whas = rxDV && rxAPipe[3] ;
  assign crcDbgCnt_decAction$whas = 1'b0 ;

  // register crcDbgCnt_value
  assign crcDbgCnt_value$D_IN =
	     WILL_FIRE_RL_crcDbgCnt_ruleInc ?
	       MUX_crcDbgCnt_value$write_1__VAL_1 :
	       12'd0 ;
  assign crcDbgCnt_value$EN =
	     WILL_FIRE_RL_crcDbgCnt_ruleInc ||
	     MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // register crcEnd
  assign crcEnd$D_IN = !crcEnd ;
  assign crcEnd$EN = crcEnd || MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // register eof
  assign eof$D_IN = MUX_rxF$enq_1__SEL_1 ? eof_1$wget : 2'd0 ;
  assign eof$EN = 1'd1 ;

  // register isSOF
  assign isSOF$D_IN = crcEnd ;
  assign isSOF$EN = MUX_isSOF$write_1__SEL_2 || crcEnd ;

  // register preambleCnt_value
  assign preambleCnt_value$D_IN =
	     crcEnd ? 4'd0 : MUX_preambleCnt_value$write_1__VAL_3 ;
  assign preambleCnt_value$EN = preambleCnt_incAction$whas || crcEnd ;

  // register rxAPipe
  assign rxAPipe$D_IN = crcEnd ? 6'd0 : MUX_rxAPipe$write_1__VAL_2 ;
  assign rxAPipe$EN = rxDV || crcEnd ;

  // register rxActive
  assign rxActive$D_IN = !crcEnd ;
  assign rxActive$EN =
	     rxDV && preambleCnt_value > 4'd6 && rxData == 8'd213 || crcEnd ;

  // register rxDV
  assign rxDV$D_IN = gmii_rx_dv_i ;
  assign rxDV$EN = 1'd1 ;

  // register rxDVD
  assign rxDVD$D_IN = rxDV ;
  assign rxDVD$EN = 1'd1 ;

  // register rxDVD2
  assign rxDVD2$D_IN = rxDVD ;
  assign rxDVD2$EN = 1'd1 ;

  // register rxData
  assign rxData$D_IN = gmii_rxd_i ;
  assign rxData$EN = 1'd1 ;

  // register rxER
  assign rxER$D_IN = gmii_rx_er_i ;
  assign rxER$EN = 1'd1 ;

  // register rxPipe
  assign rxPipe$D_IN = { rxPipe[39:0], rxData } ;
  assign rxPipe$EN = rxDV ;

  // submodule crc
  assign crc$add_data = rxPipe[31:24] ;
  assign crc$EN_add = rxDV && rxAPipe[3] ;
  assign crc$EN_clear = 1'b0 ;
  assign crc$EN_complete = MUX_crcDbgCnt_value$write_1__SEL_3 ;

  // submodule rxF
  assign rxF$sD_IN =
	     MUX_rxF$enq_1__SEL_1 ?
	       MUX_rxF$enq_1__VAL_1 :
	       MUX_rxF$enq_1__VAL_2 ;
  assign rxF$sENQ =
	     MUX_crcDbgCnt_value$write_1__SEL_3 && rxActive ||
	     MUX_isSOF$write_1__SEL_2 ;
  assign rxF$dDEQ = EN_rxf_get ;

  // remaining internal signals
  assign crc_complete_6_EQ_rxPipe_2_BITS_31_TO_0_8___d106 =
	     crc$complete == rxPipe[31:0] ;
  always@(rxF$dD_OUT)
  begin
    case (rxF$dD_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_rxFdD_OUT_BITS_9_TO_8_3_0_rxFdD_OUT_BIT_ETC__q1 =
	      rxF$dD_OUT[9:8];
      2'd3: CASE_rxFdD_OUT_BITS_9_TO_8_3_0_rxFdD_OUT_BIT_ETC__q1 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK_rxClk)
  begin
    if (!rxRst$OUT_RST_N)
      begin
        crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	crcEnd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	eof <= `BSV_ASSIGNMENT_DELAY 2'd0;
	isSOF <= `BSV_ASSIGNMENT_DELAY 1'd1;
	preambleCnt_value <= `BSV_ASSIGNMENT_DELAY 4'd0;
	rxAPipe <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rxActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDVD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxDVD2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxER <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (crcDbgCnt_value$EN)
	  crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY crcDbgCnt_value$D_IN;
	if (crcEnd$EN) crcEnd <= `BSV_ASSIGNMENT_DELAY crcEnd$D_IN;
	if (eof$EN) eof <= `BSV_ASSIGNMENT_DELAY eof$D_IN;
	if (isSOF$EN) isSOF <= `BSV_ASSIGNMENT_DELAY isSOF$D_IN;
	if (preambleCnt_value$EN)
	  preambleCnt_value <= `BSV_ASSIGNMENT_DELAY preambleCnt_value$D_IN;
	if (rxAPipe$EN) rxAPipe <= `BSV_ASSIGNMENT_DELAY rxAPipe$D_IN;
	if (rxActive$EN) rxActive <= `BSV_ASSIGNMENT_DELAY rxActive$D_IN;
	if (rxDV$EN) rxDV <= `BSV_ASSIGNMENT_DELAY rxDV$D_IN;
	if (rxDVD$EN) rxDVD <= `BSV_ASSIGNMENT_DELAY rxDVD$D_IN;
	if (rxDVD2$EN) rxDVD2 <= `BSV_ASSIGNMENT_DELAY rxDVD2$D_IN;
	if (rxER$EN) rxER <= `BSV_ASSIGNMENT_DELAY rxER$D_IN;
      end
    if (rxData$EN) rxData <= `BSV_ASSIGNMENT_DELAY rxData$D_IN;
    if (rxPipe$EN) rxPipe <= `BSV_ASSIGNMENT_DELAY rxPipe$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    crcDbgCnt_value = 12'hAAA;
    crcEnd = 1'h0;
    eof = 2'h2;
    isSOF = 1'h0;
    preambleCnt_value = 4'hA;
    rxAPipe = 6'h2A;
    rxActive = 1'h0;
    rxDV = 1'h0;
    rxDVD = 1'h0;
    rxDVD2 = 1'h0;
    rxData = 8'hAA;
    rxER = 1'h0;
    rxPipe = 48'hAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK_rxClk)
  begin
    #0;
    if (rxRst$OUT_RST_N)
      if (MUX_crcDbgCnt_value$write_1__SEL_3)
	begin
	  v__h6218 = $time;
	  #0;
	end
    if (rxRst$OUT_RST_N)
      if (MUX_crcDbgCnt_value$write_1__SEL_3)
	$display("[%0d]: %m: RX FCS:%08x from %d elements",
		 v__h6218,
		 crc$complete,
		 $unsigned(crcDbgCnt_value));
  end
  // synopsys translate_on
endmodule  // mkRxRSAsync

