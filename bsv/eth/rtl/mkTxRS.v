//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Feb 17 11:38:00 EST 2012
//
//
// Ports:
// Name                         I/O  size props
// RDY_txf_put                    O     1 reg
// txUnderflow                    O     1 reg
// RDY_txUnderflow                O     1 const
// gmii_txd                       O     8 reg
// gmii_tx_en                     O     1 reg
// gmii_tx_er                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// txf_put                        I    10
// EN_txf_put                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkTxRS(CLK,
	      RST_N,

	      txf_put,
	      EN_txf_put,
	      RDY_txf_put,

	      txUnderflow,
	      RDY_txUnderflow,

	      gmii_txd,

	      gmii_tx_en,

	      gmii_tx_er);
  input  CLK;
  input  RST_N;

  // action method txf_put
  input  [9 : 0] txf_put;
  input  EN_txf_put;
  output RDY_txf_put;

  // value method txUnderflow
  output txUnderflow;
  output RDY_txUnderflow;

  // value method gmii_txd
  output [7 : 0] gmii_txd;

  // value method gmii_tx_en
  output gmii_tx_en;

  // value method gmii_tx_er
  output gmii_tx_er;

  // signals for module outputs
  wire [7 : 0] gmii_txd;
  wire RDY_txUnderflow, RDY_txf_put, gmii_tx_en, gmii_tx_er, txUnderflow;

  // inlined wires
  reg [7 : 0] txData_1$wget;
  wire ifgCnt_decAction$whas,
       ifgCnt_incAction$whas,
       lenCnt_decAction$whas,
       lenCnt_incAction$whas,
       preambleCnt_decAction$whas,
       preambleCnt_incAction$whas,
       txDV_1$wget,
       txDV_1$whas,
       txData_1$whas,
       txER_1$wget,
       txER_1$whas,
       underflow_1$wget,
       underflow_1$whas;

  // register emitFCS
  reg [2 : 0] emitFCS;
  wire [2 : 0] emitFCS$D_IN;
  wire emitFCS$EN;

  // register ifgCnt_value
  reg [4 : 0] ifgCnt_value;
  wire [4 : 0] ifgCnt_value$D_IN;
  wire ifgCnt_value$EN;

  // register lenCnt_value
  reg [11 : 0] lenCnt_value;
  wire [11 : 0] lenCnt_value$D_IN;
  wire lenCnt_value$EN;

  // register preambleCnt_value
  reg [3 : 0] preambleCnt_value;
  wire [3 : 0] preambleCnt_value$D_IN;
  wire preambleCnt_value$EN;

  // register txActive
  reg txActive;
  wire txActive$D_IN, txActive$EN;

  // register txDV
  reg txDV;
  wire txDV$D_IN, txDV$EN;

  // register txData
  reg [7 : 0] txData;
  wire [7 : 0] txData$D_IN;
  wire txData$EN;

  // register txER
  reg txER;
  wire txER$D_IN, txER$EN;

  // register underflow
  reg underflow;
  wire underflow$D_IN, underflow$EN;

  // ports of submodule crc
  wire [31 : 0] crc$result;
  wire [7 : 0] crc$add_data;
  wire crc$EN_add, crc$EN_clear, crc$EN_complete;

  // ports of submodule txF
  wire [9 : 0] txF$D_IN, txF$D_OUT;
  wire txF$CLR, txF$DEQ, txF$EMPTY_N, txF$ENQ, txF$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_egress_Body,
       WILL_FIRE_RL_egress_EOF,
       WILL_FIRE_RL_egress_FCS,
       WILL_FIRE_RL_egress_SOF;

  // inputs to muxes for submodule ports
  reg [7 : 0] MUX_txData_1$wset_1__VAL_2;
  wire [11 : 0] MUX_lenCnt_value$write_1__VAL_1;
  wire [7 : 0] MUX_crc$add_1__VAL_3, MUX_txData_1$wset_1__VAL_4;
  wire [4 : 0] MUX_ifgCnt_value$write_1__VAL_2;
  wire [3 : 0] MUX_preambleCnt_value$write_1__VAL_2;
  wire [2 : 0] MUX_emitFCS$write_1__VAL_2;
  wire MUX_crc$add_1__SEL_1,
       MUX_emitFCS$write_1__SEL_1,
       MUX_ifgCnt_value$write_1__SEL_1;

  // remaining internal signals
  reg [1 : 0] CASE_txf_put_BITS_9_TO_8_3_0_txf_put_BITS_9_TO_ETC__q1;
  wire lenCnt_value_1_ULT_60___d103, preambleCnt_value_5_ULT_7___d118;

  // action method txf_put
  assign RDY_txf_put = txF$FULL_N ;

  // value method txUnderflow
  assign txUnderflow = underflow ;
  assign RDY_txUnderflow = 1'd1 ;

  // value method gmii_txd
  assign gmii_txd = txData ;

  // value method gmii_tx_en
  assign gmii_tx_en = txDV ;

  // value method gmii_tx_er
  assign gmii_tx_er = txER ;

  // submodule crc
  mkCRC32 crc(.CLK(CLK),
	      .RST_N(RST_N),
	      .add_data(crc$add_data),
	      .EN_add(crc$EN_add),
	      .EN_clear(crc$EN_clear),
	      .EN_complete(crc$EN_complete),
	      .RDY_add(),
	      .RDY_clear(),
	      .result(crc$result),
	      .RDY_result(),
	      .complete(),
	      .RDY_complete());

  // submodule txF
  FIFO2 #(.width(32'd10), .guarded(32'd1)) txF(.RST_N(RST_N),
					       .CLK(CLK),
					       .D_IN(txF$D_IN),
					       .ENQ(txF$ENQ),
					       .DEQ(txF$DEQ),
					       .CLR(txF$CLR),
					       .D_OUT(txF$D_OUT),
					       .FULL_N(txF$FULL_N),
					       .EMPTY_N(txF$EMPTY_N));

  // rule RL_egress_SOF
  assign WILL_FIRE_RL_egress_SOF =
	     txF$EMPTY_N && txF$D_OUT[9:8] == 2'd0 && ifgCnt_value == 5'd0 ;

  // rule RL_egress_Body
  assign WILL_FIRE_RL_egress_Body = txF$EMPTY_N && txF$D_OUT[9:8] == 2'd1 ;

  // rule RL_egress_EOF
  assign WILL_FIRE_RL_egress_EOF = txF$EMPTY_N && txF$D_OUT[9:8] == 2'd2 ;

  // rule RL_egress_FCS
  assign WILL_FIRE_RL_egress_FCS =
	     emitFCS != 3'd0 && !WILL_FIRE_RL_egress_EOF &&
	     !WILL_FIRE_RL_egress_Body &&
	     !WILL_FIRE_RL_egress_SOF ;

  // inputs to muxes for submodule ports
  assign MUX_crc$add_1__SEL_1 =
	     WILL_FIRE_RL_egress_SOF && !preambleCnt_value_5_ULT_7___d118 &&
	     preambleCnt_value != 4'd7 ;
  assign MUX_emitFCS$write_1__SEL_1 =
	     WILL_FIRE_RL_egress_EOF && !lenCnt_value_1_ULT_60___d103 ;
  assign MUX_ifgCnt_value$write_1__SEL_1 =
	     WILL_FIRE_RL_egress_FCS && emitFCS == 3'd1 ;
  assign MUX_crc$add_1__VAL_3 =
	     lenCnt_value_1_ULT_60___d103 ? 8'd0 : txF$D_OUT[7:0] ;
  assign MUX_emitFCS$write_1__VAL_2 = emitFCS - 3'd1 ;
  assign MUX_ifgCnt_value$write_1__VAL_2 =
	     (ifgCnt_value == 5'd0) ? ifgCnt_value : ifgCnt_value - 5'd1 ;
  assign MUX_lenCnt_value$write_1__VAL_1 =
	     (lenCnt_value == 12'd2047) ?
	       lenCnt_value :
	       lenCnt_value + 12'd1 ;
  assign MUX_preambleCnt_value$write_1__VAL_2 =
	     (preambleCnt_value == 4'd7) ?
	       preambleCnt_value :
	       preambleCnt_value + 4'd1 ;
  always@(emitFCS or crc$result)
  begin
    case (emitFCS)
      3'd1: MUX_txData_1$wset_1__VAL_2 = crc$result[7:0];
      3'd2: MUX_txData_1$wset_1__VAL_2 = crc$result[15:8];
      3'd3: MUX_txData_1$wset_1__VAL_2 = crc$result[23:16];
      default: MUX_txData_1$wset_1__VAL_2 = crc$result[31:24];
    endcase
  end
  assign MUX_txData_1$wset_1__VAL_4 =
	     preambleCnt_value_5_ULT_7___d118 ?
	       8'd85 :
	       ((preambleCnt_value == 4'd7) ? 8'd213 : txF$D_OUT[7:0]) ;

  // inlined wires
  always@(WILL_FIRE_RL_egress_Body or
	  txF$D_OUT or
	  WILL_FIRE_RL_egress_FCS or
	  MUX_txData_1$wset_1__VAL_2 or
	  WILL_FIRE_RL_egress_EOF or
	  MUX_crc$add_1__VAL_3 or
	  WILL_FIRE_RL_egress_SOF or MUX_txData_1$wset_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_egress_Body: txData_1$wget = txF$D_OUT[7:0];
      WILL_FIRE_RL_egress_FCS: txData_1$wget = MUX_txData_1$wset_1__VAL_2;
      WILL_FIRE_RL_egress_EOF: txData_1$wget = MUX_crc$add_1__VAL_3;
      WILL_FIRE_RL_egress_SOF: txData_1$wget = MUX_txData_1$wset_1__VAL_4;
      default: txData_1$wget = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign txData_1$whas =
	     WILL_FIRE_RL_egress_Body || WILL_FIRE_RL_egress_FCS ||
	     WILL_FIRE_RL_egress_EOF ||
	     WILL_FIRE_RL_egress_SOF ;
  assign txDV_1$wget = 1'd1 ;
  assign txDV_1$whas =
	     WILL_FIRE_RL_egress_FCS || WILL_FIRE_RL_egress_EOF ||
	     WILL_FIRE_RL_egress_Body ||
	     WILL_FIRE_RL_egress_SOF ;
  assign txER_1$wget = 1'b0 ;
  assign txER_1$whas = 1'b0 ;
  assign underflow_1$wget = 1'b0 ;
  assign underflow_1$whas = 1'b0 ;
  assign preambleCnt_incAction$whas =
	     WILL_FIRE_RL_egress_SOF &&
	     (preambleCnt_value_5_ULT_7___d118 || preambleCnt_value == 4'd7) ;
  assign preambleCnt_decAction$whas = 1'b0 ;
  assign ifgCnt_incAction$whas = 1'b0 ;
  assign ifgCnt_decAction$whas = ifgCnt_value != 5'd0 ;
  assign lenCnt_incAction$whas =
	     WILL_FIRE_RL_egress_SOF && !preambleCnt_value_5_ULT_7___d118 &&
	     preambleCnt_value != 4'd7 ||
	     WILL_FIRE_RL_egress_FCS ||
	     WILL_FIRE_RL_egress_EOF ||
	     WILL_FIRE_RL_egress_Body ;
  assign lenCnt_decAction$whas = 1'b0 ;

  // register emitFCS
  assign emitFCS$D_IN =
	     MUX_emitFCS$write_1__SEL_1 ? 3'd4 : MUX_emitFCS$write_1__VAL_2 ;
  assign emitFCS$EN =
	     WILL_FIRE_RL_egress_EOF && !lenCnt_value_1_ULT_60___d103 ||
	     WILL_FIRE_RL_egress_FCS ;

  // register ifgCnt_value
  assign ifgCnt_value$D_IN =
	     MUX_ifgCnt_value$write_1__SEL_1 ?
	       5'd12 :
	       MUX_ifgCnt_value$write_1__VAL_2 ;
  assign ifgCnt_value$EN =
	     WILL_FIRE_RL_egress_FCS && emitFCS == 3'd1 ||
	     ifgCnt_value != 5'd0 ;

  // register lenCnt_value
  assign lenCnt_value$D_IN = MUX_lenCnt_value$write_1__VAL_1 ;
  assign lenCnt_value$EN = lenCnt_incAction$whas ;

  // register preambleCnt_value
  assign preambleCnt_value$D_IN =
	     MUX_crc$add_1__SEL_1 ?
	       4'd0 :
	       MUX_preambleCnt_value$write_1__VAL_2 ;
  assign preambleCnt_value$EN =
	     WILL_FIRE_RL_egress_SOF && !preambleCnt_value_5_ULT_7___d118 &&
	     preambleCnt_value != 4'd7 ||
	     preambleCnt_incAction$whas && !WILL_FIRE_RL_egress_SOF ;

  // register txActive
  assign txActive$D_IN = !MUX_emitFCS$write_1__SEL_1 ;
  assign txActive$EN =
	     WILL_FIRE_RL_egress_EOF && !lenCnt_value_1_ULT_60___d103 ||
	     WILL_FIRE_RL_egress_SOF ;

  // register txDV
  assign txDV$D_IN = txDV_1$whas ;
  assign txDV$EN = 1'd1 ;

  // register txData
  assign txData$D_IN = txData_1$whas ? txData_1$wget : 8'd0 ;
  assign txData$EN = 1'd1 ;

  // register txER
  assign txER$D_IN = 1'b0 ;
  assign txER$EN = 1'd1 ;

  // register underflow
  assign underflow$D_IN = 1'b0 ;
  assign underflow$EN = 1'd1 ;

  // submodule crc
  assign crc$add_data =
	     (MUX_crc$add_1__SEL_1 || WILL_FIRE_RL_egress_Body) ?
	       txF$D_OUT[7:0] :
	       MUX_crc$add_1__VAL_3 ;
  assign crc$EN_add =
	     WILL_FIRE_RL_egress_SOF && !preambleCnt_value_5_ULT_7___d118 &&
	     preambleCnt_value != 4'd7 ||
	     WILL_FIRE_RL_egress_Body ||
	     WILL_FIRE_RL_egress_EOF ;
  assign crc$EN_clear = 1'b0 ;
  assign crc$EN_complete = 1'b0 ;

  // submodule txF
  assign txF$D_IN =
	     { CASE_txf_put_BITS_9_TO_8_3_0_txf_put_BITS_9_TO_ETC__q1,
	       txf_put[7:0] } ;
  assign txF$ENQ = EN_txf_put ;
  assign txF$DEQ =
	     WILL_FIRE_RL_egress_SOF && !preambleCnt_value_5_ULT_7___d118 &&
	     preambleCnt_value != 4'd7 ||
	     WILL_FIRE_RL_egress_EOF && !lenCnt_value_1_ULT_60___d103 ||
	     WILL_FIRE_RL_egress_Body ;
  assign txF$CLR = 1'b0 ;

  // remaining internal signals
  assign lenCnt_value_1_ULT_60___d103 = lenCnt_value < 12'd60 ;
  assign preambleCnt_value_5_ULT_7___d118 = preambleCnt_value < 4'd7 ;
  always@(txf_put)
  begin
    case (txf_put[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_txf_put_BITS_9_TO_8_3_0_txf_put_BITS_9_TO_ETC__q1 =
	      txf_put[9:8];
      2'd3: CASE_txf_put_BITS_9_TO_8_3_0_txf_put_BITS_9_TO_ETC__q1 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        emitFCS <= `BSV_ASSIGNMENT_DELAY 3'd0;
	ifgCnt_value <= `BSV_ASSIGNMENT_DELAY 5'd0;
	lenCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	preambleCnt_value <= `BSV_ASSIGNMENT_DELAY 4'd0;
	txActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txDV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txData <= `BSV_ASSIGNMENT_DELAY 8'd0;
	txER <= `BSV_ASSIGNMENT_DELAY 1'd0;
	underflow <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (emitFCS$EN) emitFCS <= `BSV_ASSIGNMENT_DELAY emitFCS$D_IN;
	if (ifgCnt_value$EN)
	  ifgCnt_value <= `BSV_ASSIGNMENT_DELAY ifgCnt_value$D_IN;
	if (lenCnt_value$EN)
	  lenCnt_value <= `BSV_ASSIGNMENT_DELAY lenCnt_value$D_IN;
	if (preambleCnt_value$EN)
	  preambleCnt_value <= `BSV_ASSIGNMENT_DELAY preambleCnt_value$D_IN;
	if (txActive$EN) txActive <= `BSV_ASSIGNMENT_DELAY txActive$D_IN;
	if (txDV$EN) txDV <= `BSV_ASSIGNMENT_DELAY txDV$D_IN;
	if (txData$EN) txData <= `BSV_ASSIGNMENT_DELAY txData$D_IN;
	if (txER$EN) txER <= `BSV_ASSIGNMENT_DELAY txER$D_IN;
	if (underflow$EN) underflow <= `BSV_ASSIGNMENT_DELAY underflow$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    emitFCS = 3'h2;
    ifgCnt_value = 5'h0A;
    lenCnt_value = 12'hAAA;
    preambleCnt_value = 4'hA;
    txActive = 1'h0;
    txDV = 1'h0;
    txData = 8'hAA;
    txER = 1'h0;
    underflow = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkTxRS

